{"./":{"url":"./","title":"实验简介","keywords":"","body":"MiniDecaf 编译实验 实验手册指北：实验文档看起来会有一些长，是因为编译器本身就是一个庞大的系统，我们希望提供尽可能全面的内容来帮助大家理解框架的构成。请大家认真阅读文档，并且尽可能按照文档去动手试一试，而不是直接开始动手写作业。 实验概述 MiniDecaf 1 是一个 C 的子集，去掉了include/define等预处理指令，多文件编译支持，以及结构体/指针等语言特性。 本学期的编译实验要求同学们通过多次“思考-实现-重新设计”的过程，一步步实现从简单到复杂的 MiniDecaf 语言的完整编译器，能够把 MiniDecaf 代码编译到 RISC-V 汇编代码。进而深入理解编译原理和相关概念，同时具备基本的编译技术开发能力，能够解决编译技术问题。MiniDecaf 编译实验分为多个 stage，每个 stage 包含多个 step。每个 step 大家都会完成一个可以运行的编译器，把不同的 MiniDecaf 程序代码编译成 RISC-V 汇编代码，可以在 QEMU/SPIKE 硬件模拟器上执行。随着实验内容一步步推进，MiniDecaf 语言将从简单变得复杂。每个步骤都会增加部分语言特性，以及支持相关语言特性的编译器结构或程序（如符号表、数据流分析方法、寄存器分配方法等）。下面是采用 MiniDecaf 语言实现的快速排序程序，与 C 语言相同。 int qsort(int a[], int l, int r) { int i = l; int j = r; int p = a[(l+r)/2]; while (i p) j = j - 1; if (i > j) break; int u = a[i]; a[i] = a[j]; a[j] = u; i = i + 1; j = j - 1; } if (i l) qsort(a, l, j); return 0; } 2025 年秋季学期基本沿用了往年《编译原理》课程的语法规范。为了贴合课程教学内容，提升训练效果，课程组设计了比较完善的编译器框架，包括词法分析、语法分析、语义分析、中间代码生成、数据流分析、寄存器分配、目标平台汇编代码生成等步骤。每个 step 同学们都会面对一个完整的编译器流程，但不必担心，实验开始的几个 step 涉及的编译器框架知识都比较初级，随着课程实验的深入，将会循序渐进地引入各个编译器功能模块，并通过文档对相关技术进行分析介绍，便于同学们实现相关编译功能模块。 实验起点和基本要求 本次实验一共设置 14 个步骤（其中 step 0 和 step 1 为实验框架熟悉，不需要修改框架代码）。后续的 step 2-13 我们将由易到难完成 MiniDecaf 语言的所有特性，由于编译器的边界情况很多，你只需通过我们提供的正例与负例即可。此外，parser step 为同学们提供了一个上手语法分析器的机会。 我们以 stage 组织实验，各个 stage 组织如下： 第一个编译器（step0-step1）。我们给的实验框架可以通过所有测试用例，你需要做的事情为跟着文档阅读学习实验框架代码。请各位同学注意，stage0 尤为重要，掌握好实验框架是高质量和高效率完成后续实验的保证。 常量表达式（step2-step4）。在这个 stage 中你将实现常量操作（加减乘除模等）。 变量和赋值（step5）。在这个 stage 中你将第一次支持变量声明与赋值。 作用域和块语句（step6）。在这个 stage 中你的编译器将支持作用域，以便支持后续的条件和循环。 手工自顶向下语法分析器（parser step）。在这个 step 中你将实现一个手工的自顶向下语法分析器，来替代当前框架中使用的 ANTLR 生成的语法分析器。 这个语法分析器只需要支持前面的几个 step，在随后的各个 step 中我们仍然使用 ANTLR 生成的语法分析器。 条件和循环（step7-step8）。在这个 stage 中你将支持条件判断和循环语句，此时，你的编译器可以编译的程序就从线性结构程序到了有分支结构的程序。 函数（step9）。在这个 stage 中你将支持函数的声明和调用，这样你就可以写很多有意思的代码了。 全局变量和数组（step10-step12）。在这个 stage 中，你将支持全局变量和数组，数组中包括全局数组和局部数组。 寄存器分配算法（step13）。在这个 stage 中，你将实现基于图染色的寄存器分配算法，替代当前框架中简单的启发式算法。 其中，stage0 为环境配置和框架学习，无需进行编程，不计入成绩。 stage1 - stage4 与 parser-stage 为 5 个基础关卡，你需要通过它们以拿到一定的分数（35%）。 stage5 为升级关卡，如果你学有余力，完成它们可以减少期末考试在总评中所占的比重（完整完成可以获得占总评 7% 的成绩并替代期末考试对应权重）。 stage6 为进阶关卡，如果你依然学有余力，你可以在这里实现一些编译优化（完整完成可以获得占总评 8% 的成绩并替代期末考试对应权重）。注意，你需要在完成 stage5 后才能尝试 stage6，否则无法获得对应分数。 我们以 step 组织文档，每个 step 的文档都将以如下形式组织：首先我们会介绍当前 step 需要用到的知识点，其次我们会以一个当前 step 具有代表性的例子介绍它的整个编译流程。在之前 step 中已经介绍的知识点，我们会略过，新的知识点和技术会被详细介绍。 我们通过问答墙来集中解决大家在环境配置及完成实验中遇到的问题。如果你遇到了任何问题，都可以在问答墙中检索；如果你的问题尚未有其他人提问过，欢迎向助教提问，助教会尽快回复的。 诚信守则 请注意，诚信守则是参加本课程的学生应遵守的道德行为规范。实验指导中给出的生成结果（抽象语法树、三地址码、汇编）只是一种参考的实现，同学们可以按照自己的方式实现，只要能够通过测试用例即可。但是，严格杜绝抄袭现象，如果代码查重过程中发现有抄袭现象，抄袭者与主动提供抄袭信息的被抄袭者将被记为0分。 实验提交 大家在网络学堂提交 git.tsinghua.edu.cn 的帐号名后，助教会给每个人建立一个私有的仓库，URL 为 https://git.tsinghua.edu.cn/compiler25/stu25/minidecaf-你的学号 ，将作业提交到那个仓库即可。 每个 stage 会对应于一个 branch，当切换到一个新的 branch 上实现时，你可以用 git checkout -b 来创建一个新的分支。 本学期我们使用清华大学代码托管服务（git.tsinghua）的 CI（持续集成）来测试大家的代码实现及提交实验报告。 .gitlab-ci.yml 中描述了如何运行 CI，你不允许修改此文件； prepare.sh 是在测试前会运行的准备脚本，包括安装所需的依赖（python），如果你想添加新的依赖或者修改编译流程，请修改此文件。 在 CI 中会检查是否通过所有测例及是否有提交报告，只有通过所有测例且提交报告，才会被视为通过 CI。 我们只接受 pdf 格式的实验报告。你需要将报告放在仓库的 ./reports/.pdf 路径，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 ./reports/stage-1.pdf。 实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 评分标准 对于每个阶段（stage）： 80% 的成绩是自动化测试的结果，你可以直接在 git.tsinghua 的 CI 测试中看到。 20% 的成绩是实验报告，其中对实验内容的描述占 10%，对思考题的回答占 10%。 评分会以每个 stage 的 branch 最后一次触发的 CI 及触发此次 CI 的 commit 里的实验报告为准，详见补交政策。 如果你认为成绩有问题，请及时与助教联系。 时间安排及补交政策请看实验进度安排。 学术规范 由于实验有一定难度，同学之间相互学习和指导是提倡的。 对于其他同学的代码（包括实验报告中思考题的回答），可以参考，但禁止直接拷贝。 如有代码交给其他同学参考，必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 请所有同学不要将自己的代码托管至任何公开的仓库上（如 GitHub），托管至私有仓库的请不要给其他同学任何访问权限。 我们将会对所有同学的代码作相似度检查，如发现有代码雷同的情形，拷贝者和被拷贝者将会得到同样的处罚，除非被拷贝的同学提交时已做过声明。 代码雷同情节严重的，课程组有权上报至院系和学校，并按照相关规定严肃处理。 相关资源 实验指导书（首页有实验报告提交要求） 实验指导书勘误表 课程问答墙 实验思路指导与问答墙 参考资料 Writing a C Compiler: by Nora Sandler nqcc http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf 备注 1. 关于名字由来，由于往年的实验叫 Decaf，我们在新的且更简单的语言规范下复用了 Decaf 的编译器框架，所以今年的实验就叫 MiniDecaf 了。 ↩ "},"docs/misc/schedule.html":{"url":"docs/misc/schedule.html","title":"实验进度安排","keywords":"","body":"实验进度安排 所有截止时间均为所标日期的23:59:59（UTC+8），即第二天0点之前，如有特殊情况将会在网络学堂通知。 必做部分： 第三周周日（9.29）：Stage 0 截止 熟悉框架和基础知识 （占比：0%） stage 0 不需要你编写任何代码，stage 0的思考题请与stage 1一起提交。 第四周周日（10.6）：Stage 1 截止 常量表达式（占比：7%） 第六周周日（10.20）：Stage 2 截止 变量（占比：7%） 第八周周日（11.3）：Stage 3 截止 作用域（占比：7%） 第十周周日（11.17）：Stage 4 截止 控制语句（占比：7%） 第十四周周日（12.15）：Stage 5 截止 函数（占比：7%） 函数部分由于难度较大，给大家预留了四周时间，请大家不要等到最后一周再开始。 选做部分： 选做部分难度较大，且时间较紧，同学可能需要提前一些开始才能保证完成。 第十五周周日（12.22）：Stage 6 截止 全局变量和数组（占比：7%） 第十六周周日（12.29）：Stage 7 截止 寄存器分配与代码优化（占比：8%） 补交政策 假设 a 日 24:00 是某个 stage 的截止时间； a + k 日 24:00 前补交，此 stage 得分乘以 max(1 - (k / 20), 0.5)； 提交/补交时间是该 stage 截止后这个 stage 的 branch 最后一次触发 CI 的时间； 更具体来讲是创建 pipeline 的时间，而不是 pipeline 更新的时间，这几乎等于你 push 到远端仓库的时间。并且，你也可以随意地 retry 反复运行 CI，这不会对你的提交/补交产生影响。 如果在多次 retry 中你的代码会得到不一致的结果，请联系助教。 选做实验不接受补交。 "},"docs/step0/errate.html":{"url":"docs/step0/errate.html","title":"勘误表","keywords":"","body":"勘误表 在这里我们会列出与实验相关的勘误，它会和问答墙上的勘误部分保持一致。同学们遇到问题时，请先在勘误表中查找查看是否已有解答。   Q：使用 pip install -r ./requirements.txt 命令无法正确安装依赖？ A：如果你安装了多版本的 python，使用 pip 命令未必会对应 3.9 版本的包管理器。请尝试使用 python3.9 -m pip install -r ./requirements.txt 安装依赖。   Q： 代码框架 step7 中，由 multi_nesting.c 生成的以下中间代码无法成功生成目标代码。 经过使用 print 法调试，发现是 _T1 所对应的寄存器在 return _T1 前就被释放了，后端会尝试到栈中寻找 _T1 并且不会找到，出现报错： utils.error.IllegalArgumentException: error: encounter a non-returned basic block 请问是后端实现上有问题，还是这一部分本来就需要我们自己修改呢？ A：代码框架的后端除了要修改指令选择部分之外，还需要修改基本块 CFG，可以参见 BruteRegAlloc 的注释里给出的提示。   Q：我怎样才能知道我的提交通过了所有测试用例？ A：可以通过本地测试或者通过 CI 结果可以判断是否通过了本阶段测例（不过你需要确保你的提交在对应的 branch 上，如 stage1 对应 stage-1 分支）。   Q：如何提交课程报告？ A： 请将实验报告以 pdf 格式提交到 git.tsinghua 自己的仓库中，放在仓库根目录下的 reports/.pdf，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 reports/stage-1.pdf。 最新的 CI 会检查是否通过所有测例及是否有提交报告，只有通过所有测例且正确地提交报告，才会算作 pass。 如果关于报告提交有任何问题，请及时联系助教。 "},"docs/ref/riscv.html":{"url":"docs/ref/riscv.html","title":"RISC-V 参考资料","keywords":"","body":"RISC-V相关内容补充 RISC-V官方资料 不建议阅读，太过冗长，这对于编译知识提升非常有限。 RISC-V 官方 请下载ISA Specifications (Ratified)中的Volume 1, Unprivileged Specification。 如果你时间充足，你可以阅读： Chapter 24 RV32/64G Instruction Set Listings Chapter 25 RISC-V Assembly Programmer’s Handbook 如何快速查询RISC-V指令 在线编译器 你可以使用Compiler Explorer (godbolt.org)来快速获得一个riscv指令的实现 在左边输入以下例子 int mod(int x, int y) { // 注意：此处不要直接写一个可以计算得到结果的式子 // 比如5 % 8会被编译器优化为5 return x % y; } 把右边的编译器选为RISC-V(32-bits)中的任何一个，在编译选项中写上-O2（减少不必要的指令生成），翻译一条指令看看效果。 本地编译器 你可以通过 gcc 编译如下程序来了解如何翻译逻辑非运算符到 RISC-V 汇编 riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 foo.c -S -O3 -o foo.s（记得加 -O3 或者 -O2 选项）： int foo(int x) { return !x; } 不出意外你会获得如下结果： foo: seqz a0,a0 ret "},"docs/step0/intro.html":{"url":"docs/step0/intro.html","title":"实验环境简介","keywords":"","body":"实验环境简介 2025 年秋季学期，助教给大家提供了服务器。同学们可以选择使用我们已经配置好的机器，节省一定的时间花费。 服务器环境如下： Ubuntu 23.04 python 3.11.4 注意： 禁止大家在服务器上安装软件、运行与课程实验无关的程序或者破环系统环境。否则将有可能受到惩罚。 为了安全起见，服务器仅可通过校内网络访问。 服务器的地址、账号和密码会通过网络学堂发给大家，请登录网络学堂查收。 提示： 如何使用 ssh 登陆服务器？ ssh username@ip -p port # 假如你的账号为 2023000001，服务器 ip 地址为 192.168.1.1，端口为 223，则命令为： ssh 2023000001@192.168.1.1 -p 223 建议配置 ssh 免密登录，方便大家使用服务器，然后在服务器上运行。你可以参考这里。 vscode 也是可以使用ssh远程写代码的，参考这里。 如果你使用我们提供的服务器，你可以直接来看RISC-V 的工具链使用和运行实验框架。 "},"docs/step0/riscv_env.html":{"url":"docs/step0/riscv_env.html","title":"RISC-V 环境配置","keywords":"","body":"RISC-V 环境配置 必做：RISC-V 的 gcc 和 qemu 我们的编译器只生成 RISC-V 汇编，然后再使用 gcc 把 RISC-V 汇编变成 RISC-V 可执行文件，最后用 qemu/spike 等模拟器来运行 RISC-V 可执行文件。 注意这里的 gcc 和常说的 gcc 不一样。 常说的 gcc 运行在我们的 x86 机器上、把 C 编译到 x86 可执行文件； 而这里的 gcc 虽然也运行在我们的 x86 机器上，却要编译到 RISC-V 可执行文件。 这种“gcc 跑在 x86 却编译出 RISC-V 代码”的操作被称为交叉编译（cross compilation）。 因此我们不能直接使用有些系统自带的 gcc，这种 gcc 生成的可执行程序只能在你本机（x86）上运行。 我们需要下载安装 riscv64-unknown-elf-gcc，用来生成 RISC-V 可执行程序。 建议各位同学使用我们提供的 RISC-V 工具链，由 SiFive 预编译的较新版本的工具链对 32 位的支持存在问题。 我们提供了预编译的 riscv64-unknown-elf-gcc 和 qemu/spike 模拟器，不过只能在 Linux/Mac 下运行（qemu 对应 Linux，spike 对应 Mac），Windows 的同学可以使用 WSL，或者运行一个虚拟机。 命令行基础操作我们就不赘述了，大家可以自己在网上查找资料。 下面是环境配置指南，请阅读自己的系统的那一小节。 你的编译器 gcc qemu/spike MiniDecaf 源文件 ------------> RISC-V 汇编 -----> 可执行文件 --------> 输出 Windows 用户环境配置指南 下面描述了 WSL 的一种参考方法。 你还可以开一个 Linux 虚拟机，使用 Virtualbox 或 VMWare 等，然后参考下面 Linux 配置。 Win10 设置 参考 https://blog.csdn.net/daybreak222/article/details/87968078 ，设置“开发者模式”以及“启用子系统功能”。 打开Microsoft Store，搜索Ubuntu，选择ubuntu20.04. 按照下面的 Linux 用户环境配置指南安装 riscv 工具链。 Ubuntu 用户环境配置指南 建议使用 Ubuntu 20.04 及更高的版本，你可以直接使用 apt 来安装用户态的 qemu，即 apt install qemu-user。 如果使用的是低版本的 WSL，通过 Windows 应用商店可以很容易地安装 Ubuntu 20.04 LTS; 如果在机器上直接安装了较低版本的 Ubuntu, 可以参考这个教程进行升级，升级时注意备份。 如果出于某些原因必须使用低版本的 Ubuntu，你需要自己编译出可用的用户态 QEMU。 git clone https://mirrors.tuna.tsinghua.edu.cn/git/qemu.git cd qemu && ./configure --prefix=/usr/local --target-list=riscv32-linux-user make make install qemu-riscv32 --version # 检查是否安装成功 从这里下载预编译好的 RISC-V 工具链并解压。 安装工具链 cp riscv64-unknown-elf-gcc-10.1.0-2020.08.2-x86_64-linux-ubuntu14/* /usr/ -r 在第 2. 步，你可以选择不安装到系统目录下。相应的，你需要设置环境变量： 首先把文件夹riscv64-unknown-elf-gcc-10.1.0-2020.08.2-x86_64-linux-ubuntu14/改名为 riscv-prebuilt（这一步实际不是必须的，主要为缩短文件夹名字的长度），然后修改~/.bashrc 文件, 把export PATH=$PATH:/path/to/riscv-prebuilt/bin加入到.bashrc文件的末尾。注意，此处的/path/to 需要替换解压文件夹所在目录。每次修改.bashrc文件后，都需要执行命令source ~/.bashrc使修改生效。 （如果你不用系统自带的 bash 而是用 zsh 之类的 shell，那加到 ~/.zshrc 等 shell 配置文件里） macOS 用户环境配置指南 从这里下载预编译好的 RISC-V 工具链并解压到你喜欢的目录。 由于 macOS 不支持 QEMU 的用户态模式，我们使用 Spike 模拟器和一个简易内核 riscv-pk 提供用户态程序的运行环境。你可以选择下面两种安装方法中的任意一种： 从这里下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，不过还需要通过 Homebrew 安装依赖 device tree compiler： $ brew install dtc 通过 Homebrew 安装 Spike（会自动安装 dtc）： $ brew tap riscv/riscv $ brew install riscv-isa-sim 然后从这里上下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，只用里面的 pk。 Homebrew 也提供了 riscv-pk，不过那是 64 位的，而我们需要 32 位的，请使用我们预编译的 riscv-pk 或自行编译。 请注意我们提供的预编译 pk 是 x86 版本，如果你是其他平台（如M1 Mac），可以尝试自行根据 pk 的源码进行编译，附 Github 仓库链接。 （可选）设置环境变量，方法与 Linux 一样，见上一节。如果不设置每次使用 gcc 和 spike 时都要输入完整路径。不过对于 pk 设置环境变量不管用，要么把它放到系统目录 /usr/local/bin/pk，要么每次都用完整路径。 测试你 GCC 和 Spike 是否成功安装，详见RISC-V 的工具链使用。 必做：测试你是否正确配置好了环境 创建 test.c 文件，其中写入如下内容 #include int main() { printf(\"Hello world!\\n\"); } 编译 test.c 文件，gcc 应该输出一个可执行文件 a.out。但 a.out 是 RISC-V 可执行文件，所以我们的 X86 计算机无法运行。 $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 test.c $ ls a.out a.out $ ./a.out # 如果没有安装qemu模拟器，则会出现如下错误:\"bash: ./a.out: cannot execute binary file: Exec format error\" 后面RISC-V 的工具链使用总结了 gcc 和 qemu 在编译实验中可能需要的用法。 使用 qemu 执行 a.out，具体操作如下 Linux用户 $ qemu-riscv32 a.out Hello world! 注意：安装了qemu之后，直接运行 ./a.out 往往也可以调用qemu环境正确执行，并得到\"Hello world!\"输出。 Mac OS用户，假设你已经将spike加入环境变量，将pk加入系统目录 $ spike --isa=RV32G pk a.out bbl loader Hello world! 备注 1. 开头的 $ 表示接下来是一条命令，记得运行的时候去掉 $。例如，让你运行 $ echo x，那你最终敲到终端里的是 echo x（然后回车）。如果开头没有 $，那么这一行是上一条命令的输出（除非我们特别说明，这一行是你要输入的内容）。 ↩ "},"docs/step0/riscv.html":{"url":"docs/step0/riscv.html","title":"RISC-V 的工具链使用","keywords":"","body":"RISC-V 相关信息 RISC-V 是一个很像 MIPS 的 RISC 指令集架构，编译实验要求你的编译器把 MiniDecaf 程序编译到 RISC-V 汇编。 指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"。 另外这里也有（非官方的）指令用法说明。 不过事实上，很多时候看 gcc 输出的汇编比看什么文档都有用。 RISC-V 工具使用 我们提供预先编译好的 RISC-V 工具，在环境配置中已经叙述了安装和使用方法。 下面汇总一下。 注意，我们虽然是用的工具前缀是 riscv64， 但我们加上参数 -march=rv32im -mabi=ilp32 以后就能编译到 32 位汇编 1。 使用时记得加这个参数，否则默认编译到 64 位汇编。 我们假设你已经正确设置好了环境变量，否则运行 riscv64-unknown-elf-gcc 或 qemu-riscv32 或 spike 时请用完整路径。 gcc 编译 input.c 到汇编 input.s，最高优化等级（否则输出的汇编会很冗长） # input.c 的内容 $ cat input.c int main(){return 233;} # 编译到 input.s $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c # gcc 的编译结果 $ cat input.s .file \"input.c\" .option nopic .attribute arch, \"rv32i2p0_m2p0\" .attribute unaligned_access, 0 .attribute stack_align, 16 .text .section .text.startup,\"ax\",@progbits .align 2 .globl main .type main, @function main: li a0,233 ret .size main, .-main .ident \"GCC: (SiFive GCC 8.3.0-2020.04.0) 8.3.0\" gcc 编译 input.s 到可执行文件 a.out # input.s 的内容，就是上面汇编输出的简化版本 $ cat input.s .text .globl main main: li a0,233 ret # 编译到 a.out $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 input.s # 输出结果，能看到是 32 位的 RISC-V 可执行文件 $ file a.out a.out: ELF 32-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped 【Linux 用户】qemu 运行 a.out，获取返回码 # 运行 a.out $ qemu-riscv32 a.out # $? 是 qemu 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 【macOS 用户】Spike 模拟器运行 a.out，获取返回码 # 运行 a.out # /usr/local/bin/pk 替换为你自己的 pk 路径 $ spike --isa=RV32G /usr/local/bin/pk a.out bbl loader # $? 是 spike 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 1. 这里的 rv32im 表示使用 RV32I 基本指令集，并包含 M 扩展（乘除法）。本实验中我们不需要其他扩展。 ↩ "},"docs/step0/env.html":{"url":"docs/step0/env.html","title":"实验框架环境配置","keywords":"","body":"实验框架环境配置 Python 实验框架环境配置 关于操作系统，助教推荐使用 Linux 环境（如 Ubuntu，Debain 或 Windows 下的 WSL 等），当然你也可以在类 Unix 系统环境（Mac OS）中进行开发。助教不推荐直接在 Window 中搭建开发环境。你需要安装或保证如下软件满足我们的要求： python >= 3.9 助教强烈建议使用类似 Miniconda 或venv的系统管理不同的Python环境。你可以方便地使用miniconda安装最新的Python版本，安装好之后使用pip安装依赖即可。 框架本身在 python 3.9 下进行开发，使用了 python 3.9 的新特性，请保证你所使用的 python 版本高于此版本。 如果你没有使用虚拟环境，可以参考下面的指导。Linux 环境下安装 Python 3 可以尝试如下命令： > sudo add-apt-repository ppa:deadsnakes/ppa > sudo apt update > sudo apt install python3 此外，如果安装了多个版本的 python，可以通过 update-alternatives 命令修改 python 版本使用的优先级，对所有服务器用户都有效，具体用法可参见这里。你可以通过此命令来检查当前优先的 Python3 版本： > python3 --version 框架里已经提供了需要的 python 包列表文件 requirements.txt，你可以通过 pip 命令安装下文提到的 python 依赖包 ply 和 argparse： $ python3 -m pip install -r ./requirements.txt argparse 框架使用了 argparse 以处理命令行参数。官方文档中提供了它的教程。 ply ply是一个自动生成词法分析器和语法分析器的工具，其中ply.lex为词法分析相关的模块而ply.yacc为语法分析相关。可以参考 ply 的文档。 助教在项目中使用 type hints，如果你习惯在 vscode 中进行开发的话同时推荐使用 pylance 这一插件。 由于 python 的跨平台性，理论上也可以在 Windows 下进行开发。但不保证Windows和在线测试环境下程序行为的一致性。 "},"docs/step0/testing.html":{"url":"docs/step0/testing.html","title":"运行实验框架","keywords":"","body":"运行实验框架 配好环境以后，我们强烈推荐你构建运行我们提供的实验框架初始代码。 接下来我们会用到 git。 git 的安装和使用会在软件工程课上讲述，同学们也自行查阅相关资料，也可以参考这里 。 按照本文档的前几节（RISCV 环境配置和实验框架环境配置）配置好实验环境。 助教已经为每位同学在 git.tsinghua.edu.cn 创建了一个仓库，其中 minidecaf 的测例仓库为其中的一个子模块，你可以通过以下指令来在克隆主仓库的同时克隆子模块 git clone --recursive 。 由于测例仓库会有所更新，在克隆之后你需要在主仓库目录下使用 git submodule update --remote --merge 来手动更新。 注意：由于子模块使用 ssh 链接，你需要将你的 ssh 公钥添加到你的 git.tsinghua 账号上，才能将其克隆下来。 按照测例的 README 运行测试 step1，实验框架给出的初始代码可以通过 step1 的所有测例。 测试运行的 输出结果 大致如下。 $ STEP_UNTIL=1 ./check.sh gcc found qemu found parallel found OK testcases/step1/multi_digit.c OK testcases/step1/newlines.c ...... 其他测试点，太长省略 "},"docs/step1/arch.html":{"url":"docs/step1/arch.html","title":"MiniDecaf 编译器结构","keywords":"","body":"MiniDecaf 编译器结构 MiniDecaf 编译器大致划分为三个部分：前端、中端、后端。通过编译器前端，可以读入 MiniDecaf 源程序，然后通过词法分析和语法分析将源程序转化为一个抽象语法树(Abstract Syntax Tree, AST)，接下来通过扫描 AST 进行语义分析，检查是否存在语义错误；在编译器中端，通过扫描 AST 生成中间代码 —— 三地址码；在编译器后端中，将三地址码转换为 RISC-V 汇编代码。下面依次介绍上述编译步骤，以及对应框架代码的位置。 我们在这里针对每个步骤只是简要介绍，目的是给同学们一个大致的印象：编译器到底是由哪些部分组成的，这些部分又有什么作用。具体的技术点，我们将在用到的 step 作详细介绍。 词法分析和语法分析 此部分对应框架源码位置： 词法分析程序位于 frontend/lexer/；语法分析程序位于 frontend/parser/；语法树位于 frontend/ast/。 编译器前端分为两个子任务，一是词法分析，二是语法分析。词法分析的功能是从左到右扫描 MiniDecaf 源程序，识别出程序源代码中的标识符、保留字、整数常量、算符、分界符等单词符号（即终结符），并把识别结果返回给语法分析器，以供语法分析器使用。语法分析的功能是在词法分析的基础上针对所输入的终结符串建立语法树，并对不符合语法规则的 MiniDecaf 程序进行报错处理。一般而言，这一步所生成的语法树并非表示了所有语法细节的语法分析树，而是只表示其树形结构的抽象语法树（Abstract Syntax Tree, AST）。比如，对于下面这一段简单的MiniDecaf 代码： if (i) i = 1; 它对应的完整语法分析树可能长这样： if_stmt |- \"if\" |- \"(\" |- Identifier(\"i\") |- \")\" |- assign_stmt |- Identifier(\"i\") |- \"=\" |- Int(1) |- \";\" 其中双引号下的和大写字母开头的都为词法分析器产出的终结符。而对应的抽象语法树可能长这样： if_stmt |- (condition) Identifier(\"i\") |- (body) assign_stmt |- (lh) Identifier(\"i\") |- (rh) Int(1) AST省略掉了完整的语法分析树中不必要的细节（例如条件表达式旁边的括号），有利于简化树的结构与后续对树的处理。 词法分析和语法分析的最终结果是一棵跟所输入的 MiniDecaf 源程序相对应的语法树。本阶段的实验重点是掌握 LEX 和 YACC 的用法，了解编译器自动构造工具的特点，并且结合实验内容理解正规表达式、自动机、LALR(1) 分析等理论知识在实践中的应用。 语义分析 此部分对应框架源码位置： 符号表构建位于 frontend/typecheck/namer.py；类型检查位于 frontend/typecheck/typer.py；符号表相关的数据结构位于frontend/symbol/；作用域相关数据结构位于 frontend/scope/。 语法分析树的建立可以说明所输入的 MiniDecaf 源程序在语法规范上是合法的，但是要进行有效的翻译，编译器还需要理解每个程序语句的含义。了解程序含义的过程称为语义分析。 可以把语义分析过程分为两个部分：分析符号含义和检查语义正确性。分析符号含义是指对于表达式中所出现的符号，找出该符号所代表的内容，这个工作主要通过检索符号表来实现。检查语义正确性指的是检查每条语句是否合法，比如检查每个表达式的操作数是否符合要求，每个表达式是否为语言规范中所规定的合法的表达式，使用的变量是否都经过声明等。程序代码通过了词法和语法分析，其语义未必正确，因此未必是合法的语句。不合法的语句的具体含义在语言规范中没有规定，从而使得编译器无法确定这些语句的确切含义，所以检查语义的正确性是很有必要的。如果一个程序成功通过语义分析，则说明这个程序的含义对于编译器来说是明确的，翻译工作可以继续进行。 具体来说，在这一阶段中，我们需要对 AST 进行两遍扫描，分别完成以下的检查： 符号表构建：声明了哪些标识符，待编译程序使用的标识符对应于哪个位置的声明。 类型检查：各语句和表达式是否类型正确。 如果在语义分析阶段发现错误，那么整个编译过程在这一阶段结束后将终止，并报告编译错误。所有的语义错误都应该在这一阶段，且只应该在这一阶段报告。下面分别介绍符号表构建和类型检查的内容。 符号表构建 针对 MiniDecaf 程序中所有定义的标识符，包括函数名和变量名，我们统一用一种具有层次结构的符号表来维护。使用符号表的好处包括：(1) 在分析各语句和表达式时，若它们引用了某些标识符，我们可以在符号表中查询这些标识符是否有定义以及相关信息（如类型）；(2) 符号表的层次结构与作用域是一一对应的，便于检查出符号定义是否有冲突，以及确定不同作用域引用的标识符。 step1-4 中只需要考虑常量的计算，直到 step5 才需要考虑符号表构建。 类型检查 完成符号表构建后，我们就可以自顶向下地遍历 AST，对每个语句和表达式逐一进行类型检查，并在 AST 上进行类型标注。对于静态类型（statically-typed）语言，在语言设计之初，设计者都会考虑该语言支持表达哪些类型，并给出定型规则（typing rules）。 在已知定型规则的情况下编码实现类型检查算法并不困难——往往只要逐条将其翻译为代码即可。 事实上，由于 MiniDecaf 代码的基本类型只有整数类型（int），因此我们在类型检查时只需要考虑 int 和 int 数组两种类型。在支持数组（step11）之前，都基本不需要考虑类型检查。 中间代码生成 三地址码定义位于 utils/tac/；中间代码生成位于 frontend/tacgen/tacgen.py。 在对 AST 进行语义分析后，我们将在这一阶段把带有类型标注的 AST 翻译成适合后端处理的一种中间表示。中间表示（也称中间代码，intermediate representation / IR）是介于语法树和汇编代码之间的一种程序表示。 它不像语法树一样保留了那么多源程序的结构，也不至于像汇编一样底层。 由于源语言（MiniDecaf）和目标语言（RISC-V 汇编）一般存在较大的差别，因此直接把源语言翻译为目标语言中的合法程序通常是比较困难的。大多数编译器实现中所采取的做法，是首先把源语言的程序翻译成一种相对接近目标语言的中间表示形式，然后再从这种中间表示翻译成目标代码。中间表示（IR）的所带来的优势如下： 通过把 AST 到汇编的步骤一分为二，缩小调试范围。如果目标代码有误，通过检查 IR 是否正确就可以知道：是 AST 到 IR 翻译有误，还是 IR 到汇编翻译有误。 将 AST 转换到汇编的过程分成两个步骤，每个步骤代码更精简，更易于调试。 通过 IR 可以适配不同指令集（RISC-V, x86, MIPS, ARM...）和源语言（MiniDecaf, C, Java...）。由于不同源语言的 AST 不同，直接从 AST 生成汇编的话，为了支持 N 个源语言和 M 个目标指令集，需要写 N * M 个目标代码生成模块。如果有了 IR，只需要写 N 个 IR 生成器和 M 个汇编生成器，只有 N + M 个模块。 接下来，将对我们所使用的中间代码 —— 三地址码 (TAC) 做简要介绍，后续的实验步骤中需要同学们添加恰当的三地址码指令来完成特定的功能。为了降低实验难度，给出部分参考实现，各位同学可以依据参考实现完成设计，也可以自行设计三地址码。需要指出的是，我们使用的 TAC 并非严格按照课本上的定义，并且也没有严格要求只能使用三个寄存器地址，不过绝大多数指令均可以仅使用三个寄存器地址实现（函数调用除外）。 三地址码 三地址码（Three Address Code, TAC）看起来很像汇编，与汇编最大的区别在于 —— 汇编里面使用的是目标平台（如 risc-v, x86, mips）规定的物理寄存器，其数目有限；而 TAC 使用的是“虚拟寄存器”，我们称为临时变量，其数目不受限制，可以任意使用（这意味着直接将临时变量转化为寄存器可能会出现寄存器不够用的情况）。在后端生成汇编代码时，我们再考虑如何为临时变量分配物理寄存器的问题。 main: # main 函数入口标签 _T0 = 1 # 加载立即数 _T1 = _T0 # 临时变量赋值操作 _T2 = ADD _T0, _T1 # 加法操作 _T2 = _T0 + _T1 _T3 = NEG _T0 # 取负操作 _T3 = -_T0 return _T2 # 函数返回 以上给出了一份 TAC 示例程序。请注意 TAC 代码只是一种中间表示，并不需要像汇编语言那样有严格的语法。因此，同学们可以自由选择输出 TAC 代码的格式，只要方便自己调试即可。例如，你也可以将 _T2 = ADD _T0, _T1 输出成 _T2 = _T0 + _T1。 TAC 程序由标签和指令构成： 标签用来标记一段指令序列的起始位置。从底层实现的角度来看，每个标签本质上就是一个地址，且往往是某一段连续内存的起始地址。在我们的实验框架中，标签有两个作用：作为函数入口地址（如上例中的 main 函数入口），以及作为分支语句的跳转目标（TAC 指令不支持 MiniDecaf 语言中条件和循环控制流语句，而是将它们都翻译成更加底层的跳转语句）。 TAC 指令与汇编指令类似，每条 TAC 指令由操作码和操作数（最多3个，函数调用除外，由于函数参数可能有多个，使用严格的三个操作数反而会使得函数一节中实现更为复杂）构成。 操作数可能会有：临时变量、常量、标签（可理解为常量地址）和全局变量（全局变量的处理比较特殊，由于 step10 才需要考虑，届时再介绍其处理方法）。如上例所示，TAC 中的临时变量均用 \"_Tk\" 的形式表示（k表示变量的编号）。 TAC 程序是无类型的，或者说它仅支持一种类型：32位（4字节）整数。为了简化实验内容，MiniDecaf 只支持 int 类型和 int 数组类型，其值和地址都可以用一个32位整数存储，故 MiniDecaf 程序中的变/常量和 TAC 中的变/常量可以直接对应。 数组类型无法用临时变量直接表示，可以用一段连续内存的起始地址表示。其实现细节将在 step11 详细讨论。 控制流、数据流分析和寄存器分配 数据流图定义及优化在 backend/dataflow/ 中；寄存器分配在 backend/reg/ 中 控制流和数据流分析 一般来说，三地址码是可以直接翻译为目标代码的，但是这样的直接翻译会导致所产生的代码的效率比较差，所以多数编译器都会进行一定的优化工作。为了进行更深入的优化，编译器需要了解程序语义的更多内容，例如一个变量的某个赋值在当前指令中是否有效、一个变量在当前指令以后是否还会被使用、当前运算指令的两个操作数是否都能够在编译的时候计算出来、循环体中某些代码是否能够提出到循环外面、循环次数是不是编译的时候已知的常数等等，这些语义分析和代码优化离不开控制流分析和数据流分析。 所谓控制流分析，是指分析程序的执行路径满足什么性质，包括基本块划分、流图构造、以及分析循环或其他控制区域（region）。而所谓数据流分析，是指分析各种数据对象在程序的执行路径中的状态关系，例如一个变量在某个语句以后是否还被用到等。依据数据流分析的结果，可以进行后续的中间代码优化以及寄存器分配等相关步骤。 关于数据流分析的细节，我们将在 step7 做详细介绍。 寄存器分配 所谓寄存器分配，是指为中间代码中的虚拟寄存器分配实际的物理寄存器。对中间代码来说，通常假设虚拟寄存器的数量是无限的，这导致我们在分配物理寄存器时无法简单的对虚拟寄存器做一一映射，需要有一个调度与分配算法来合理使用有限的物理寄存器。本实验框架中使用了一种暴力寄存器分配算法，具体细节将在 step5 中详细说明，当然如果你感兴趣，你也可以基于我们的框架实现更高级的干涉图分配算法，具体不作要求。 目标平台汇编代码生成 目标平台汇编代码生成在 backend/asm.py | subroutineinfo.py 以及 backend/riscv/ 中。 通常我们认为的目标代码生成步骤包含寄存器分配、指令选择。寄存器分配是指为中间代码中的虚拟寄存器分配实际的物理寄存器，涉及物理寄存器的调度分配。指令选择是指选用合适的汇编指令来翻译中间代码指令，如中间代码生成章节提供的例子中，使用 addi 汇编指令来翻译 ADD 中间代码指令。需要特别提出的是，RISC-V 指令集的设计思路是尽可能简洁，因此有些指令并没有直接提供，需要用多条简单指令代替，如相等、大于等于、逻辑与、逻辑或等等。同学们实现时需要特别注意。 课程实验的目标平台为 RISC-V，RISC-V 是一个与 MIPS 类似的 RISC 指令集架构，编译实验要求所实现的编译器把 MiniDecaf 程序编译到 RISC-V 汇编代码。指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"，另外这里也有（非官方的）指令用法说明。下图给出了 RISC-V 的32个整数寄存器的相关说明，其中需要特别注意的寄存器有 ra（存放函数返回地址）、sp（存放当前栈顶地址）、fp（存放当前栈底地址）、a0&a1（存放函数返回值）。为了简单起见，我们简化了 RISC-V 的调用约定，由调用者（caller）负责保存寄存器内容，因此，无需关心某个寄存器是 caller-saved 还是 callee-saved。 "},"docs/step1/provided.html":{"url":"docs/step1/provided.html","title":"已提供的语法特性","keywords":"","body":"已经提供的语法特性 为了方便同学们完成实验，我们提供的实验框架中已经完成了部分语言特性的实现。对于某些步骤，同学们可以参照已实现的特性完成剩余的部分。例如，根据提供的 while 循环实现，同学们可以参考着完成 for 循环的实现。 下面我们列出了所有框架中已经完成的特性： step1 中我们提供了所有实现。 step2 中我们提供了取负运算的实现。 step3 中我们提供了加法和逻辑或操作运算的实现。 step5 中我们提供了基础数据结构——符号表的实现。 step6 中我们提供了基础数据结构——单层作用域的实现。 step7 中我们提供了 if 语句的实现。 step8 中我们提供了 while 循环的实现。 此外，我们提供了 step1-6 需要的语法树节点和中间代码指令，以及后端中的寄存器分配算法。 "},"docs/step1/intro.html":{"url":"docs/step1/intro.html","title":"实验要求","keywords":"","body":"实验指导 step1：一个仅有 return 的 main 函数 实验框架已经完成并通过了本节的测例，因此你不需要在这个阶段修改代码，但需要在 stage 1 的报告中（注意不是 stage 0）完成通过例子学习一节末尾的思考题。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 ./reports/stage-1.pdf。整个 stage 1 只需要提交一份报告，你不需要单独为 step 1 准备报告。 "},"docs/step1/example.html":{"url":"docs/step1/example.html","title":"通过例子学习","keywords":"","body":"通过例子学习，一个仅有 return 的主函数编译全流程： 本步骤主要涉及的语法为主函数和 return 语句，完成本步骤之后，你的编译器将支持将一个仅有 return 的主函数编译为 32 位 RISC-V 汇编代码，并通过 RISC-V 工具链生成可以在硬件模拟器上正确运行的程序。因为这是大家首次接触 MiniDecaf 编译实验框架，我们给大家的代码框架中已经包含所有 step1 的实现，大家可以直接运行通过 step1 的测试用例。并且，我们在每个步骤的文档中会详细梳理介绍在当前步骤中需要用到的知识点以及对应的代码片段和注释，如果我们认为当前步骤并不需要了解某部分知识点（如数据流分析、寄存器分配），我们会在后续的步骤中进行知识点的讲解。 下面我们将通过一个简单的 step1 测试用例，一起走过它的编译全流程： int main() { return 2025; } 词法分析 & 语法分析 在词法分析 & 语法分析这一步中，我们需要将输入的程序字符流按照语法规范转化为后续步骤所需要的 AST，我们使用了 lex/yacc 库来实现这一点。yacc 是一个根据 EBNF 形式的语法规范生成相应 LALR parser 的工具，支持基于属性文法的语法制导的语义计算过程。你可以根据我们的框架中对 lex/yacc 的使用，结合我们的文档，来快速上手 lex/yacc，完成作业；也可以选择阅读一些较为详细的文档，来系统地进行 lex/yacc 的入门，但这不是必须的。 在实验框架中，我们使用的是 lex/yacc 的一个纯 python 实现，称为 python-lex-yacc（简称 ply），其使用方法与 lex/yacc 有一些差异。 Python-lex-yacc 快速入门 程序的入口点在 main.py，它通过调用 frontend.parser.parser（位于 frontend/parser/ply_parser.py）来完成语法分析的工作，而这一语法分析器会自动调用位于 frontend/lexer/ply_lexer.py 的词法分析器进行词法分析。语法的定义和语法分析器都位于 frontend/parser/ply_parser.py，而词法的定义位于 frontend/lexer/lex.py。AST 节点的定义位于 frontend/ast/tree.py 中。以下表示中的符号都出自于这几个文件。 这部分的工作流程如下： 读内容 词法分析 & 语法分析 语义分析 readCode parser.parse Namer.transform & Typer.transform MiniDecaf 源文件 --------> 字节流 -----------> AST -------------------------------> ... 当程序读入程序的字符流之后，它首先会被 lexer 处理，并被转化为如下形式的一个 Token 流： Int Identifier(\"main\") LParen RParen LBrace Return Integer(2025) Semi RBrace 在frontend/lexer/lex.py文件中你可以看到每个 Token 是如何定义的，每个token都会以t_开头。如t_Semi = \";\"代表分号被解析以后会转化为 Semi 这个Token。而对于一些复杂的 Token，我们需要在lexer中定义一个正则表达式来匹配它，lex中通过定义一个函数来实现正则匹配。以匹配整数为例，函数的第一行r\"[0-9]+\"代表匹配用到的正则表达式，而函数的参数t则是被匹配得到的字符串，我们通过python中的类型转换将其变为一个整数，你可以在文件中看到以下代码： def t_Integer(t): r\"[0-9]+\" # can be accessed from `t_Interger.__doc__` t.value = int(t.value) return t 之后，这些 token 会被 yacc 生成的 LALR(1) parser 转化为如下形式的 AST： Program |- (children[0]) Function |- (ret_t) TInt |- (ident) Identifier(\"main\") |- (body) Block |- (children[0]) Return |- (expr) IntLiteral(2025) 得到的 AST 也就是 main.py 中 step_parse 这一函数里 parser.parse(...) 的输出。 在frontend/parser/ply_parser.py文件中，你可以看到我们是如何定义语法规则的，文件的最末尾有parser = yacc.yacc(start=\"program\")代表了parser的入口点是program，而program的定义在p_program函数中，你可以看到这个函数的docstring中定义了program的语法规则。注意docstring（即三个引号之间的内容）在这里并非注释，而是用于定义语法规则。 def p_program(p): \"\"\" program : function \"\"\" p[0] = Program(p[1]) def p_function_def(p): \"\"\" function : type Identifier LParen RParen LBrace block RBrace \"\"\" p[0] = Function(p[1], p[2], p[6]) 我们先看p_program函数，我们定义的语法规则是program由一个function组成，对应的上下文无关表达式就是program -> function，同时代码中的p[0] = Program(p[1])代表了构建AST的计算过程，这里的p[0]代表的是当前语法规则的左部，p[1]代表的是当前语法规则的右部第一个符号（即function），p[2]代表的是当前语法规则的右部第二个符号（这里没有），以此类推。这样递归下去，就能解析完整个程序。p[0] = Program(p[1])最后就会变为p[0] = Program(Function(...))，这里Program、Function类的定义在frontend/ast/tree.py文件中，你可以看到Function这个类的构造函数接受了三个参数，分别是返回值类型、函数名和函数体。 尝试运行 python main.py --input example.c --parse 你应该就能看到类似的输出。（记得自己写一个example.c） 语义分析 在 step1 语义分析步骤中，我们要遍历 AST，检验是否存在如下的语义错误： main 函数是否存在。（frontend/typecheck/namer.py:37） 在实际操作中，我们遍历 AST 所用的方法就是的 Visitor 模式，通过 Visitor 模式，我们可以从抽象语法树的根结点开始，遍历整颗树的所有语法结点，并针对特定的语法结点作出相应的操作，如名称检查和类型检查等。在编译器中，这种基于 Visitor 的对语法树进行一次遍历，完成某种检查或优化的过程，称为遍（pass）。不难想到，一个现代编译器是由很多遍扫描组成的，如 gcc 根据优化等级不同会有数百个不等的 pass。下面，我们将指出，step1 中我们是如何实现符号表构建 pass 和类型检查 pass 的，同学们可以选择去看相应的代码注释与实现细节。 frontend/typecheck/namer.py 和 typer.py 分别对应了符号表构建和类型检查这两次遍历。在框架中，Namer 和 Typer 都是继承 frontend/ast/visitor.py 中的 Visitor 类来通过 Visitor 模式遍历 AST 。 中间代码生成 在通过语义检查之后，编译器已经掌握了翻译源程序所需的信息（符号表、类型等），下一步要做的则是将抽象语法树翻译为便于移植和优化的中间代码，在本实验框架中就是三地址码。如何翻译抽象语法树？当然还是无所不能的 Visitor 模式，我们在中间代码生成步骤中再遍历一次语法树，对每个结点做对应的翻译处理。具体来说，在 step1 当中，我们只需要提取 return 语句返回的常量，为之分配一个临时变量，再生成相应的 TAC 返回指令即可。不难看出，本例对应的三地址码为： main: # main 函数入口标签 _T0 = 2025 # 为立即数 2025 分配一个临时变量 return _T0 # 返回 下面，我们同样也指出了在代码中我们是怎样实现这个中间代码生成 pass 的，大家可以参考注释和代码了解实现细节。 utils/tac 目录下实现了生成 TAC 所需的底层类。其中 tacinstr.py 下实现了各种 TAC 指令，同学们可以在必要时修改或增加 TAC 指令。 frontend/tacgen/tacgen.py 中通过一遍 AST 扫描完成 TAC 生成。和语义分析一样，这部分也使用了 Visitor 模式。这个文件里除了类型TACGen之外还有一个辅助类TACFuncEmitter，它用于处理产生TAC代码过程中一些相对底层的细节。在本框架中，TAC 程序的生成以函数为单位，对每个函数（step1-8 中只有 main 函数）分别使用一个 TACFuncEmitter 来生成对应的 TAC 函数代码。如果你增加了 TAC 指令，则可能需要在 TACFuncEmitter 类中增加生成相应指令的代码。 目标代码生成 目标代码生成步骤是对中间代码的再一次翻译，在本例中，你需要了解并掌握的知识点有: 如何将一个立即数装载到指定寄存器中？ RISC-V 提供了 li 指令来支持加载一个 32 位立即数到指定寄存器中，其中 表示寄存器名， 表示立即数值，如：li t0, 2025，就是将立即数 2025 加载到寄存器 t0 中。 如何设置返回值？ 在 RISC-V 中，a0 和 a1 是 gcc 调用约定上的存储返回值的寄存器，返回值会按照其大小和顺序存储在 a0 和 a1 中。也就是说，如果你有一个 32 位的返回值，你可以放在 a0 中返回，如果你有两个 32 位的返回值，你就需要把它们分别放在 a0 和 a1 中返回。更多的返回值会全部放入内存返回，如约定好的栈的某个位置，这取决于函数调用约定。 在我们的实验要求中，返回值均是单个 32 位的值。因此在当前步骤中你只需要了解，将需要返回的值放入 a0 寄存器中，然后在后面加上一条 ret 指令即可完成函数返回的工作。 综上所述，我们上述中间代码翻译成如下 RISC-V 汇编代码： .text # 代码段 .global main # 声明全局符号 main main: # 主函数入口符号 li t0, 2025 # 加载立即数 2025 到 t0 寄存器中 mv a0, t0 # 将返回值放到 a0 寄存器中 ret # 返回 实验框架中关于目标代码生成的文件主要集中 backend 文件夹下，step1 中你只需要关注 backend/riscv 文件夹中的 riscvasmemitter.py 以及 utils/riscv.py 即可。具体来说 backend/asm.py 中会先调用 riscvasmemitter.py 中的 selectInstr 方法对每个函数内的 TAC 指令选择相应的 RISC-V 指令，然后会进行数据流分析、寄存器分配等流程，在寄存器分配结束后生成真正的汇编指令（即所有操作数都已经分配好寄存器的指令），最后通过 RiscvSubroutineEmitter 的 emitFunc 方法生成每个函数的 RISC-V 汇编。 思考题 在我们的框架中，从 AST 向 TAC 的转换经过了 namer.transform, typer.transform 两个步骤，如果没有这两个步骤，以下代码能正常编译吗，为什么？ int main(){ return 10; } 我们的框架现在对于 return 语句没有返回值的情况是在哪一步处理的？报的是什么错？ 为什么框架定义了 frontend/ast/tree.py:Unary、utils/tac/tacop.py:TacUnaryOp、utils/riscv.py:RvUnaryOp 三种不同的一元运算符类型？ "},"docs/step1/visitor.html":{"url":"docs/step1/visitor.html","title":"Visitor 模式速成","keywords":"","body":"Visitor 模式速成 编译器的构造中会使用到很多设计模式，Visitor 模式就是常见的一种。 基础的设计模式都在 OOP 课程中覆盖，这里重提一下 Visitor 模式，并以框架中的代码为示例进行介绍。 我们知道，编译器里有很多的树状结构。最典型的就是，源程序通过上下文无关文法解析后，得到的抽象语法树。在语义分析和中间表示生成两个步骤中，我们都需要遍历整个抽象语法树。Visitor 模式的目的，就是对遍历树状结构的过程进行封装，本质就是一个 DFS 遍历。 让我们考虑 step1 的文法： program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer 以这个文法对应的一段 MiniDecaf 代码为示例： int main() { return 2; } 它会对应如下的 AST 结构： program function type(int) identifier(main) param_list return int(2) 我们用缩进表示树结构，其中 program, function, type, identifier, param_list, block, return, int 等均为 AST 上的结点类型。 在框架中，我们有以下的 AST 结点类实现（进行了适当的简略）： ''' frontend/ast/node.py ''' class Node: # 所有 AST 结点的基类 # ... ''' frontend/ast/tree.py ''' class Program(ListNode[Union[\"Function\", \"Declaration\"]]): # 程序，AST 的根结点类型 # ... class Function(Node): # 函数 # ... class Statement(Node): # 语句基类 # ... class Return(Statement): # return 语句 # ... class TypeLiteral(Node): # 类型基类 # ... class TInt(TypeLiteral): # 整型 # ... 假设在经过了词法分析和语法分析后，我们已经成功将 MiniDecaf 代码转化为了 AST 结构。现在，我们想要编写代码对 AST 进行扫描。很容易写出递归的 DFS 遍历： def dfs(node: Node): if isinstance(node, Program): for func in node.functions: dfs(func) elif isinstance(node, Function): # do something for scanning a function node elif isinstance(node, Return): # ... dfs 函数接收一个结点，根据这个结点的类型进行深度优先遍历。容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的遍历逻辑。 那么我们把这些遍历逻辑封装到一个类里面，就得到了一个最简单的 Visitor。此外，为了便于实现，我们不使用 isinstance 来判断结点类型，而是调用结点自身的一个 accept 函数，并把不同的 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口。 ''' frontend/ast/node.py ''' class Node: # 所有 AST 结点的基类 def accept(self, v: Visitor[T, U], ctx: T) -> Optional[U]: raise NotImplementedError ''' frontend/ast/tree.py ''' class Program(ListNode[Union[\"Function\", \"Declaration\"]]): # ... def accept(self, v: Visitor[T, U], ctx: T): return v.visitProgram(self, ctx) class Function(Node): # ... def accept(self, v: Visitor[T, U], ctx: T): return v.visitFunction(self, ctx) # ... ''' frontend/ast/visitor.py ''' class Visitor(Protocol[T, U]): def visitOther(self, node: Node, ctx: T) -> None: return None def visitProgram(self, that: Program, ctx: T) -> Optional[U]: return self.visitOther(that, ctx) def visitFunction(self, that: Function, ctx: T) -> Optional[U]: return self.visitOther(that, ctx) # ... 之后，如果我们想要编写一种遍历 AST 的方法，可以直接继承 Visitor 类，并在对应结点的 visit 成员方法下实现对应的逻辑。例如，框架中用如下的方法进行符号表构建： class Namer(Visitor[ScopeStack, None]): def visitProgram(self, program: Program, ctx: ScopeStack) -> None: # ... for child in program: if isinstance(child, Function): child.accept(self, ctx) def visitFunction(self, func: Function, ctx: ScopeStack) -> None: # ... # ... 如果想要访问某个子结点 child，直接调用 child.accept(self, ctx) 即可。 "},"docs/step1/spec.html":{"url":"docs/step1/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step1 语法规范 我们采用 EBNF (extended Barkus-Naur form) 记号书写语法规范，采用类似 ANTLR 的记号： 小写字母打头的是非终结符（如 program），大写字母打头的是终结符（如 Identifier），可以用字符串字面量表示终结符（如 'int'） 后面会用到：( 和 ) 表示分组，| 表示选择，* 零或多次，+ 一或多次，? 零或一次。 很容易通过增加新的非终结符，去掉这些符号。例如 x+ 就可以被替换成新的非终结符 y，并且 y : x | x y。 EBNF 也有很多写法，另一种是用尖括号表示非终结符 ::= 等。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer step1 语义规范 1.1 MiniDecaf 的 int 类型具体指 32 位有符号整数类型，范围 [-2^31, 2^31-1]，补码表示。 1.2 编译器应当只接受 [0, 2^31-1] 范围内的整数常量, 不支持负整数常量，如果整数不在此范围内，编译器应当报错。引入负号-后，可以用负号配合正整数常量来间接表示负整数常量。 1.3 如果输入程序没有 main 函数，编译器应当报错。 "},"docs/step2/intro.html":{"url":"docs/step2/intro.html","title":"实验要求","keywords":"","body":"实验指导 step2：一元运算符 step2 中，我们要给整数常量增加一元运算：取负 -、按位取反 ~ 以及逻辑非 !。 语法上，我们需要修改 expression 的定义，从 expression : Integer 变成： expression : unary unary : Integer | ('-'|'!'|'~') unary 三个操作的语义和 C 以及常识相同，例如 ~0 == -1，!!2 == 1。 稍微一提，关于按位取反，我们使用补码存储 int；关于逻辑非，只有 0 表示逻辑假，其他的 int 都是逻辑真。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 ./reports/stage-1.pdf。整个 stage 1 只需要提交一份报告，你不需要单独为 step 2 准备报告。stage 1 的报告还需要额外包含 step 1 的思考题。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 如何检查我是否通过自动测试(CI) 在 git.tsinghua 上打开你的项目，在界面的右侧，Clone 按钮的下方，commit id 的左侧，可以看到一个画圈的 × 或者 √ 的图标，代表当前 commit 是否通过 CI 测试。 如果你希望获取详细测试输出，可以点击这个画圈的 × 或者 √ 的图标，或者在网页左侧选择 CI/CD 一栏的 Jobs，然后选择希望查看的评测结果即可。如果测试输出无法显示，可以点击输出框右上角四个按钮中最左边的一个，或者在当前地址(如.../jobs/123456)的后面加上/raw(如.../jobs/123456/raw)，即可获取测试输出。 "},"docs/step2/example.html":{"url":"docs/step2/example.html","title":"通过例子学习","keywords":"","body":"step2 实验指导 我们按照上一节划分的编译器阶段，分阶段给出 step2 实验指导。本实验指导使用的例子为： 需要注意的是，我们为了简化描述，提取出了测试用例中和本步骤最相关的部分，实际的测试用例还是一个完整的，带有主函数的 MiniDecaf 程序。 -1 词法语法分析 在 step2 中，我们引入了一元运算，因此需要引入新的抽象语法树节点： 节点 成员 含义 Unary 操作数 operand，运算类型 op 一元运算 注意由于各种一元运算的形式是一样的，只是运算规则不同，所以用统一的一元运算节点来表示，在后续步骤中，再根据具体的运算种类翻译为不同的 TAC 与 RISC-V 指令。 语义分析 由于现在 return 语句的返回值不再是整型常量，而是表达式，因此语义分析时需要递归地访问运算操作结点的子结点，才能访问到作为叶子结点的整型常量，完成 step1 中实现的整型常量越界检查。 代码没有特别需要修改的地方。 中间代码生成 在 step1 中，我们只需为 return 语句的返回的整型常量分配一个临时变量即可。而从 Step2 开始，语法树上出现了各种运算操作结点。在生成 TAC 的过程中，我们需要为运算结点分配一个临时变量，并生成一条指令，该指令根据子结点的临时变量进行计算，将结果赋予该结点的临时变量。 针对取负操作，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 NEG T0 对参数取负 按照上文说的，-1 在语法树上对应父-子两个结点，父结点为取负操作，子结点为常量 1。在生成过程中，首先使用 Visitor 模式递归地访问子结点，我们使用一个临时变量加载该立即数。之后，在父结点，我们根据子结点的临时变量，生成一条取负指令，将这条指令得到的目标临时变量设置为父结点的临时变量。 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = NEG _T0 目标代码生成 step2 目标代码生成步骤的关键点在于，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。以 NEG 中间表达指令为例，RISC-V 汇编中有 neg 指令与其对应，因此上述中间代码可以翻译为如下的 RISC-V 汇编： li t0, 1 neg t1, t0 如果你不知道某个运算符应该翻译成怎样的汇编代码，你可以看这里 实现细节 关于实现细节，对应的代码位置在下面给出，代码中提供注释供大家学习。 相比于step 0, 我们实现了把返回值从一个整数（如：2025、1）变成单目表达式（如：-1），则在这一步中你可能需要进行以下操作（实际上这些实现已经在框架里提供）： 首先，我们应该把 - 看作一个符号，而不应该将 -1 看作一个整体，因为我们还可能遇到 -x 这种求一个变量的相反数的操作，如果将其分开处理则会增加我们的工作量。因此我们需要在词法分析中加入对 - 的处理。 我们能发现 -, !, ~ 等符号都可以作为一元运算符出现，比如!x, ~a, -10，我们将这类一元运算操作都称为 unary ，一并处理所有的一元运算符这样就不需要对每一种符号都专门生成一种语法规则和 AST 节点了。 因此我们希望生成的 AST 应当变为如下形式： Program |- (children[0]) Function |- (ret_t) TInt |- (ident) Identifier(\"main\") |- (body) Block |- (children[0]) Return |- (expr) Unary |- (op) Minus |- (expr) IntLiteral(1) 看到这里，你可能会好奇，为什么这里多了如 (expr) Unary 这样的奇怪的 AST 节点。在编译器中，我们将所有的值、或者运算产生的结果称为一个表达式。比如 1 这个数字是一个表达式， -1 , y-x同样也是表达式，其会生成一个值。而带返回值的 return 语句需要一个值，我们可以理解为带返回值的 return 语句后需要接一个表达式，这样在语义上才是正确的（例如，我们能见到return 1;这样的语句，但是不会见到return if;这样的语句，因为 if 并不是一个会产生值的表达式）。 词法分析 & 语法分析 在 frontend/lexer/lex.py 里加入新的 lex token 定义，以便lexer可以解析 -： t_Minus = \"-\" 在 ply 的 lexer 中，定义的新 token 需要以 t_开头。更具体的解释见文件注释或文档（太长了助教也读不下去）。 在 frontend/ast/tree.py 里加入新的 AST 节点定义（以及相应的其它东西）： class Unary(Expression): def __init__(self, op: Operator, operand: Expression): ... 并在 frontend/ast/visitor.py 中加入相应的分派函数。 它将在后续的 parser 语义计算中被用到。 在 frontend/parser/ply_parser.py 里加入新的 grammar rule： def p_expression_precedence(p): # 定义的新语法规则名。可以随便起，但必须以 `p_` 开头以被 ply 识别。 \"\"\" expression : unary unary : primary \"\"\" # 以 [BNF](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form) 定义的新语法规则，以 docstring 的形式提供。 p[0] = p[1] # 这条语法规则相应的语义计算步骤，下标对应着产生式中的相应符号。 # 语法分析器直接产生的实际上是一棵语法分析树，而构建 AST 这一数据结构则通过相应语法制导的语义计算过程来完成。 def p_unary_expression(p): \"\"\" unary : Minus unary \"\"\" p[0] = tree.Unary(UnaryOp.Neg, p[2]) 这里其实就是上下文无关文法，大家要看懂文法和代码的对应关系，注意看这条生成规则unary : Minus unary，其中p[0]代表的就是第一个unary, p[1]则是Minus，p[2]为第二个unary。你会看到我们框架代码和这里不太一样，因为unary符号不止有减号，我们通过将lex解析得到的-通过backward_search对应到我们在代码中enum的UnaryOp.Neg（frontend/ast/node.py:40）。 现在尝试运行 python main.py --input example.c --parse 看看效果吧。（记得修改example.c） 怎么从 AST 变为 TAC 的？ 什么是 TAC ，如果你没读前面的章节，你可以快速看看这一部分。 这一步就是 TACGen.transform 函数(frontend/tacgen/tacgen.py)做的事了， TACGen.transform 接受一个AST树输入，输出一个TAC表示，请确保你已经对Visitor 模式有所了解，或者假设你已经知道在遍历 AST 时 accept 函数会对不同类型的 AST Node 调用不同的visit 函数。例如，visit (children[0]) Return 时，遇到的子节点是 (expr) Unary，那么 accept 最终会调用visitUnary，你的lint工具应该是没法做到点一下就跳转到对应的位置，所以你需要自己判断我们在遍历某个节点的时候其子节点的类型。 下面的描述中一定要记得区分accept和直接对于mv.emitXXX的调用，前者是在遍历AST时调用的，后者是在 TACFuncEmitter 类中调用的。并且希望大家一定要对着代码看。 Program |- (children[0]) Function |- (ret_t) TInt |- (ident) Identifier(\"main\") |- (body) Block |- (children[0]) Return |- (expr) Unary |- (op) Minus |- (expr) IntLiteral(1) 继续看上述例子，我们先关注只有 main 函数的 Minidecaf 程序，我们将TACGen.transform代码贴了一些在这里： def transform(self, program: Program) -> TACProg: labelManager = LabelManager() tacFuncs = [] for funcName, astFunc in program.functions().items(): # in step9, you need to use real parameter count emitter = TACFuncEmitter(FuncLabel(funcName), 0, labelManager) astFunc.body.accept(self, emitter) tacFuncs.append(emitter.emitEnd()) return TACProg(tacFuncs) 现在我们开始正式遍历 AST 树，transform 会先遍历每一个函数进行代码翻译，因为我们目前只有一个函数main，我们只考虑没有参数的函数，我们需要对函数体进行翻译，函数体首先在一个block中（花括号括起来的部分），因此会先进入 visitBlock 函数，visitBlock 函数对于在block中的所有子节点调用了child.accept(self, mv)，在这个例子中则会调用Return 语句对应的visitor，进入visitReturn。继续向下，visitReturn 又对于 return AST Node 中的 expr 调用了 stmt.expr.accept(self, mv) ，又进入了visitUnary，同理，expr.operand.accept(self, mv)会进入visitIntLiteral。 到了此处出现了不同，我们发现visitIntLiteral中第一次调用了mv的成员函数 mv.emitLoad(expr.value) 这里进入了TACFuncEmitter.emitLoad： def emitLoad(self, value: Union[int, str]) -> Temp: temp = self.freshTemp() self.func.add(LoadImm4(temp, value)) return temp self.freshTemp()分配了一个虚拟寄存器 temp ，并且产生了一条立即数加载语句（你可以认为现在的所有指令就是用一个大数组存放了起来）。至此，我们翻译出了第一条语句，将 1 load 到一个虚拟寄存器 temp 中。剩下的部分，与这条语句的翻译也十分相似，因此不再赘述。 到此为止我们得到的TAC代码如下： FUNCTION: _T0 = 1 _T1 = - _T0 return _T1 现在尝试运行 python main.py --input example.c --tac 看看效果吧。 怎么从TAC到汇编代码 这一步是 Asm.transform 函数(backend/asm.py)处理的，Asm.transform 接受一个 TAC 输入，输出汇编代码。 def transform(self, prog: TACProg): analyzer = LivenessAnalyzer() for func in prog.funcs: emitter = RiscvAsmEmitter(Riscv.AllocatableRegs, Riscv.CallerSaved) reg_alloc = BruteRegAlloc(emitter) pair = emitter.selectInstr(func) builder = CFGBuilder() cfg: CFG = builder.buildFrom(pair[0]) analyzer.accept(cfg) reg_alloc.accept(cfg, pair[1]) return emitter.emitEnd() 我们先忽略LivenessAnalyzer和Control Flow Graph(CFG)以及寄存器分配的部分（助教写了一个非常简单暴力的寄存器分配，如果你觉得它不够好，你可以在后面的step换掉它），实际上，我们这里最主要的是指令选择（selectInstr），指令选择将中端TAC代码转换为riscv汇编代码，selectInstr函数中，我们也采用了visitor模式遍历指令序列， _T0 = 1 这句比较直接，我们也能较为容易的想到一个简单的汇编指令对应（li _T0, 1），主要讲讲和_T1 = - _T0 和 return _T1翻译过程发生了什么。 先看emitUnary函数： def emitUnary(self, instr: Unary) -> None: op = { TacUnaryOp.NEG: RvUnaryOp.NEG, # You can add binary operations here. }[instr.op] self.seq.append(Riscv.Unary(op, instr.dst, instr.operand)) 这里将中端的TacUnaryOp.NEG翻译为了后端的RvUnaryOp.NEG，在后端输出汇编时，我们直接将RvUnaryOp.NEG转换为小写字符串取了11位以后的字符，直接输出为neg（参考Unary.__str__函数），因此后续希望添加其他后端的符号时，你应该直接在RvUnaryOp中增加对应的同名的enum字段。 你可以试试，将RvUnaryOp.NEG中名字改为RvUnaryOp.XXX看看输出的汇编代码会发生什么变化吧。 再看emitReturn函数，我们这里的return是一个带返回值函数的return def emitReturn(self, instr: Return) -> None: if instr.value is not None: self.seq.append(Riscv.Move(Riscv.A0, instr.value)) else: self.seq.append(Riscv.LoadImm(Riscv.A0, 0)) self.seq.append(Riscv.JumpToEpilogue(self.entry)) 这里会进入第一个分支，由于 Risc-V 的调用约定将A0寄存器定为存放返回值的寄存器，因此在返回时我们产生了一条Move指令，这里的instr.value则是返回值对应的表达式使用的寄存器。 你可能会觉得，这一步不就是将 TAC 一一对应为一个汇编指令序列嘛，有什么必要吗？其实这一步是必要的，首先有的中间表示可能无法由一条汇编指令完成，比如T2 = T1 || T0，这里的逻辑或需要将T1、T0进行或操作后，再判断其值是否为1。为什么这一步不在产生 TAC 时就处理了？因为我们希望中间表示能在一定程度上与平台无关（不同后端目标架构的指令选择可能存在较大差异），中间表示有一定抽象能力能简化整体编译器的设计。 物理寄存器分配我们暂时跳过。至此我们已经完成了从源代码到汇编代码的翻译。 现在尝试运行 python main.py --input example.c --riscv 看看效果吧。 思考题 我们在语义规范中规定整数运算越界是未定义行为，运算越界可以简单理解成理论上的运算结果没有办法保存在32位整数的空间中，必须截断高于32位的内容。请设计一个 minidecaf 表达式，只使用-~!这三个单目运算符和从 0 到 2147483647 范围内的非负整数，使得运算过程中发生越界。 提示：发生越界的一步计算是-。 总结 本步骤中其他运算符的实现逻辑和方法与取负类似，大家可以借鉴取负的实现方法实现剩下的逻辑非和按位非。并且，我们在实验框架中已经给出了取负的参考实现，希望能够帮助大家快速上手编译实验。 "},"docs/step2/spec.html":{"url":"docs/step2/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step2 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : unary unary : Integer | ('-'|'!'|'~') unary step2 语义规范 2.1 运算符 - 的结果是其操作数的相反数。 2.2 运算符 ~ 的结果是其操作数的二进制反码（也就是说，结果中的每一个二进制位是 1 当且仅当其对应的二进制位是 0）。 2.3 当操作数不等于 0 时，逻辑非运算符 ! 的结果为 0；当操作数等于 0 时，其结果为 1。 2.4 MiniDecaf 中，负数字面量不被整体作为一个 token。它被看成是一个取负符号、后面是它的绝对值。 所以我们无法用字面量表示 -2147483648，但可以写成 -2147483647-1（待我们加上四则运算后）。 2.5 整数运算越界是未定义行为（undefined behavior），即对程序的行为无任何限制。 例如 -(-2147483647-1) 是未定义行为。这一条规则对于后续 step 引入的运算符也都适用。 对于含有未定义行为的 C/C++ 程序，在启用优化选项编译时，编译器可能产生意料之外的结果。 "},"docs/step3/intro.html":{"url":"docs/step3/intro.html","title":"实验要求","keywords":"","body":"实验指导 step3：加减乘除模 step3 我们要增加的是：加 +、减 -、乘 *、整除 /、模 % 以及括号 ( )。 语法上我们继续修改 expression，变成 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1+2*(4/2+1) == 7。 我们这种表达式语法写法可能比较繁琐，但它有几个好处： 和 C17 标准草案保持一致 把优先级和结合性信息直接编码入语法里，见优先级和结合性一节。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 ./reports/stage-1.pdf。整个 stage 1 只需要提交一份报告，你不需要单独为 step 3 准备报告。stage 1 的报告还需要额外包含 step 1 的思考题。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 如何检查我是否通过自动测试(CI) 在 git.tsinghua 上打开你的项目，在界面的右侧，Clone 按钮的下方，commit id 的左侧，可以看到一个画圈的 × 或者 √ 的图标，代表当前 commit 是否通过 CI 测试。 如果你希望获取详细测试输出，可以点击这个画圈的 × 或者 √ 的图标，或者在网页左侧选择 CI/CD 一栏的 Jobs，然后选择希望查看的评测结果即可。如果测试输出无法显示，可以点击输出框右上角四个按钮中最左边的一个，或者在当前地址(如.../jobs/123456)的后面加上/raw(如.../jobs/123456/raw)，即可获取测试输出。 "},"docs/step3/example.html":{"url":"docs/step3/example.html","title":"通过例子学习","keywords":"","body":"step3 实验指导 本实验指导使用的例子为： 1+3 词法语法分析 在 step3 中，我们引入了算术运算，因此需要引入新的抽象语法树节点： 节点 成员 含义 Binary 左操作数 lhs，右操作数 rhs，运算类型 op 二元运算 对有兴趣的同学：虽然 -2 和 2-3 里面的 - 意义不同，但 lexer 不知道这点（parser 才知道），所以它们都会用同样的 token kind - 表示。 但有时，可能需要后续阶段告诉 lexer（或 parser）一些信息，最经典的例子是 “typedef-name identifier problem”。 语义分析 同 Step2。 中间代码生成 与一元操作类似，针对加法，我们需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 作用 ADD T0,T1 将两个参数相加 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = 3 _T2 = ADD _T0, _T1 目标代码生成 step3 目标代码生成步骤的关键点与 step2 相同，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。 li t0, 1 li t1, 3 add t2, t0, t1 思考题 我们知道“除数为零的除法是未定义行为”，但是即使除法的右操作数不是 0，仍然可能存在未定义行为。请问这时除法的左操作数和右操作数分别是什么？请将这时除法的左操作数和右操作数填入下面的代码中，分别在你的电脑（请标明你的电脑的架构，比如 x86-64 或 ARM）中和 RISCV-32 的 qemu 模拟器中编译运行下面的代码，并给出运行结果。（编译时请不要开启任何编译优化） #include int main() { int a = 左操作数; int b = 右操作数; printf(\"%d\\n\", a / b); return 0; } 总结 本步骤中其他运算符的实现逻辑和方法与加法类似，可以参考二元加法的实现方法设计实现其他二元运算符。 "},"docs/step3/precedence.html":{"url":"docs/step3/precedence.html","title":"优先级和结合性","keywords":"","body":"优先级和结合性 操作符有优先级和结合性的概念，在之前的编程经历中大家应该已经对这两个概念已经有了直观的理解，这里用例子进一步解释一下： 优先级是两个操作符之间的关系，例如*的优先级比+高，所以表达式1 + 2 * 3应该解析成语法树add (1 mul (2 3))（前序表示），不能解析成mul (add (1 2) 3) 结合性是一个操作符的性质，例如-是左结合的，所以表达式1 - 2 - 3应该解析成sub (sub (1 2) 3)，不能解析成sub (1 sub (2 3)) 我们给出的语法规范已经表示了这样的性质，因此理论上我们不需要再额外定义操作符的优先级和结合性了。你可以自己试试，按照本步给出的语法规则，上面的两个表达式确实只能解析成我们期望的结果。 但是有一个问题：这样的语法规范虽然是正确的，也确实可以直接用来实现语法分析器了，但并不符合直观：我们一开始学习C或者别的编程语言的时候，讲的就是一个二元表达式由两个子表达式和中间的操作符组成，并且操作符有优先级和结合性。也就是这样的： expression : expression ('+'|'-') expression | expression ('*'|'/'|'%') expression | ('-'|'~'|'!') expression | Integer | '(' expression ')' 当然，它是有歧义的，你也可以自己试试，如果只有这些产生式的话，上面的两个表达式都可以解析成正确或者错误的结果。所以如果想基于这个规范来实现语法分析器，就必须告诉语法分析工具这些操作符的优先级和结合性是什么。 之后每一步给出的语法都是没有歧义，本身就能体现优先级和结合性的。如果你确实想借助优先级和结合性来实现，需要两个步骤： 把我们给出的语法规范转化成类似上面这样“更模糊”，有歧义的语法规范。我们相信这个方向的转化应该是容易的。 指定每个操作符的优先级和结合性。可以参考https://en.cppreference.com/w/c/language/operator_precedence，它给出了C语言操作符的优先级和结合性，因为我们的MiniDecaf语言是C语言的一个子集，所以这张表格也足够我们的语言使用了。 "},"docs/step3/spec.html":{"url":"docs/step3/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step3 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step3 语义规范 3.1 二元操作符 * 的结果是操作数的乘积。 3.2 二元操作符 / 的结果是第一个操作数除以第二个操作数所得的商的整数部分（即所谓“向零取整”），二元操作符 % 的结果是第一个操作数除以第二个操作数所得的余数。在两种操作中，如果第二个操作数为 0，则其行为都是未定义的。当 b 不为 0 时，表达式 (a/b)*b + a%b 应该等于 a。 3.3 二元操作符 + 的结果是操作数的和。 3.4 二元操作符 - 的结果是第一个操作数减去第二个操作数所得的差。 3.5 除非特别声明，子表达式求值顺序是未规定行为（unspecified behavior），即其行为可以是多种合法的可能性之一。也就是说，以任意顺序对子表达式求值都是合法的。 例如：执行 int a=0; (a=1)+(a=a+1); 之后 a 的值是未规定的（待我们加上变量和赋值运算符后，这个问题才会产生真正切实的影响）。 "},"docs/step4/intro.html":{"url":"docs/step4/intro.html","title":"实验要求","keywords":"","body":"实验指导 step4：比较和逻辑表达式 step4 我们要增加的是： 比较大小和相等的二元操作：、、>=, >, ==, != equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive 逻辑与 &&、逻辑或 || expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1=2 是逻辑真（int 为 1）。 但特别注意，C 中逻辑运算符 || 和 && 有短路现象，我们不要求。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 ./reports/stage-1.pdf。整个 stage 1 只需要提交一份报告，你不需要单独为 step 4 准备报告。stage 1 的报告还需要额外包含 step 1 的思考题。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 如何检查我是否通过自动测试(CI) 在 git.tsinghua 上打开你的项目，在界面的右侧，Clone 按钮的下方，commit id 的左侧，可以看到一个画圈的 × 或者 √ 的图标，代表当前 commit 是否通过 CI 测试。 如果你希望获取详细测试输出，可以点击这个画圈的 × 或者 √ 的图标，或者在网页左侧选择 CI/CD 一栏的 Jobs，然后选择希望查看的评测结果即可。如果测试输出无法显示，可以点击输出框右上角四个按钮中最左边的一个，或者在当前地址(如.../jobs/123456)的后面加上/raw(如.../jobs/123456/raw)，即可获取测试输出。 "},"docs/step4/example.html":{"url":"docs/step4/example.html","title":"通过例子学习","keywords":"","body":"step4 实验指导 本实验指导使用的例子为： 1 词法语法分析 本 step 中引入的运算均为二元运算，在 step3 中引入的二元运算节点中进行修改即可。 语义分析 同 Step2。 中间代码生成 针对小于符号，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 LT T0,T1 给出 T0结果，成立为1，失败为0 需要特别注意的是，在 C 语言中，逻辑运算符 || 和 && 有短路现象，我们的实现中不要求大家考虑它们的短路性质。 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = 2 _T2 = LT _T0, _T1 目标代码生成 step4 目标代码生成步骤的关键点与 step3 相同，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。 li t0, 1 li t1, 2 slt t2, t0, t1 逻辑表达式会麻烦一点，因为 gcc 可能会用跳转来实现&&和||，比较难以理解，所以下面直接给出 land 和 lor 对应的不使用跳转的汇编。 IR 汇编 lor or t3,t1,t2 ; snez t3,t3 land snez d, s1; sub d, zero, d; and d, d, s2; snez d, d; 注意 RISC-V 汇编中的 and 和 or 指令都是位运算指令，不是逻辑运算指令。 思考题 在 MiniDecaf 中，我们对于短路求值未做要求，但在包括 C 语言的大多数流行的语言中，短路求值都是被支持的。为何这一特性广受欢迎？你认为短路求值这一特性会给程序员带来怎样的好处？ 总结 本步骤中其他运算符的实现逻辑和方法与小于符号类似，可以参考小于符号的实现方法设计实现其他逻辑运算符。 恭喜你！到目前为止，你已经成功实现了一个基于 MiniDecaf 语言的计算器，可以完成基本的数学运算和逻辑比较运算了，成就感满满！然而，目前你的计算器还只能支持常量计算，这大大降低了计算器的使用体验，因此，在下一个 Stage，我们将一起实现对变量的支持。无论如何，当前的任务已经完成，好好休息一下吧☕️ "},"docs/step4/spec.html":{"url":"docs/step4/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step4 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step4 语义规范 4.1 关系操作符 （小于）、>（大于）、（小于等于）和>=（大于等于）的结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。 关系操作符可能导致表达式的含义与数学文献中常见的含义不同，例如 0 的含义与 (0 相同，即“如果 0 小于 1，那么判断是否有 1 小于 2，否则判断是否有 0 小于 2”。 4.2 判等操作符 ==（等于）和 !=（不等于）类似于关系操作符，结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。但判等操作符的优先级比关系操作符更低。对于任意一对操作数，这两个操作符中有且仅有一个结果为 1。 其优先级的设定会导致其含义在某些时候可能会反直观，例如，0 的运算结果为 1。 4.3 当操作数都非 0 时，逻辑与操作符 && 的结果为 1；否则其结果为 0。 4.4 当操作数有一个非 0 时，逻辑或操作符 || 的结果为 1；否则其结果为 0。 4.5 逻辑操作符 || 和 && 依然遵循语义规范 3.5，即其操作数的求值顺序是未指定行为。 换言之，我们不对逻辑表达式的短路求值做要求，可以将操作数两个以任意顺序计算出，再计算逻辑操作的结果。 "},"docs/step5/intro.html":{"url":"docs/step5/intro.html","title":"实验要求","keywords":"","body":"实验指导 step5：局部变量和赋值 这一步我们终于要增加变量了，包括： 变量的声明 变量的使用（读取/赋值） 此外，我们的 main 函数内部可以包含多条语句和声明了。 为了增加变量，我们需要确定：变量存放在哪里、如何访问变量。我们将借此引入 栈帧 的概念，并介绍它的布局。 语法上，step5 的改动如下： function : type Identifier '(' ')' '{' statement* '}' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression primary : Integer | '(' expression ')' | Identifier 我们要增加和变量相关的语义检查：变量不能重复声明，不能使用未声明的变量。 请将你的作业放置在分支stage-2下，你可以通过git checkout -b stage-2创建一个新的分支并继承当前分支的修改。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 2 的实验报告需要放在 stage-2 这个 branch 下的 ./reports/stage-2.pdf。注意报告的标题是 stage-2 而不是 step-5。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step5/example.html":{"url":"docs/step5/example.html","title":"通过例子学习","keywords":"","body":"step5 实验指导 本实验指导使用的例子为： int main() { int x = 2025; return x; } 词法语法分析 针对局部变量定义和赋值操作，我们需要设计 AST 节点来表示它，给出的参考定义如下（框架中已经提供）： 节点 成员 含义 TInt 无 整型 Identifier 名称 value 标识符（用于表示变量名） Assignment 同 Binary 赋值运算 Declaration 类型 var_t，标识符 ident，初始表达式 init_expr 变量声明 请注意，赋值操作是一种特殊的二元运算，因此可以将它合并到 Binary 节点里，也可以单独设置一类节点继承 Binary 类来处理它。 语义分析 从本节开始，我们需要在语义分析阶段对局部变量的规范进行检查。具体来说，我们需要名为符号表的数据结构。符号表的实现已经在框架中给出。因此，你只需要修改语义分析部分的代码，在必要时调用符号表的接口即可。 在符号表构建过程中，我们要按照语句顺序，逐一访问所有变量定义声明。在访问变量声明时，我们需要为该变量赋予一个变量符号，并将它存入符号表中。由于变量不能重复声明，在定义变量符号前需要在符号表中检查是否有同名符号。 类似地，在访问表达式时，如果遇到变量的使用，我们也需要在符号表中检查，避免使用未声明的变量。例如，如果我们将测例修改为： int main() { int x = 2025; return x + y; } 那么在扫描到加法操作的 AST 结点时，会依次检查该操作的两个操作数 x 和 y。这两个操作数均为变量标识符，因此我们需要到符号表中搜索 x 和 y 对应的符号。符号 x 可以在符号表中找到（我们在扫描 int x = 2025; 这条语句后已经为其定义），而 y 无法找到，因此编译器需要在扫描到 y 对应的结点时报错。 符号表总是和作用域相关的。例如，在 C 语言中，我们可以在全局作用域中定义名为 \"a\" 的全局变量，同时在 main 函数中定义名为 \"a\" 的局部变量，这并不产生冲突。不过由于本节还无需支持全局变量和块语句，同学们不用考虑这一点，只考虑 main 函数作用域对应的单张符号表即可。 此外，在本节中，我们引入了赋值操作。赋值可以看作一种特殊的二元运算，但需要注意，赋值号左侧必须为一个左值。具体来说，同学们需要检查赋值号左侧只能是变量名标识符。在 step11 中，我们会将左值的范围进一步包括数组元素。 对应到框架代码上： frontend/symbol 目录下为符号的实现。其中 symbol.py 为符号类的基类，varsymbol.py 为变量符号。在本节中，同学们只需要考虑变量符号即可。 frontend/scope 目录下为符号表的实现。其中 scope.py 为作用域类，在本节中由于只有一个局部作用域，因此无需考虑作用域栈。同学们只需要新建一个 Scope 对象，用以维护 main 函数中所有出现过的变量符号即可。 中间代码生成 我们首先来看本节指导用例所对应的中间代码： main: _T1 = 2025 _T0 = _T1 return _T0 针对赋值操作，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 ASSIGN T0,T1 临时变量的赋值 从中间代码可以看出，尽管我们引入了变量的概念，但是在比较低级的中间代码上，数据的存储和传递仍然是基于虚拟寄存器进行的。由于 MiniDecaf 语言中的基本类型只有 int 型，而 TAC 里的临时变量也是 32 位整数，因此，我们可以把 MiniDecaf 局部变量和 TAC 临时变量对应起来。 在扫描到 int x = 2025; 这条语句时，中间代码先把立即数 2025 加载到临时变量 _T1 中，然后再把 _T1 的值赋给临时变量 _T0，此时 _T0 已经成为了变量 x 的“替身”。每次需要用到变量 x 的值时，我们都会去访问 _T0。例如，测例中直接用返回 _T0 代替了返回变量 x 的值。因此，为了在后续使用变量 x 时能快速找到 _T0 这个临时变量，在符号表中存储 x 这个符号时，应当为该符号设置一个成员，存储 x 对应的临时变量。每当在 AST 上扫描到一个变量标识符结点时，我们都直接调用该变量对应的临时变量作为结点的返回值。 请注意 frontend/symbol/varsymbol.py 中，变量符号的定义里有该变量对应的 TAC 临时变量成员。 目标代码生成 本节指导用例对应如下 RISC-V 汇编代码： .text .global main main: li t1, 2025 mv t0, t1 # 我们使用 mv 指令来翻译中间表示里的 ASSIGN 指令 mv a0, t0 ret 简单的启发式寄存器分配算法 在中间代码中，我们使用了虚拟寄存器来存储变量的值。如果所使用的虚拟寄存器的个数，超过了目标机器实际拥有的物理寄存器数目，将无法生成正确的目标代码。此时，需要采用寄存器分配算法，调度和分配数目有限的物理寄存器资源，保证所有临时变量（虚拟寄存器或伪寄存器）都有合适的物理寄存器与之对应。在程序执行的任何时刻，都需要保证不会出现寄存器分配冲突，即两个同时有效且将被引用的临时变量（虚拟寄存器）被分配到同一个物理寄存器中，寄存器分配冲突将造成程序运行结果的错误。然而，寄存器分配问题是NP 完备问题（可以从 3-SAT 问题归约），这意味着对于一个含有大量临时变量的程序，为了获得最优寄存器分配方案，编译器将耗费可观的计算时间用于寄存器分配。因此，考虑到执行效率问题，实际的编译器实现中一般采用启发式算法。 实验框架中所采用的启发式寄存器分配算法基于活跃性分析。为避免一次性介绍过多的知识，将在 Step6 详细介绍活跃性分析的相关理论。大家目前只需要了解，活跃性分析是为了求解每个临时变量是否会在程序某点之后被引用，如果被引用，这个临时变量就是活跃的。 基于活跃性分析的启发式寄存器分配算法的基本思路：针对每一条 TAC 指令（例如 _T2 = ADD _T1, _T0），对于每个源操作数对应的临时变量（本例中 _T1 和 _T0），我们检查该临时变量是否已经存放在物理寄存器中，如果不是，则分配一个物理寄存器，并从栈帧中把该临时变量加载到寄存器中；对于目标操作数对应的临时变量（本例中的 _T2），如果该临时变量没有对应的物理寄存器，则为其分配一个新的物理寄存器。寄存器分配过程中，将为临时变量和为该变量分配的物理寄存器之间建立一种关联关系。 在分配寄存器时，首先检查是否存在空闲的寄存器（即尚未跟任何临时变量建立关联关系的寄存器），有则选择该寄存器作为分配结果。否则，检查有没有这样的寄存器，其所关联的临时变量在当前位置已经不是活跃变量了，这说明该寄存器所保存的数据未来不会被用到，可以回收使用这个寄存器而不用担心引起数据错误。一种可能的情况是，所有寄存器所关联的变量都是活跃的，即不存在空闲的寄存器。此时，将把某个寄存器所关联的暂时不用的变量存到栈帧（内存的一部分）中，腾出这个寄存器，这也称为溢出（spill）到内存。所腾空的寄存器是随机选取的，因此，所采用的寄存器分配算法有些暴力，存在进一步优化空间。 在实验框架中已经给出寄存器分配算法的代码，集中在 backend/reg/bruteregalloc.py 中，主要有以下几个函数： accept：根据每个函数的 DFG（数据流图）进行寄存器分配，寄存器分配结束后生成相应汇编代码。 bind：将一个 Temp（临时变量）与寄存器绑定。 unbind：将一个 Temp（临时变量）与相应寄存器解绑定。 localAlloc：根据活跃变量信息对一个 BasicBlock（基本块）内的指令进行寄存器分配。 allocForLoc：每一条指令进行寄存器分配。 allocRegFor：根据活跃变量信息决定为当前 Temp（临时变量）分配哪一个寄存器。 栈帧 上面的描述中提到，在分配寄存器的时候从栈帧中加载数据，以及将暂时不用的变量存储到栈帧中，接下来介绍栈帧的概念。 栈帧的概念 在汇编语言课程学习中，大家应该已经接触到栈帧的概念，下面简单回顾一下。在程序执行过程中，每次调用和执行一个函数，都会在栈上开辟一块新的存储空间，这块存储空间就叫做“栈帧”。栈帧中存放了函数执行所需的各种数据，包括需要临时保存的局部变量、在栈上临时申请的存储空间（如数组，在 Step11 中介绍）、被调用者负责保存的寄存器等。栈帧是函数正确调用和执行的保证。 需要注意的是，由于我们目前只支持一个 main 函数，直到 Step9 才会有多函数支持。所以现在关于栈帧的讨论，就只针对 main 函数的栈帧，并且集中于临时变量的存储和加载。 假设当前函数被某个函数调用，下图给出当前函数的栈帧。如图所示，当前函数的栈帧由被调用者负责保存的寄存器、保存的临时变量以及局部变量三个部分组成，fp 指向当前栈帧的栈底，sp 指向当前栈帧的栈顶，fp 和 sp 之间的部分就是当前函数的栈帧。当前实验步骤中，需要关注的是临时变量保存区域，正是在这个区域中，保存了为腾空物理寄存器而取出的临时变量（仍然活跃的临时变量）。值得一提的是，临时变量保存区域中还保存了基本块出口处仍活跃的临时变量（关于基本块的概念，将在 Step6 介绍，在当前的步骤不需要考虑）。 栈帧的建立与销毁 栈帧是函数运行所需要的上下文的一部分，在进入函数的时候需要建立对应的栈帧，在退出函数的时候需要销毁其对应的栈帧。栈帧对于函数的运行非常重要。那么程序在运行的过程中如何建立和销毁栈帧呢？实际上，建立栈帧的操作是由编译器生成代码完成的。在每个函数的起始位置，由编译器生成的用于建立栈帧的那段汇编代码称为函数的 prologue。prologue 所做的事情包括：分配栈帧空间和保存相应寄存器的值。相应的，在每个函数的末尾，用于销毁栈帧的那段汇编代码称为函数的 epilogue。epilogue 所做的事情包括：设置返回地址，回收栈帧空间，以及从当前被调用函数过程返回 貌似创建和销毁栈帧是一个大工程？实际不然，确定栈帧只需要维护好两个寄存器，sp 和 fp，它们分别保存当前栈帧的栈顶地址和栈底地址。当新的函数被调用时，需要把旧栈帧的栈底地址（fp）保存起来，用旧栈帧的栈顶地址（sp）表示新栈帧的栈底地址（新fp）。不难看出，新老栈帧在栈内存中是连续的存储空间。此外，每个函数体中需要分配的局部变量以及需要保存的临时变量在编译过程中是可知的。因此，栈帧的大小在编译期可以计算得出，即存储寄存器的空间，临时变量存储空间与局部变量空间三者之和。在求得栈帧大小之后，可以通过修改栈顶指针（sp）的值来分配恰当的栈帧空间。 一个例子 #include int calculate() { int a = 1; int b = 2; int c = 3; int d = 4; int e = 5; int result = a + b + c + d + e; return result; } int main() { int result = calculate(); printf(\"%d\\n\", result); return 0; } 在这个示例中，我们在 calculate 函数内部声明了 5 个局部整数变量（a 到 e）。假设我们的处理器只有 4 个通用寄存器，在这种情况下，我们无法将 5 个局部变量都保存在寄存器中。因此，编译器需要在栈上分配空间来存储这些变量。以下是栈空间的变化过程： main 函数调用 calculate 函数，将返回地址压入栈中。 calculate 函数执行 prologue，将 fp 的值保存到栈中，然后将 sp 的值赋给 fp，此时 fp 和 sp 的值相同，都指向栈顶。 calculate 函数分配栈帧空间，在这个例子中，假设 a 到 d 保存在寄存器中，e 保存在栈帧中，因此需要分配 4 字节的栈帧空间。sp 指向栈顶，因此 sp 的值减去 4，即可得到 e 的地址。 计算完成后，calculate 函数执行 epilogue，将 fp 的值赋给 sp，并恢复 fp 的值，然后将返回地址弹出栈中，跳转到返回地址。 思考题 请将你的整个stage-2作业放置在分支stage-2下，你可以通过git checkout -b stage-2创建一个新的分支并继承当前分支的修改。 我们假定当前栈帧的栈顶地址存储在 sp 寄存器中，请写出一段 risc-v 汇编代码，将栈帧空间扩大 16 字节。（提示1：栈帧由高地址向低地址延伸；提示2：risc-v 汇编中 addi reg0, reg1, 表示将 reg1 的值加上立即数存储到 reg0 中。） 有些语言允许在同一个作用域中多次定义同名的变量，例如这是一段合法的 Rust 代码（你不需要精确了解它的含义，大致理解即可）： fn main() { let a = 0; let a = f(a); let a = g(a); } 其中f(a)中的a是上一行的let a = 0;定义的，g(a)中的a是上一行的let a = f(a);。 如果 MiniDecaf 也允许多次定义同名变量，并规定新的定义会覆盖之前的同名定义，请问在你的实现中，需要对定义变量和查找变量的逻辑做怎样的修改？（提示：如何区分一个作用域中不同位置的变量定义？） 总结 Step5 主要涉及的知识为符号表、寄存器分配和栈帧，对于大家来说有一定的跳跃性和挑战性，希望大家能够尽早开始。 "},"docs/step5/spec.html":{"url":"docs/step5/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step5 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement* '}' type : 'int' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step5 语义规范 5.1 每一条变量声明（定义）指定了对标识符的解释和属性。当变量被定义时，应当有一块存储空间为这个变量所保留。当变量声明之后，若与这个变量的名称相同的标识符作为操作数（operand）出现在一个表达式中时，其就应被指派（designate）为这个变量。 5.2 变量的初始化表达式指定了变量的初始值。 5.3 同一个标识符应只能作为至多一个变量的名字，即是说，不允许声明重名变量。 5.4 对未声明的变量的使用是错误。 5.5 没有被初始化的（局部）变量的值是不确定的。 在初始化表达式中，正在被初始化的变量已被声明，但其值尚未被初始化。 例如，int a = a + 1;，这样一条声明在语义上等价于 int a; a = a + 1; 5.6 局部变量的名字可以为 main。 5.7 赋值运算 = 的左操作数必须是一个可修改的左值（modifiable lvalue）。左值（lvalue）即一个会被指派为某个变量的表达式，如在 int a; a = 1; 中，a 即是一个会被指派为变量的表达式。左值可修改是指被指派的变量不能是一个左值数组。 就 step5 来说，这一点其实几乎已经被语法保证，因为其 = 的左边只能是一个标识符，只需再要求其是一个已经声明过的变量的名字即可。 5.8 在赋值运算（=）中，右操作数的值会被存在左操作数所指派的变量中。 5.9 赋值表达式的结果，为赋值运算完成后左操作数所指派的变量的值，但这个结果本身并非左值。 5.10 一个函数中可以有任意多条 return 语句。 5.11 当 main 函数执行至 } 时，应终止执行并返回 0。 "},"docs/step6/intro.html":{"url":"docs/step6/intro.html","title":"实验要求","keywords":"","body":"实验指导 step6：作用域和块语句 step6 我们要增加块语句的支持。 虽然块语句语义不难，就是把多个语句组成一个块，每个块都是一个作用域。 随之而来一个问题是：不同变量可以重名了。 重名的情况包括作用域内部声明覆盖（shadowing）外部声明，以及不相交的作用域之间的重名变量。 因此，变量名不能唯一标识变量了，同一个变量名 a 出现在代码不同地方可能标识完全不同的变量。 我们需要在符号表构建的过程中，确定 AST 中出现的每个变量名分别对应那个变量。 语法上改动不大 function : type Identifier '(' ')' compound_statement compound_statement : '{' block_item* '}' statement : 'return' expression ';' | compound_statement block_item : statement | declaration 语义检查我们也要修改了，只有在同一个作用域里，变量才不能重复声明。 当然，如果变量在使用前还是必须先被声明。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 3 的实验报告需要放在 stage-3 这个 branch 下的 ./reports/stage-3.pdf。注意报告的标题是 stage-3 而不是 step-6。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step6/example.html":{"url":"docs/step6/example.html","title":"通过例子学习","keywords":"","body":"step6 实验指导 本实验指导使用的例子为： int main() { int x = 1; { x = 2; int x = 3; } x = 4; return x; } 词法语法分析 针对块语句，我们需要设计 AST 节点来表示它，给出的参考定义如下： 节点 成员 含义 Block 子语句列表 children 语句块 语义分析 从 Step6 开始，我们需要考虑作用域和代码块。简而言之，一份代码中可能有多个代码块的嵌套，因此作用域开始出现了层次结构。例如，在示例中，尽管 main 函数里定义了变量 x，但随后我们开启了一个新的代码块。在这个代码块中，赋值语句 x = 2; 中的 x 就是指 main 作用域中定义的 x，而随后通过 int x = 3; 我们定义了另一个变量 x，这个 x 只在内部大括号括起的作用域内生效。 在 Step5 中，我们只维护了 main 的作用域，所有符号都在这个作用域的符号表中维护。现在，为了维护层次嵌套的作用域，我们引入了作用域栈（Scope Stack）这个数据结构。在进行符号表构建的扫描过程中，我们需要动态维护作用域栈，保存当前扫描结点所在的从内到外所有作用域。每次我们开启一个代码块时，要新建一个作用域并压栈；而当退出代码块时，要弹栈关闭此作用域。 接下来针对上述代码示例，讲述作用域栈的维护方式。首先，栈底有一个全局作用域，其符号表里只有 main 函数。由于目前不需要考虑函数和全局变量，可以暂时忽略全局作用域。进入 main 函数时，开启一个局部作用域，在扫描 int x = 1; 时定义变量符号 x，并将其加入栈顶作用域对应的符号表中。如下所示： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域（栈顶） 变量 x 接下来，扫描到一个局部代码块，由此建立一个局部作用域并压栈。在扫描 x = 2; 时，我们需要分析 x 这个变量对应着哪个作用域里的符号。此时的作用域栈是这样的： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域 变量 x 局部作用域（栈顶） 空 对变量x的查找从栈顶开始，由上向下依次查找对应的符号表，直至找到变量 x 为止。由于在栈顶作用域对应的符号表中不存在变量符号 x，于是向下继续查找。在 main 函数对应的作用域中，可以找到变量符号 x。因此，语句 x = 2; 中的 x 对应 main 函数作用域里定义的变量 x。 接下来，当扫描到语句 int x = 3; 时，定义了另一个变量 x。此时，只需要在栈顶作用域中查找该变量是否存在。若不存在，即在符号表中加入对应符号。此时的作用域栈如下： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域 变量 x 局部作用域（栈顶） 变量 x 请务必注意上表中的两个变量 x 是不同的变量。 接下来，退出代码块，将其对应的作用域弹出栈，此时的作用域栈如下： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域（栈顶） 变量 x 最后，扫描语句 x = 4; 时，从栈顶作用域符号表查找 x，所找到的变量 x 为 main 作用域定义的 x 变量。 中间代码生成 本步骤中无须新增新的 TAC 指令。 让我们来看看示例所对应的 TAC 代码： main: _T1 = 1 _T0 = _T1 # int x = 1; _T2 = 2 _T0 = _T2 # x = 2 _T4 = 3 _T3 = _T4 # int x = 3; _T5 = 4 _T0 = _T5 # x = 4; return _T0 显然，两个代码块里的变量 x 是不同的变量，因此它们分别对应着不同的临时变量。其中，_T0 对应着 main 作用域里的 x，而 _T3 则对应着内层代码块定义的变量 x。只要同学们在符号表构建阶段把每个变量和正确作用域的变量符号关联起来，这一步就非常简单了：找到对应变量符号，使用该符号对应的临时变量即可。 目标代码生成 不需要新增新的中间代码指令。 代码框架需要同学们对寄存器分配相关的 CFG 的内容进行细微修改。具体来说，需要在 backend/dataflow/cfg.py 中添加基本块是否可达的判断。在寄存器分配算法 backend/reg/bruteregalloc.py 的注释中，我们给出了提示，如果一个基本块不可达，那么无须为它分配寄存器。 实现提示 在 step5 中，namer/typer 遍历时的上下文信息(参数 ctx)是单一的作用域。到了 step 6，你需要按照实验指导书中描述，把上下文信息改成“作用域栈”。也即定义 class Namer(Visitor[Scope, None]) 应改为 class Namer(Visitor[YourType, None])，其中 YourType 是你的作用域栈类型，你可以任意命名它。我们推荐把这个类的定义放在 frontend/scope/ 下。class Typer 也需要如上改动。 之前 step5 的全局唯一的作用域可以被当作“函数作用域使用”，在 visitFunction 入栈。然后在新的 visitBlock 中，再进一步将局部作用域压栈。最后，在所有这些方法的末尾，不要忘了把对应作用域退栈。 当只有一个作用域时，“不可以定义新变量a”就意味着当前“可以获取变量a的值”，反之亦然，所以“定义变量”和“获取变量”的检查都可以用 Scope.lookup 实现。但有了多个作用域之后，就出现了“既可以拿到a的值，也可以重新定义一个a”的情况。这需要重新考虑 Typer / Namer 中的每一个 Scope.lookup ，看她们是否需要换成新函数。 后续 stage-4 时，你需要一个机制来检查 break/continue 语句是否在一个循环内。这可以通过修改 namer/typer 中的对应结点来实现。另外，别忘了循环本身也是一个作用域！ 后续如果你选做“全局变量”部分，可以在 Namer 和 Typer 的 transform 方法中先将全局作用域加入栈底，再往上才是 visitFunction 的函数作用域。 思考题 请画出下面 MiniDecaf 代码的控制流图。int main(){ int a = 2; if (a "},"docs/step6/dataflow.html":{"url":"docs/step6/dataflow.html","title":"数据流分析","keywords":"","body":"数据流分析 编译优化的基础是数据流分析。 基本块（basic block）和控制流图（control-flow graph）是用于进行上述分析的数据结构。 以下讲述数据流分析的内容中，所有的 CondBranch 指令为条件跳转指令，Branch 指令为跳转指令。 基本块 基本块是指一段这样的代码序列： 除出口语句外基本块中不含任何的 Branch、Beqz（条件为假时跳转）、Bnez（条件为真时跳转）或者 Return 等跳转语句（但可以包含 Call 语句）。 除入口语句外基本块中不含任何的 Label 标记，即不能跳转到基本块中间。 在满足前两条的前提下含有最多的连续语句，即基本块的头尾再纳入一条语句将会违反上面两条规则。 下面的例子中，代码中不同的基本块被标以不同的颜色： 也就是说，基本块内的代码执行过程总是从基本块入口开始，到基本块出口结束的，中间不会跳到别的地方或者从别的地方跳进来。 控制流图 控制流图是一个有向图：它以基本块作为结点，如果一个基本块 A 执行完之后，有可能跳转到另一个基本块 B，则图中包含从 A 对应结点到 B 对应结点的有向边。对于以 Branch 语句或者任何非跳转语句结尾的基本块，其后继只有一个结点；对于以 CondBranch 语句结尾的基本块，其后继含有两个结点，分别对应跳转条件为真和假的情况。不难想像，控制流图的有向边组成的每一个环路都对应着程序中的一个循环结构。由于该图给出程序控制流的各种可能执行路径，因此也称为控制流图。 为进行编译优化，建立控制流图是必不可少的一步。已知一个操作序列，如何根据这个操作序列建立对应的控制流图呢？通常分为两步进行： 划分基本块。 建立基本块之间的连接关系。 基本块的划分算法比较简单：从头到尾扫描操作序列，当遇到以下情况时结束当前基本块，并开始一个新的基本块建立过程： 当遇到一个 Label 标记而且存在跳转语句跳转到这个行号时。 当遇到 Branch、CondBranch 或者 Return 等跳转语句时。 整个操作序列扫描完毕后，我们就成功建立了所有基本块。 在划分好基本块之后，需要从头到尾依次扫描所有的基本块建立控制流图： 如果当前基本块以 Branch 结尾，则在当前基本块与所跳转到的目标基本块之间加入一条有向边。 如果当前基本块以 CondBranch 结尾，则在当前基本块和跳转条件成立与不成立的目标基本块之间分别加入一条有向边（共 2 条边）。 如果当前基本块以 Return 结尾，则不需要加入新的边。 在所有的基本块都扫描完毕后，即建立了控制流图。基于控制流图，可以进行控制流分析。 上面例子对应的控制流图如下： 活跃变量和活跃变量方程 从编译器中端出来的中间代码中，我们对 TAC 中使用的临时变量的个数并没有做任何限制。但是在实际机器中，物理寄存器的数量是有限的。 因此我们需要想办法把这些无限多的临时变量“塞”到有限个物理寄存器里面：如果两个临时变量不会在同一条指令中被用到，那么我们可以让这两个临时变量使用同一个物理寄存器（把一部分当前指令用不到的临时变量保存到栈上）。 根据这样的原则，大多数的临时变量都可以用有限的几个物理寄存器对应起来，而“塞不下”的那些临时变量，则可以暂时保存到内存里面（因为访问内存的时间比访问寄存器的时间多得多，因此临时变量应尽可能一直存放在物理寄存器中，尽量不要 spill 到栈上）。 由于一个物理寄存器在确定的时刻只能容纳一个临时变量，因此为了把若干个变量塞到同一个物理寄存器里面，我们需要知道各个临时变量分别在哪条指令以后不会再被用到（以便腾出当前临时变量占用的物理寄存器给别的临时变量）。此时我们需要用到活性分析（liveness analysis），或者称为“活跃变量分析”。 一个临时变量在某个执行点是活的（也叫“活跃”、live），是指该临时变量在该执行点处具有的值会在这个执行点以后被用到，换句话说，就是在该执行点到给这个临时变量重新赋值的执行点之间存在着使用到这个临时变量的语句。活性分析是指分析每一个临时变量在程序的每一个执行点处的活跃情况，通常是通过计算出每个执行点处的活跃变量集合来完成。 下面代码中每行语句右边都给出了执行完该语句后的活跃变量集合： TAC 代码 活跃变量集合 _T0 = 4 {_T0} _T1 = 3 {_T0, _T1} _T2 = _T0 * _T1 {_T0} _T3 = _T0 * _T0 {_T0, _T3} _T2 = _T3 * _T3 {_T0, _T2, _T3} _T2 = _T0 * _T2 {_T2, _T3} _T1 = _T2 * _T3 {_T1} return _T1 空集 一般来说，活性分析是通过求解活跃变量方程来完成的。为了介绍活跃变量方程的概念， 我们需要先引入下面四种针对基本块的集合： Def 集合：一个基本块的 Def 集合是在这个基本块内被定值的所有变量。所谓的定值 （definition），可以理解为给变量赋值，例如加法语句给目标变量定值等（注意：Store 语句不给任何变量定值，Load 语句则会给对应变量定值）。 LiveUse 集合：一个基本块的 LiveUse 集合是在这个基本块中所有在定值前就被引用过的变量，包括了在这个基本块中被引用到但是没有被定值的那些变量。 LiveIn 集合：在进入基本块入口之前必须是活跃的那些变量。 LiveOut 集合：在离开基本块出口的时候是活跃的那些变量。 其中 Def 和 LiveUse 是基本块本身的属性，对每个基本块从后往前遍历基本块内的指令便可以求出。 有了基本块的这四个集合的概念，我们给出控制流图中每个基本块满足的活跃变量方程: 该方程说的是一个基本块的 LiveOut 集合是其所有后继基本块的 LiveIn 集合的并集，而且 LiveIn 集合是 LiveUse 集合的变量加上 LiveOut 集合中去掉 Def 集合以后的部分。 这个方程的直观意义是： 一个基本块的任何一个后继基本块入口处活跃的变量在这个基本块的出口必须也是活跃的。 在一个基本块入口处需要活跃的变量是在该基本块中没有定值就被使用的变量，以及在基本块出口处活跃但是基本块中没有定值过的变量（因为它们的初值必定是在进入基本 块之前就要具有的了）。 根据这个方程，我们可以通过迭代更新的办法求出每个基本块的 LiveIn、LiveOut 集合，以下是求解的伪代码： for i 获得了每个基本块的 LiveIn 和 LiveOut 集合以后，我们需要进一步地计算基本块内每个 TAC 语句的 LiveIn 和 LiveOut 集合。如果我们把基本块内所有 TAC 语句分别看成是一个独立的基本块，则不难想像，前面提到的活跃变量方程仍然有效，不同之处在于，一个基本块对应的 “控制流图” 有以下三种特点： 每个节点的出度都是 1，也就是说 LiveOut(B) = LiveIn(Succ(B))。 由于每个结点只含有一个语句，因此其 Def 集要么是空集，要么只含有一个元素。 由于每个结点对应的语句里所引用的所有变量在使用的时候都未在该基本块中经过定值，其 LiveUse 集合就是源操作数对应的所有变量。 基于上面三个特点，已经求出基本块的 LiveOut 集合的前提下我们只需要在每个基本块内从后往前遍历基本块内的指令就可以对每条基本块内指令求出 LiveIn、LiveOut。 "},"docs/step6/spec.html":{"url":"docs/step6/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step6 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | compound_statement declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step6 语义规范 6.1 根据其声明的位置，每一个标识符都属于一个作用域。目前我们有两种作用域：文件级和块级。如果是在块中声明，则标识符其声明所属的块的作用域中，例如局部变量；否则标识符在文件级（全局）作用域中，例如全局变量。 6.2 （更新 5.6）如果一个标识符在两个作用域里面，这两个作用域必然是嵌套的，即一个内层作用域完全被另一个外层作用域所覆盖。且在内层作用域中，外层作用域里该标识符所指派（designate）的变量或函数是不可见的。 在初始化表达式中，其正在初始化的变量已被声明，会隐藏（shadow）外层作用域的同名变量，但其值不确定。例如在下面的代码片段中，a + 1 的值是不确定的。 int a = 1; { int a = a + 1; } 6.3 （更新 5.3）对于同一个标识符，在同一个作用域中至多有一个声明。 6.4 （更新 5.4）使用不在当前开作用域中的变量名是不合法的。 "},"docs/step-parser/intro.html":{"url":"docs/step-parser/intro.html","title":"实验要求","keywords":"","body":"实验指导 parser-stage：自顶向下语法分析器 在 Stage1-2 中，实验框架使用了 ply 作为语法分析器，解析 MiniDecaf 程序并生成 AST。 在 parser-stage 中，我们将结合课堂上学习的 LL(1) 分析方法，完成一个手工实现的递归下降语法分析器。为了降低难度和工作量，将提供分析器的基本框架和部分实现，同学们只需要补全代码片段即可。所实现的手工语法分析器，只需要支持 Step1-6 的语法。 准备工作 parser-stage 不涉及中端、后端部分，所以请同学们将 stage2 中完成的中后端代码合并到 parser-stage 的实验框架上。具体的操作可以参考如下步骤： $ git switch parser-stage $ git merge stage-2 （本步骤所需要的额外文件请在此处获取，在 python/ 下） 在切换到 parser-stage 分支之后，从链接下载 python 目录下的文件，并使用 frontend/parser/ 目录整个替换你 stage2 代码的对应目录，然后在整体框架上完成实验。 需要注意的是，parser-stage 的实验相对于其他 stage 是独立的。在后续进行 stage3 的实验时，应从 stage2 所完成的代码开始，而不需要用 parser-stage 的代码。未来在进行 stage3 实验时，建议进行如下操作： $ git switch stage-3 # 注意不要从 parser-stage merge $ git merge stage-2 背景知识 如果你已经很熟悉自顶向下语法分析、自底向上语法分析的原理，可以跳过这部分。这里我们只对两种语法分析方法进行简单介绍，详细原理请参考课件。 bison/ply 自动生成的语法分析器，属于 LALR(1) 语法分析，是自底向上的语法分析方法。 具体来说，维护一个栈（保存状态和符号），每一步操作如果是移进（shift）操作，则将新的 token 加入栈顶；如果是归约（reduce）操作，则依据归约对应的产生式的右端，将栈顶的状态和符号依次弹出，然后将产生式左端的非终结符（以及对应转移到的状态）入栈。根据归约的结果，从语法树的最底层开始，自底向上构建 AST 结点，最终得到整个 AST。 而递归下降语法分析的过程是: 从文法开始符号（对应 AST 的根结点）起，通过预测集合 PS（实际实现中，为了简便，直接采用了 First 集和 Follow 集）以及输入符号，选择对应的产生式。对于产生式右侧的非终结符和终结符分别进行不同的操作，对于非终结符通过调用递归函数进行处理，对于终结符通过 matchToken（实际实现中，用 lookahead 函数实现） 进行处理。由于在递归下降分析的过程中，只有分析完叶子结点后，才会返回，所以实际的 AST 构造过程也是自底向上构建 AST 结点，最终得到整个 AST。 任务描述 要求： 使用所提供的 parser-stage 框架替换你的编译器中的 parser 部分，完善框架中的实现，通过 Step1-6 的测试。 本步骤需要修改的代码均有 TODO 标识，并有相关的引导注释。其中需要修改的文件为 frontend/parser/my_parser.py。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step-parser/example.html":{"url":"docs/step-parser/example.html","title":"通过例子学习","keywords":"","body":"parser-stage 框架介绍 下面我们介绍 parser-stage 实验框架中的一些函数，来帮助大家更好地理解实验框架。 注意我们的框架并不完全是课堂讲授的基于 LL(1) 文法的递归下降分析方法，在有些地方会通过 while 循环来解析多个连续的、左结合的表达式，对应于等价的拓展巴克斯范式（EBNF）文法。详见下文关于 p_multiplicative 函数的介绍。 框架接口 lookahead 函数 def lookahead(self, type: Optional[str] = None) -> Any 词法分析器 lex 将程序字符串转换为一串 token， 用 next(lexer) 获取词法分析器提供的下一个 token。 为了实现递归下降语法分析中的 \"lookahead\" 机制，我们需要看下一个 token 是什么，但却不能消耗这个 token，为此我们用一个变量 next_token （Parser.next_token）暂存将要被解析的下一个 token。通过判断 next_token 的类型，来判断将要使用哪一条产生式。 而 lookahead() 函数有两个重载的版本。一个版本不带参数，直接读取一个 token； 另一个版本传入了一个 token 类型做参数，表示希望读取一个特定类型的 token，如果类型不符则报错。每次执行 lookahead() 函数，都会消耗当前的 next_token 并从词法分析器获得新的 token 赋值给 next_token 变量。 注意直接访问 next_token 变量和执行 lookahead() 函数的区别在于：是否消耗一个 token 并向词法分析器请求下一个 token。next_token 变量不会消耗，而 lookahead() 函数则会消耗一个 token。 First/Follow 某个产生式的 First 集合，包括可能在该产生式右端第一个出现的所有 token。如果该产生式可以产生空串，则该 First 集合也包含空串。 某个非终结符的 Follow 集合，包括可能紧跟出现在该非终结符之后 token。 在我们的框架里，因为语法非常简单，所以没有进一步计算 PS 预测集合，而是直接用 if 语句结合 First/Follow 集合直接进行判断（用 if 语句枚举判断输入的 token 是否属于集合中的元素）。 代码框架中通过装饰器模式（decorator pattern）定义了每个产生式左端非终结符的 First 集合，例如 p_declaration 函数开头的 @first(\"Int\") 表示 declaration 的 First 集只包含 token 'Int'。代码框架里没有显式定义 Follow 集合。事实上，需要同学们完善的部分里并不需要用到 First/Follow 集合，直接使用 if 语句判断即可。 p_Multiplicative 我们使用代码框架中的 p_multiplicative() 函数介绍框架里是如何使用与语法规范等价的 EBNF 文法及其解析方法。这两个函数都希望从当前的 token 流中，解析出一个 multiplicative 表达式，并返回其语法树结点。 multiplicative 对应的语法为： multiplicative : multiplicative '*' unary | multiplicative '/' unary | multiplicative '%' unary | unary 容易发现，这个产生式是左递归的，不适合基于 LL(1) 的递归下降 分析器直接处理。我们将其转换为 EBNF 的形式进行程序解析：multiplicative : unary { '*' unary | '/' unary | '%' unary } 其中，EBNF 中的大括号表示重复零次或任意多次。 注意到产生式的开头总有一个 Unary 非终结符，所以我们递归调用 p_Unary() 函数解析对应的 Unary 非终结符，如果通过 next_token 检查到后续符号不属于 *、/ 或 %，就可以直接返回创建并返回 Unary AST结点。否则，通过 lookahead() 读取掉运算符 (* / %)，并按照左结合的方法，循环解析更多的 Unary 非终结符。最终完成 Multiplicative 对应 AST 结点的构建。 例如，让我们考虑这个函数如何处理连乘积 1*2*3*(4+5)*x： 递归解析出 1 对应的 Unary AST 结点，然后进入 while 循环： while 循环第一轮: lookahead 消耗掉 *，递归解析出 2 对应的 AST 结点，然后构建 1*2 这个乘法表达式对应的 AST 结点； while 循环第二轮: lookahead 消耗掉 *，递归解析出 3 对应的 AST 结点，然后构建 1*2*3 这个乘法表达式对应的 AST 结点； ……（以此类推） 直到处理完 x 后，发现下一个 token 不是 *，那么当前 multiplicative 非终结符对应的文法 parse 结束，并返回 AST 结点。 最后得到的 AST 为： binary(*) [ binary(*) [ binary(*) [ binary(*) [ int(1) int(2) ] int(3) ] binary(+) [ int(4) int(5) ] ] identifier(x) ] 需要填写的函数 实验框架中标记有 TODO 的函数需要我们填写。填写正确后，合并 stage2 的中端、后端，要求通过 step1-6 的测例。 需要完成的函数： p_relational p_logical_and p_assignment p_expression p_statement p_declaration p_block p_if p_return p_type 思考题 在框架里我们使用 EBNF 处理了 additive 的产生式。请使用课上学习的消除左递归、消除左公因子的方法，将其转换为不含左递归的 LL(1) 文法。（不考虑后续 multiplicative 的产生式） additive : additive '+' multiplicative | additive '-' multiplicative | multiplicative 对于我们的程序框架，在自顶向下语法分析的过程中，如果出现一个语法错误，可以进行错误恢复以继续解析，从而继续解析程序中后续的语法单元。 请尝试举出一个出错程序的例子，结合我们的程序框架，描述你心目中的错误恢复机制对这个例子，怎样越过出错的位置继续解析。（注意目前框架里是没有错误恢复机制的。） （选做，不计分）指出你认为的本阶段的实验框架/实验设计的可取之处、不足之处、或可改进的地方。 "},"docs/step-parser/spec.html":{"url":"docs/step-parser/spec.html","title":"规范","keywords":"","body":"parser-stage 语法规范（同 step6） program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | compound_statement declaration : type Identifier ('=' expression)? ';' assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier "},"docs/step7/intro.html":{"url":"docs/step7/intro.html","title":"实验要求","keywords":"","body":"实验指导 step7： step7 我们要支持条件语句，包括 if 语句和条件表达式（又称三元/三目表达式，ternary expression）。 语法上的改动是： if 表达式 statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? 条件表达式 assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional if 语句的语义和 C 语言相同，注意条件表达式优先级只比赋值高。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 4 的实验报告需要放在 stage-4 这个 branch 下的 ./reports/stage-4.pdf。整个 stage 4 只需要提交一份报告，你不需要单独为 step 7 准备报告。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step7/example.html":{"url":"docs/step7/example.html","title":"通过例子学习","keywords":"","body":"step7 实验指导 本实验指导使用的例子为： int main() { int x = 1; if (x) x = 2; else x = 3; return x; } 词法语法分析 针对 if 语句，我们需要设计 AST 节点来表示它，给出的参考定义如下（框架中已经提供）： 节点 成员 含义 If 分支条件 cond，真分支 then，假分支 otherwise if 分支语句 仿照 if 节点，还需要类似地实现条件表达式节点。 悬吊 else 问题 这一节引入的 if 语句既可以带 else 子句也可以不带，但这会导致语法二义性：else 到底和哪一个 if 结合？ 例如 if(a) if(b) c=0; else d=0;，到底是 if(a) {if(b) c=0; else d=0;} 还是 if(a) {if(b) c=0;} else d=0;？ 这个问题被称为 悬吊 else（dangling else） 问题。 如果程序员没有加大括号，那么我们需要通过一个规定来解决歧义。 我们人为规定：else 和最近的 if 结合，也就是说上面两种理解中只有前者合法。 为了让 parser 能遵守这个规定，一种方法是设置产生式的优先级，优先选择没有 else 的 if。 按照这个规定，parser 看到 if(a) if(b) c=0; else d=0; 中第一个 if 时，选择没有 else 的 if； 而看到第二个时只能选择有 else 的 if ，也就使得 else d=0; 被绑定到 if(b) 而不是 if(a) 了。 需要说明的是 bison 默认在 shift-reduce conflict 的时候选择shift，从而对悬挂else进行就近匹配。 语义分析 本步骤中语义分析没有特别需要增加的内容，只需要在扫描到 if 语句和条件表达式时递归地访问其子结点即可。请注意 if 语句不总是有 else 分支，所以在递归到子结点时，请先判断子结点是否存在。 中间代码生成 从本步骤开始，由于 MiniDecaf 程序出现了分支结构，我们需要开始考虑跳转语句了。在 Step1-4 中，TAC 代码中的标签只有标志 main 函数入口这一个功能。而现在，我们需要使用标签来指示跳转指令的目标位置。我们用 _Lk 来表示跳转用标签，以此和函数入口标签区分开来。 为了实现 if 语句，我们需要设计两条中间代码指令，分别表示条件跳转和无条件跳转，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 作用 BEQZ T0, Label 若 T0 的值为0，则跳转到 LABEL 标签处 JUMP Label 跳转到 LABEL 标签处 现在让我们来看看示例所对应的 TAC 代码： main: _T1 = 1 _T0 = _T1 BEQZ _T0, _L1 _T2 = 2 _T0 = _T2 JUMP _L2 _L1: _T3 = 3 _T0 = _T3 _L2: return _T0 在这段 TAC 代码中，x 对应的临时变量为 _T0。如果 x 的值为真（不等于0），那么应当执行 then 分支 x = 2;，否则执行 else 分支 x = 3;。因此，我们设置了两个跳转标签 _L1 和 _L2，分别表示 else 分支开始位置和整个 if 语句的结束位置。如果 x 为假，那么应当跳转到 _L1 处，我们使用一条 BEQ 指令来执行。如果 x 为真，那么按顺序执行 then 分支的代码，并在该分支结束时，用一条 JMP 指令跳转到 if 语句的结束位置，从而跳过 else 分支。在 TAC 生成过程中，每当扫描到 if 语句时，都需要调用 TAC 的底层接口，新建两个跳转标签，并按照这种方式生成中间代码。 当然，如果一条 if 语句没有 else 分支，那么只需要一个跳转标签即可。例如我们将例子中的 if 语句修改为 if (x) x = 2;，则对应的 TAC 代码可简化为： main: _T1 = 1 _T0 = _T1 BEQ _T0, _L1 _T2 = 2 _T0 = _T2 _L1: return _T0 同样地，条件表达式也可以使用类似的方法完成中间代码生成。要注意的是，条件表达式是一种特殊的表达式，因此有返回值。同学们在实现的时候不要忘记为其分配临时变量。 目标代码生成 Step7 中目标代码生成主要是指令的选择以及 label 的声明，RISC-V 提供了与中间代码中 BEQZ 和 JUMP 类似的指令： step7: # RISC-V 汇编标签 beqz t1, step7 # 如果 t1 为 0，跳转到 step7 标签处 j step7 # 无条件跳转到 step6 标签处 思考题 我们的实验框架里是如何处理悬吊 else 问题的？请简要描述。 在实验要求的语义规范中，条件表达式存在短路现象。即： int main() { int a = 0; int b = 1 ? 1 : (a = 2); return a; } 会返回 0 而不是 2。如果要求条件表达式不短路，在你的实现中该做何种修改？简述你的思路。 总结 本节主要就是引入了跳转，后面 Step8 循环语句还会使用。 "},"docs/step7/spec.html":{"url":"docs/step7/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step7 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' block_item* '}' type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | compound_statement | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier 注意：if 的 then 分支和 else 分支需要是一个语句（statement）而非声明（declaration）。 例如 if (1) int a; 不是合法的 MiniDecaf 程序。 step7 语义规范 7.1 条件表达式会先对第一个操作数求值，再根据其值选择计算第二个或第三个操作数。当且仅当第一个操作数的值不等于 0，我们会对第二个操作数求值。当且仅当第一个操作数的值等于 0，我们会对第三个操作数求值。当第一个操作数的值为 0 时，条件表达式的求值结果为第二个操作数所求得的值；当第一个操作数的值非 0 时，条件表达式的求值结果为第三个操作数所求得的值。 不论选择第二个操作数或者是第三个操作数去求值，都必须首先计算完第一个操作数，之后才能开始第二个或第三个操作数的求值计算。 7.2 对于 if 语句而言，当控制条件不等于 0 时，会执行第一个子句；当控制条件等于 0 时，如果有 else 分支，就会执行第二个语句，否则整个 if 语句的执行便已经完成。 7.3 如果出现悬吊 else（dangling else），要求 else 优先和最接近的没有匹配 else 的 if 匹配。 例如 if (0) if (0) ; else ; 等价于 if (0) { if (0) ; else; } 而非 if (0) { if (0) ; } else ;。 "},"docs/step8/intro.html":{"url":"docs/step8/intro.html","title":"实验要求","keywords":"","body":"实验指导 step8：循环语句 step8 我们要增加对循环语句，以及 break/continue 的支持： statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' 循环语句的语义和 C 语言相同，注意检查 break/continue 不能出现在循环外。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 4 的实验报告需要放在 stage-4 这个 branch 下的 ./reports/stage-4.pdf。整个 stage 4 只需要提交一份报告，你不需要单独为 step 8 准备报告。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step8/example.html":{"url":"docs/step8/example.html","title":"通过例子学习","keywords":"","body":"step8 实验指导 本实验指导使用的例子为： for (int i = 0; i 词法语法分析 针对循环语句和 break/continue 语句，我们需要设计 AST 节点来表示它，给出的参考定义如下： 节点 成员 含义 While 循环条件 cond，循环体 body while 循环语句 For 初始语句 init，循环条件 cond，更新语句 update，循环体 body for 循环语句 Break 无 break 语句 Continue 无 continue 语句 其中，while 和 break 语句的实现已经在框架中给出，同学们可以参考并实现 for 和 continue 语句。 语义分析 本步骤语义分析阶段的处理方式和 Step7 中的 if 语句相类似，但是请额外注意以下两点： for 循环要自带一个作用域。在示例里，for (int i = 0; i 语句里定义的循环变量处于一个独自的作用域里。这也就是说，我们可以在循环体内部定义同名变量。如果我们把示例修改为：for (int i = 0; i 这也是合法的 MiniDecaf 程序。因此，在符号表构建阶段，扫描到 for 结点时，不要忘记开启一个局部作用域。 break 和 continue 语句必须位于循环体内部才合法。因此，在扫描过程中，需要记录当前结点位于多少重循环内。扫描到 break 和 continue 结点时，若当前不处于任何循环内，则报错。 中间代码生成 本步骤中没有需要新增的 TAC 指令。不过为了实现循环语句，需要仔细地考虑如何将 MiniDecaf 循环语句翻译成 TAC 的分支跳转指令。由于 while 循环可以看作 for 循环的特例，我们选择了 for 循环作为示例。 让我们先来看看示例对应的 TAC 代码： _T1 = 0 _T0 = _T1 # int i = 0; _L1: # begin label _T2 = 5 _T3 = LT _T0, _T2 BEQZ _T3, _L3 # i 为了实现所有可能的跳转，对每个 for 循环我们都需要定义三个跳转标签：begin, loop 和 break。它们的作用如下： begin 标签（示例中的 _L1）是循环体的开始位置。初次进入循环时，从这个标签的位置开始执行，并判断循环条件是否满足，若不满足，则跳转到 break 标签（示例中的 _L3）处。 loop 标签（示例中的 _L2）是执行 continue 语句时应当跳转到的位置。 break 标签是整个循环结束后的位置。如果循环条件不满足，或者执行了 break 语句，那么应当跳转到此处，执行循环之后的指令。 请注意，示例给出的只是一种循环语句参考实现，同学们也可以设计自己的实现方法。 由于循环语句可以嵌套，所以 TAC 语句生成过程中需要动态维护 loop 标签和 break 标签，这样才能确定每一条 break 和 continue 语句跳转到何处。因此，在 TAC 生成时，需要使用栈结构维护从内到外所有的 loop 标签和 break 标签。 utils/tacgen/tacgen.py 里的 TACFuncEmitter 类里实现了维护 TAC 生成时需要的上下文信息的功能。同学们可以在这个类中增加对循环所需的 break/continue 标签的维护。 目标代码生成 由于不需要增加新的中间代码指令，本步骤中目标代码生成模块没有新的内容。除非之前步骤的实现有误，否则这个步骤应该不会出现错误。 思考题 将循环语句翻译成 IR 有许多可行的翻译方法，例如 while 循环可以有以下两种翻译方式： 第一种（即实验指导中的翻译方式）： label BEGINLOOP_LABEL：开始下一轮迭代 cond 的 IR beqz BREAK_LABEL：条件不满足就终止循环 body 的 IR label CONTINUE_LABEL：continue 跳到这 br BEGINLOOP_LABEL：本轮迭代完成 label BREAK_LABEL：条件不满足，或者 break 语句都会跳到这儿 第二种： cond 的 IR beqz BREAK_LABEL：条件不满足就终止循环 label BEGINLOOP_LABEL：开始下一轮迭代 body 的 IR label CONTINUE_LABEL：continue 跳到这 cond 的 IR bnez BEGINLOOP_LABEL：本轮迭代完成，条件满足时进行下一次迭代 label BREAK_LABEL：条件不满足，或者 break 语句都会跳到这儿 从执行的指令的条数这个角度（label 不算做指令，假设循环体至少执行了一次），请评价这两种翻译方式哪一种更好？ 我们目前的 TAC IR 中条件分支指令采用了单分支目标（标签）的设计，即该指令的操作数中只有一个是标签；如果相应的分支条件不满足，则执行流会继续向下执行。在其它 IR 中存在双目标分支（标签）的条件分支指令，其形式如下： br cond, false_target, true_target 其中cond是一个临时变量，false_target和true_target是标签。其语义为：如果cond的值为0（假），则跳转到false_target处；若cond非0（真），则跳转到true_target处。它与我们的条件分支指令的区别在于执行流总是会跳转到两个标签中的一个。 你认为中间表示的哪种条件分支指令设计（单目标 vs 双目标）更合理？为什么？（言之有理即可） "},"docs/step8/spec.html":{"url":"docs/step8/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step8 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step8 语义规范 方便起见，我们称 for 循环括号中的三个表达式/声明自左向右依次为 init、ctrl 和 post。 例如 for (i=0; i 中，i=0 是 init，i 是 ctrl，i=i+1 是 post。 8.1 有两种循环语句：for 循环、while 循环。执行一条循环语句，意味着反复执行一条语句（即循环体），直到其控制表达式等于 0。 8.2 while 循环的控制表达式的求值在循环体的每次执行之前。 8.3 对于 for 循环而言：如果 init 是一个声明，其声明发生在控制表达式的第一次求值之前；如果 init 是一个表达式，其求值会在控制表达式的第一次求值之前。ctrl 即是控制表达式，其求值在循环体的每次执行之前。post 的求值在循环体的每次执行之后。 8.4 for 循环的 init、ctrl 和 post 都可以被省略。省略 ctrl 等价于将其替换为一个非零常数，比如 1。 8.5 循环语句有其自己的作用域，且是它所在的作用域的子集。循环体也有其作用域，且是循环语句的作用域的子集。如果 for 循环的 init 是一条声明，则其所声明的变量所属的作用域是整个 for 循环语句的作用域（包含 init、ctrl、post 和循环体）。 例如，for (int i=0;;i=i+1) { int i=1; return i; } 是合法的代码片段。 8.7 continue 语句和 break 语句要么出现在循环体里，要么其就是循环体。 8.8 执行一条 continue 语句，意味着将程序的执行跳转至该条 continue 语句所在的最小的循环语句的循环体的末尾。 例如，for (int i=0;i 等价于 for (int i=0;i。 8.9 执行一条 break 语句，意味着终止该条 break 语句所在的最小的循环语句的执行。 "},"docs/step9/intro.html":{"url":"docs/step9/intro.html","title":"实验要求","keywords":"","body":"实验指导 step9：函数 step9 开始，我们要支持多函数了。 我们需要支持函数的声明和定义： program : function* function : type Identifier '(' parameter_list ')' (compound_statement | ';') parameter_list : (type Identifier (',' type Identifier)*)? 我们还需要支持函数调用： expression_list : (expression (',' expression)*)? unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' 语义检查部分，我们需要检查函数的重复定义、检查调用函数的实参（argment）和形参（parameter）的个数类型一致。我们不支持 void 返回类型，这可以通过忽略函数的 int 返回值实现。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 5 的实验报告需要放在 stage-5 这个 branch 下的 ./reports/stage-5.pdf。注意报告的标题是 stage-5 而不是 step-9。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step9/example.html":{"url":"docs/step9/example.html","title":"通过例子学习","keywords":"","body":"step9 实验指导 本实验指导使用的例子为： int func(int x, int y) { return x + y; } int main() { return func(1, 2); } 词法语法分析 针对函数特性，我们需要设计 AST 节点来表示它，给出的参考定义如下： 节点 成员 含义 Function 返回类型 return_type，函数名 ident，参数列表 params，函数体 body 函数 Parameter 参数类型 var_type，变量名 ident 函数参数 Call 调用函数名 ident，参数列表 argument_list 函数调用 语义分析 本步骤中引入了函数，和局部变量类似，不允许调用未声明的函数，也不允许重复定义同名函数（允许重复声明，但要求声明类型一致）。因此，需要在全局作用域的符号表里维护函数符号。函数符号存放在栈底的全局作用域中，在遍历 AST 构建符号表的过程中，栈底符号表一直存在，不会被弹出。 此外，由于函数体内部除了局部变量以外，还有函数参数（argument）。因此，我们进入一个函数，开启函数体局部作用域时，需要将所有的参数加进该作用域的符号表中。举例来说，如果我们将示例改成： int func(int x, int y) { int x = 1; return x + y; } 那么语义检查时应当报错。 函数符号的实现在 frontend/symbol/funcsymbol.py 中。 中间代码生成 为了实现函数，我们需要设计至少一条中间代码指令来表示函数调用，给出的参考定义如下（推荐大家这样实现）： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 CALL LABEL(T0, T1, ...) 调用函数 LABEL，传入的实参为T0、T1等 下面是一段含有函数调用的代码片段： T0 = CALL foo(T1, T2) T1和T2作为被调用函数foo的实参，而调用后的返回值保存在T0中。 示例可以对应如下的 TAC 程序： func: _T2 = ADD _T0, _T1 return _T2 # 参数 x 和 y 分别对应 _T0, _T1 main: _T0 = 1 _T1 = 2 _T2 = CALL func(_T0, _T1) # 调用函数 return _T2 实际上这与高级语言的函数语义非常相似。你可能会觉得一个与源语言语义几乎没差别的中间代码函数调用指令有点多余，所以我们也提供了另一种方案（不推荐按照这样实现，可能会造成数据流分析困难）。 在早先的文档中，函数调用涉及CALL和PARAM两种指令。CALL指令只对应实际汇编代码的函数调用，而PARAM T0指令用于传递一个参数。 假设我们有若干个参数，可以依次使用 PARAM 命令将它们加入参数列表。在调用函数时，这些参数的值会自动依次按顺序装载到临时变量 _T0, _T1 ... 中。比如我们有这样一段 TAC 程序： PARAM A PARAM B PARAM C XX = CALL XXX 因此，示例可以对应如下的 TAC 程序： func: _T2 = ADD _T0, _T1 return _T2 # 参数 x 和 y 分别对应 _T0, _T1 main: _T0 = 1 PARAM _T0 # 将 _T0 的值作为参数 x _T1 = 2 PARAM _T1 # 将 _T1 的值作为参数 y _T3 = CALL func # 调用函数 return _T3 同学们可以选择使用这两种方案中的任何一种，也可以自行设计函数调用的中间表示。 思考 在本次实验中我们设置了一道关于函数调用中间表示设计的思考题。下面的问题或许能帮助你思考（你无需回答这里的问题，这里也没有标准答案）： 中间表示应该更接近源语言（高级语言）还是目标语言（例如汇编语言）？ 到目前为止实验文档给出的参考中间表示更接近源语言还是目标语言？ 如果你感兴趣，可以了解一下LLVM IR。 目标代码生成 下面是一种可能的目标汇编代码，你的编译器生成的代码无需与其完全一致。 .text .global main func: # start of prologue addi sp, sp, -56 # end of prologue # start of body add t0, a0, a1 mv a0, t0 j func_exit # end of body func_exit: # start of epilogue addi sp, sp, 56 # end of epilogue ret main: # start of prologue addi sp, sp, -56 sw ra, 52(sp) # end of prologue # start of body li t0, 1 li t1, 2 mv a0, t0 mv a1, t1 call func mv t0, a0 mv a0, t0 j main_exit # end of body main_exit: # start of epilogue lw ra, 52(sp) addi sp, sp, 56 # end of epilogue ret 首先你需要参考之前步骤中实现的方法，翻译本步骤中新增的中间代码指令。 完成这个步骤的过程中你可能需要回顾step 2中对于后端翻译的介绍和step 5中对于寄存器分配和栈帧的介绍来回想一下后端每个部分在做什么。 函数调用 程序代码里的一个函数调用，包含了下面一系列的操作： （汇编）保存 caller-saved 寄存器。 准备参数，完成传参。 执行汇编中的函数调用指令，开始执行子函数直至其返回。 拿到函数调用的返回值，作为函数调用表达式的值。 具体依赖于1的处理方式，可能需要恢复 caller-saved 寄存器。 上述步骤 1-5 称为调用序列（calling sequence）。然而，调用序列中有一些问题需要解决：如何进行参数传递？如何获取函数返回值？调用者（caller）和被调用者（callee）需要保存哪些寄存器，如何保存？调用者和被调用者通常对以上问题约定解决方式，并同时遵守这些约定。这些调用者与被调用者共同遵守的约定称为调用约定（calling convention）。调用约定通常在汇编层级使用，汇编语言课上也有涉及。因为汇编语言是低级语言，缺乏对函数的语言特性支持，只有标号、地址、寄存器，所以需要调用约定，规定如何用汇编的语言机制实现函数调用。 调用约定 我们给出RISC-V标准调用约定供大家参考，你可以不按照标准调用约定实现，这样的话你需要自己定义一种调用约定。如果你实现的是标准调用约定，你的编译器生成的代码还可以与gcc生成的代码进行链接，比如链接标准库，实现输入输出等功能。 RISC-V 的标准调用约定 caller-saved 和 callee-saved 寄存器 上表给出 RISC-V 中 32 个整数寄存器的分类。所谓 caller-saved 寄存器（又名易失性寄存器），是指不需要在各个调用之间保存的寄存器，如果调用者认为在被调用函数执行结束后仍然需要用到这些寄存器中的值，则需要自行保存。所谓 callee-saved 寄存器（又名非易失性寄存器），指这些寄存器需要在各个调用之间保存，调用者可以期望在被调用函数执行结束后，这些寄存器仍保持原来的值。这要求被调用者，如果使用这些寄存器，需要先进行保存，并在调用返回之前恢复这些 callee-saved 寄存器的值。 具体的保存方法并不限制，但一般都使用栈来保存。 函数参数以及返回值的传递 函数参数（32 位 int）从左到右存放在 a0 - a7 寄存器中，如果还有其他参数，则以从右向左的顺序压栈，第 9 个参数在栈顶位置。同学们可以使用编写一个带有多个参数的函数并进行调用，然后用 gcc 编译程序进行验证。 返回值（32 位 int）放在 a0 寄存器中。 实战教学 我们推荐大家按照以下步骤实现，当然这不是唯一的实现方式。前中端的部分在前面的step中涉及很多，大家应该已经比较熟悉，这里着重关注后端要做的事。 要做什么 由于调用约定的存在，中间表示里的函数调用指令无法像我们之前接触到的常规指令一样简单地翻译为实际汇编指令，我们必须生成额外代码进行寄存器保存、参数传递等操作以符合调用约定。这些额外操作会出现在真正的函数调用指令call周围，我们称之为“（生成）函数调用时的处理”或“对于调用者的处理”。 只是让caller调用函数的过程遵循调用约定还不够，被调用的每个函数callee也要遵守规范，保存恢复callee-saved寄存器、从正确的位置获取caller传入的参数。因为每个函数都是（潜在的）被调用者，故对于所有函数都要生成这些操作。我们称之为“生成函数体时的处理”或“对于被调用者的处理”。 你在后端主要需要实现的即为“对于调用者的处理”与“对于被调用者的处理”两部分。 对于调用者的处理 这里我们需要关注源文件backend/reg/bruteregalloc.py中的BruteRegAlloc类。 根据调用约定，调用其它函数后caller-saved即volatile寄存器中的值全部是无效的。这意味着如果函数调用前caller-saved寄存器中存放了后续仍活跃的临时变量，它们必须被倒腾到别的地方，如callee-saved寄存器或栈上。因此我们先将活跃且在caller-saved寄存器中的临时变量保存到栈上，这实际上让所有caller-saved寄存器变得空闲，以便于接下来在a0到a7中容纳参数。 保存活跃的临时变量：首先保存所有位于caller-saved寄存器中且活跃的临时变量，然后解除所有caller-saved寄存器与临时变量的绑定关系。你可以用subEmitter.emitStoreToStack和unbind来达到上述效果。 这是否意味着原本就在caller-saved寄存器中的参数也被丢到了栈上？似乎有些多余？ 是的，但这样处理比较简单。比较理想的方案是直接将参数从一个寄存器复制到目标参数寄存器，但这可能带来一些边角情况，你需要谨慎处理。 将参数放入寄存器：所有传参用到的寄存器(a0~a7)都是caller-saved寄存器，1中的操作保证了传参所需要的寄存器都是空的，因此直接将参数放到寄存器中即可。具体地，用物理寄存器a0~a7传递被调用函数的前8个参数，我们假设这8个参数对应的临时变量（Temp）为v0~v7。对于第i个参数，目标是将vi的值加载入ai。若vi已经与某个物理寄存器xj绑定，则可以生成指令mv ai, xj；如果vi的值不在物理寄存器中，调用emitLoadFromStack。（思考： 如果前面暂时不解除volatile寄存器的绑定，这里可能会有什么问题？ 你有更高效的解决方案吗？） 为什么有的临时变量可能在寄存器中？ 因为我们在步骤1中只操作了caller-saved寄存器。如果某个临时变量存放在callee-saved寄存器中，那么它不会在上一步骤被放到栈上。 用栈传递参数（可选）：调用约定规定a0至a7存放不下的参数需要用栈传递（为了降低大家的实现难度，基础实验中我们不对参数超过8个的传参实现进行测试）。若参数vi在物理寄存器xj中，则直接将xj“压栈”；否则任选一个a0~a7之外的volatile寄存器tk，我们先通过emitLoadFromStack将vi加载到tk，然后“压栈”tk（建议直接使用t0寄存器）。需要注意这里的“压栈”不能直接用emitStoreToStack，我们需要手动生成一条NativeStoreWord指令，而且它无需也不应该修改栈指针sp。在所有参数入栈后，统一修改sp。 进行真正的函数调用：可以使用emitAsm来生成一条调用指令。如果上一步中存在栈传参，别忘了在调用后把sp改回来（清除栈上传递的参数）。 妥善处理函数返回值：根据调用约定，函数返回值会存放在a0寄存器中。如果你在指令选择中为函数调用单独增添了将a0复制到目标临时变量的指令，这里无需处理。你也可以选择直接将目标临时变量绑定到a0。 记录函数调用情况（可选）：你也许需要在SubroutineEmitter中记录当前函数是否调用过其它函数，以便减少不必要的ra保存和恢复。 对于被调用者的处理 这里我们需要关注源文件backend/riscv/riscvasmemitter.py中的RiscvSubroutineEmitter类和backend/reg/bruteregalloc.py中的BruteRegAlloc类。被调用者需要从正确的位置获取到传入的参数，因此需要处理寄存器和临时变量的对应关系；同时在被调用函数的结尾我们要准确无误地返回到调用处，因此需要处理和返回地址相关的信息。 处理返回地址：具体需要保存和恢复ra寄存器，相关实现在emitFunc函数中。框架的现有部分已经帮助大家处理好了callee-saved寄存器的保存和恢复，你可以参照这部分实现ra寄存器的保存和恢复。（备注：严格来讲ra并不是callee-saved寄存器。ra会在什么情况下被修改？不过你可以选择总是保存和恢复ra。） 处理传入的函数参数和临时变量的对应关系：将传入的参数与临时变量绑定，这样在函数体中就可以直接使用这些参数。BruteRegAlloc类中的的bindings变量记录了临时变量和物理寄存器的对应关系，你可以使用bind, unbind函数来完成这些操作。思考应该在何处进行这个绑定操作。 一些可能带来困惑的地方 ra是一个caller-saved寄存器，但它有着和callee-saved寄存器相似的处理方式。一般而言只有当某个函数作为caller调用了其它函数时，它存放在ra中的返回地址才会被覆盖掉，这与其它caller-saved寄存器类似。然而鉴于ra的特殊用途，你可以把它视作一个callee-saved寄存器。 你可能会发现我们的框架能支持的栈空间大小有限，存放不了太多的临时变量。目前而言的确是这样，你无需考虑那种情况。 思考题 你更倾向采纳哪一种中间表示中的函数调用指令的设计（一整条函数调用 vs 传参和调用分离）？写一些你认为两种设计方案各自的优劣之处。 具体而言，某个“一整条函数调用”的中间表示大致如下： _T3 = CALL foo(_T2, _T1, _T0) 对应的“传参和调用分离”的中间表示类似于： PARAM _T2 PARAM _T1 PARAM _T0 _T3 = CALL foo 为何 RISC-V 标准调用约定中要引入 callee-saved 和 caller-saved 两类寄存器，而不是要求所有寄存器完全由 caller/callee 中的一方保存？为何保存返回地址的 ra 寄存器是 caller-saved 寄存器？ 总结 到这里，你已经完成了所有基础实验。有了对函数的支持，你的编译器也变得更加强大，你可以试着用它写一些更有意思的代码。 "},"docs/step9/spec.html":{"url":"docs/step9/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step9 语法规范 灰色部分表示相对上一节的修改。 program : function* function : type Identifier '(' parameter_list ')' ( compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier 我们暂不要求支持不包含函数体的函数声明。 step9 语义规范 9.1 在函数调用中，实参和形参的参数个数必须相同，同一位置的参数类型也必须相同。 9.2 在准备函数的调用时，所有的实参会被求值，然后赋给相应位置上的形参。 在函数体中，形参的值可能会被改变，但即便实参是一个可修改的左值，被调用函数中形参的改变也不会影响实参的值。 9.3 函数是可以递归调用的。 9.4 （更新 5.10）执行一条 return 语句，意味着终止当前函数的执行，并将控制权交还给调用当前函数的 caller，语句中的表达式的值会返还给 caller 作为函数调用的表达式的值。一个函数可以有任意多条 return 语句。 9.5 函数的形参可以被视为在函数体的开头被定义（被以实参的值初始化）的局部变量。所有形参均为左值，且不能被在函数体中直接重定义（除非是在一个更小的嵌套的块中）。 例如，int f(int x) { int x; } 不合法，但 int f(int x) { { int x; } } 合法。 9.6 如果一个不是 main 的函数执行到了它的 }，且其返回值被 caller 所使用，则这是一个未定义行为。 对于感兴趣的同学：C 语言中规定只有使用了返回值才是未定义行为，而 C++ 中规定不管返回值有没有被使用，都是未定义行为。 我们没有支持 void 类型，但可以忽略返回值达到类似的效果。 “执行到了 }” 意味着执行时没有通过 return 返回，例如 int f(){if(0) return 0;}。 实现的时候，你可以直接让所有函数都默认返回 0，语义规范说 main 之外的函数没有 return 是未定义行为，未定义行为的意思就是你想怎么处理都可以，所以全部默认返回 0 当然也是可以的，而且更清晰简单。 "},"docs/step10/intro.html":{"url":"docs/step10/intro.html","title":"实验要求","keywords":"","body":"实验指导 step10：全局变量 step10 我们要支持的是全局变量，语法改动非常简单： program : (function | declaration)* 全局变量和局部变量不同，它不是分配在栈上，而是放在某个固定地址，写在汇编的 .bss 段或 .data 段里。 访问它也不能通过 fp 加偏移量，而是需要通过它的符号加载它的地址，通过它的地址访问它。 汇编课上应该讲过，实际中（包括 gcc 和 qemu）使用的可执行文件的格式是 ELF（Executable and Linking Format）。 .text 是其中存放代码的段（section），.bss 和 .data 都是其中存放数据的段，前者零初始化后者须指定初始值。 对有兴趣的同学： 全局变量地址不是被狭义上的编译器（compiler）确定的，也不是被汇编器（assembler）确定的，而是被链接器（linker）或加载器（loader）确定的。 简单的说，狭义上的编译器把源代码变成文本汇编，汇编器把文本汇编给编码到二进制代码，然后通过链接器变成可执行文件，运行时由加载器加载到内存中运行。 当然，广义上的编译器就囊括了这所有阶段。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 6 的实验报告需要放在 stage-6 这个 branch 下的 ./reports/stage-6.pdf。整个 stage 6 只需要提交一份报告，你不需要单独为 step 10 准备报告。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step10/example.html":{"url":"docs/step10/example.html","title":"通过例子学习","keywords":"","body":"step10 实验指导 本实验指导使用的例子为： int x = 2025; int main() { return x; } 词法语法分析 针对全局变量，我们需要新设计 AST 节点来表示它，只需修改根节点的孩子类型即可：原先表示整个 MiniDecaf 程序的根节点只能有函数类型的子节点，现在还可以允许变量声明作为子节点。 语义分析 本步骤引入全局变量，在引入全局变量之后，AST 根结点的直接子结点不只包括函数，还包括全局变量定义。全局变量符号存放在栈底的全局作用域符号表中。在遍历 AST 构建符号表的过程中，栈底的全局作用域符号表一直都存在，不会被弹出。 中间代码生成 经过 Step5 的学习，我们知道局部变量是存储在寄存器或栈中的，可以直接访问。然而，全局变量存储在特别的内存段中，不能直接访问。课程实验建议的加载全局变量方式为：首先加载全局变量符号的地址，然后根据地址来加载数据。因此，需要定义两个中间代码指令，完成全局变量值的加载： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 LOAD T1, offset 临时变量 T1 中存储地址，加载与该地址相差 offset 个偏移的内存地址中的数据 LOAD_SYMBOL symbol symbol 为字符串，加载 symbol 符号所代表的地址 有了上述两条指令，可以将测试用例翻译如下： main: _T0 = LOAD_SYMBOL x _T1 = LOAD _T0, 0 return T1 需要说明的是，你也可以把两条指令合并为一条指令，直接加载全局变量的值，但分为两条指令的方式可扩展性更好些。 请注意，翻译所得的 TAC 代码中没有为全局变量赋予初始值（2025）。可以将变量的初始值存放在变量符号对应的符号表里，在后端代码生成时通过读取符号表得到初值。此处给出的只是一种参考实现，大家也可以将全局变量的定义显式翻译为 TAC 代码，这样可以使中端与后端完全解耦。 目标代码生成 Step10 中目标代码生成的主要任务有：翻译中间代码，将全局变量放到特定的数据段中。 翻译中间代码 实际上，我们提供的中间代码设计和 RISC-V 汇编的思想是一致的，RISC-V 汇编中有对应 LOAD 和 LOAD_SYMBOL 的指令，我们直接给出翻译结果： main： la t0, x # _T0 = LOAD_SYMBOL x lw t1, 0(t0) # _T1 = LOAD _T0, 0 mv a0, t1 ret 将全局变量放到特定的数据段中 到目前为止，翻译中间代码的方式是有问题的，问题在于，需要加载的 x 变量符号究竟存在哪里，如果所生成的汇编程序不给出 x 的定义，程序是有bug的。实际上，RISC-V 提供了一系列的汇编指令，用以声明全局变量 x 所对应的数据段。 下面给出 RISC-V 用以全局变量声明的汇编指令，其他全局变量的声明只需修改变量名称和初始值即可： .data .globl x x: .word 2025 上例中，.data 表示输出到 data 数据段；.globl x 声明 x 为全局符号；.word 后是一个 4 字节整数，是 x 符号对应的初始值。 按照汇编约定，data 段中存放已初始化的全局变量，未初始化的全局变量则存放在 bss 段中。举例而言，下面的示例将未初始化的全局变量 x 存放到 bss 段中。其中，.space 表示预留一块连续的内存，4 表示存储空间大小为 4 字节。 .bss .globl x x: .space 4 思考题 写出 la v0, a 这一 RiscV 伪指令可能会被转换成哪些 RiscV 指令的组合（说出两种可能即可）。 参考的 RiscV 指令链接：https://github.com/TheThirdOne/rars/wiki/Supported-Instructions "},"docs/step10/spec.html":{"url":"docs/step10/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step10 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' ( compound_statement | ; ) type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step10 语义规范 10.1 对于全局变量的初始化，我们仅对初始化表达式是整数字面量的情况做要求（例如 2123），对初始化表达式是非字面量的情况不做任何要求（例如 a 或 f() 或 2+3）。 C 其实也支持非字面量的编译期常量，例如 int a=1+3;。编译器可以计算出 1+3==4 然后让它等价于 int a=4;。 但为了实现简便，我们就不要求支持这点。 C 不允许 int a=f(); 因为 f() 不是编译器常量； 而 C++ 甚至可以支持 int a=f();，其大致实现为 int a=0; 然后在 main 之前执行的初始化函数中 a=f();。 10.2 我们对全局变量的重复声明不做任何要求或限定；但全局变量不能被重复定义，即不能有同名的被初始化的全局变量。 int a; int a=2; int a; int main(){ return a;} 是合法的 C 代码，不过不是合法的 C++ 代码，也许 C++ 的处理方式更符合你的直觉。 为了简单，我们不要求这点。比如对于形如 int a; int a=2; 或 int a; int a; 的代码片段，你可以以任意方式处理。 10.3 如果一个全局变量没有被初始化，我们认为其拥有一个默认初始值 0。 "},"docs/step11/intro.html":{"url":"docs/step11/intro.html","title":"实验要求","keywords":"","body":"实验指导 step11：数组 step11 的目标是支持数组： 语法上没有太大改动， 数组的初始化： declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' 数组的下标操作 postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' step11 难度不大，但有了数组让我们能够写很多有意思的程序了，step11 之前甚至 MiniDecaf 连快速排序都写不了。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 6 的实验报告需要放在 stage-6 这个 branch 下的 ./reports/stage-6.pdf。整个 stage 6 只需要提交一份报告，你不需要单独为 step 11 准备报告。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step11/example.html":{"url":"docs/step11/example.html","title":"通过例子学习","keywords":"","body":"step11 实验指导 本实验指导使用的例子为： int x[10]; int main() { int y[10]; return 0; } 词法语法分析 针对数组，我们需要设计 AST 节点来表示它，给出的参考定义如下： 节点 成员 含义 IndexExpr 索引基底 base，索引下标 index 索引运算 语义分析 由于 step 11 里引入了数组，现在我们的变量类型不只是 int 型了，还包括 int 型数组。因此，为了保证所有表达式中变量的类型均合法，需要进行类型检查。 注意：引入数组后，左值不再一定是 identifier 了，还有可能是如 a[0][1] 这样的索引运算表达式，因此同学们可能需要仔细考虑一下如何处理赋值时对值类别的检查。 frontend/type/array.py 里实现了数组类型，同学们可以使用它完成实验，也可以自行对其进行修改。 有能力的同学可以考虑将原先 Namer 中类型检查的部分，以及 stage 5 需要增加的类型检查重构进 Typer 中，使实现更加模块化。 中间代码生成 数组和普通变量类似，可以分为局部数组和全局数组。 全局数组的处理与全局变量类似，由于是升级关卡，我们留给同学自行思考（和全局变量究竟有什么不同，是不是需要的内存空间更大？提示：1. 需要申请更大的 bss 段内存）。 针对局部数组，给出一种参考实现，实际上不只存在一种实现方法。实验文档给出一种参考实现方法，定义了一条中间代码指令 ALLOC 用于分配内存空间： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 ALLOC size 分配 size 字节的内存，并返回内存首地址 采用 ALLOC 指令，测试样例中的局部数组部分代码可以翻译为如下中间代码（忽略全局数组部分）： main: T0 = ALLOC 40 # 一个 int 类型为 4 个字节 T1 = 0 return T1 通过这种方式，我们实际上是把内存分配的锅甩给了目标代码生成，这大大提升了目标代码生成的自由度，属于合理分锅。 除了分配数组，我们还需要考虑如何访问数组元素。通过 ALLOC 指令我们得到了数组的首地址，那么任何一个数组元素的地址可以通过在首地址的基础上加上偏移量得到。于是，读取数组元素可以使用 Step10 中引入的 LOAD 指令来实现，我们还需要引入一条类似的 STORE 指令将值写入数组元素。 那么，如何将数组下标对应到偏移地址？对一维数组，下标的常数倍（int 型的大小为 4 个字节，倍数为4）即为偏移量。而对于高维数组，我们可以将其视为一个展开成一维的大数组。对于数组 a[d1][d2]...[dn]，访问元素 a[i1][i2]...[in] 可以等价于访问 a[i1d2d3...dn + i2d3...*dn + ... + in]。在将数组索引翻译成 TAC 时，同学们需要自行将数组下标转换成地址计算指令。这个步骤并不困难，但可能比较繁琐，同学们在实现时要注意细节，避免错误。 目标代码生成 同中间代码生成，全局数组自行思考实现。 对于局部数组的内存分配，推荐在栈上为局部数组分配所需的空间，实际上，Step5 栈帧中的局部变量区域，可以用于存储局部数组。因此，大家需要模仿新建栈帧的操作，对栈顶指针 sp 进行修改，在栈上开辟出一块连续内存，并将这块内存的首地址返回即可。后续如有对数组中元素的访问，基于首地址进行偏移操作即可。 思考题 C 语言规范规定，允许局部变量是可变长度的数组（Variable Length Array，VLA），在我们的实验中为了简化，选择不支持它。请你简要回答，如果我们决定支持一维的可变长度的数组(即允许类似 int n = 5; int a[n]; 这种，但仍然不允许类似 int n = ...; int m = ...; int a[n][m]; 这种)，而且要求数组仍然保存在栈上（即不允许用堆上的动态内存申请，如malloc等来实现它），应该在现有的实现基础上做出那些改动？ 提示：不能再像现在这样，在进入函数时统一给局部变量分配内存，在离开函数时统一释放内存。 你可以认为可变长度的数组的长度不大于0是未定义行为，不需要处理。 "},"docs/step11/spec.html":{"url":"docs/step11/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step11 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' ( compound_statement | ; ) type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step11 语义规范 11.1 一个数组类型描述了一组被连续分配在一段内存空间中的对象，所有对象都具有相同的类型（我们称之为元素类型）。数组类型包含两部分：元素类型，和数组的长度（即元素数量）。数组类型的表达式仅能参与下标运算。 11.2 我们仅要求支持固定长度的数组，即在数组的声明中，其长度是一个正整数字面量。 所以，我们不要求支持变长数组 int a[n]; 或不定长数组 int a[];。 11.3 对于下标运算 a[b]，要求 a 是一个数组类型，b 是一个整数类型，a[b] 是 a 中的第 b 个元素（从 0 开始计数）。 11.4 下标运算越界是未定义行为。 即便是类似 int a[4][5]; a[1][7] 这种，同样也是未定义行为。 "},"docs/step12/intro.html":{"url":"docs/step12/intro.html","title":"实验要求","keywords":"","body":"实验指导 step12：为数组添加更多支持 step12 的目标是支持数组的初始化和传参： 语法上没有太大改动， 数组的初始化： declaration : type Identifier ('[' Integer ']')+ ('=' '{' (Integer (',' Integer)*)? '}')? ';' 数组的传参： function : type Identifier '(' parameter_list ')' (compound_statement | ';') parameter_list : (type Identifier ('[' ']')?(('['Integer']')*)? (',' type Identifier ('[' ']')?(('['Integer']')*)?)*)? 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 6 的实验报告需要放在 stage-6 这个 branch 下的 ./reports/stage-6.pdf。整个 stage 6 只需要提交一份报告，你不需要单独为 step 12 准备报告。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step12/example.html":{"url":"docs/step12/example.html","title":"通过例子学习","keywords":"","body":"step12 实验指导 本实验指导使用的例子为： int func(int param[]){ param[0] = 1; return 0; } int main() { int arr[4] = {1,2}; func(arr); return arr[0] + arr[1] + arr[2]; } 词法语法分析 我们需要增加一个数组的初始化列表，可以直接修改上一节数组的AST结点增加一个数组用于记录初始化元素。 函数的参数列表需要加上数组类型。 语义分析 由于 step 12 里额外引入了数组传参和数组初始化，所以你需要修改语义分析，以支持数组传参。传参出现了一种特殊情况，即：函数参数数组的第一维可以为空。 int fun(int a[][12]){ a[0][1] = 1; return 0; } 中间代码生成 在C语言中，对于全局数组，如果没有初始化，那么其值全为0，而对于局部数组来说，如果没有初始化，其值是未定义的。 而初始化后数组的元素值是确定的，如果初始化时指定的的元素个数比数组大小少，剩下的元素都回被初始化为 0。例如： int arr[3]={1,2}; // 等价于 int arr[3]={1,2,0}; 当数组长度较长时，如果对每个位置产生一条赋值语句可能会让生成的汇编代码非常冗长。因此你可能需要内置一个 memset 这样的函数来实现数组的清零。由于gcc的汇编器通常自带一个memset函数，我们这里采用fill_n命名。 // fill_n 函数原型，三个参数分别是目标内存地址，设置的内容，长度（以数组元素个数为单位） int fill_n(int *dst, int res, int cnt); 因此，上述初始化可以等价地转化为： int arr[3]; fill_n(arr, 0, 3); a[0] = 1; a[1] = 2; 目标代码生成 数组传参相对于初始化是简单的，回想函数一节的传参方式，自行实现。 思考题 作为函数参数的数组类型第一维可以为空。事实上，在 C/C++ 中即使标明了第一维的大小，类型检查依然会当作第一维是空的情况处理。如何理解这一设计？ 总结 恭喜你实现了 MiniDecaf 语言的所有特性。回过头看，我们从常量表达式开始，逐步为编译器增加变量、作用域等特性，又引入控制逻辑，最后实现全局变量和数组，编译器逐渐变得功能齐全。编译器每一个新的特性都带来了新的挑战，而你通过自己的智慧，逐步解决了这些挑战。顺利完成实验后，相信你对编译器也有了自己独特的理解。 "},"docs/step12/spec.html":{"url":"docs/step12/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step12 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' ( compound_statement | ; ) type : 'int' parameter_list : (type Identifier ('[' ']')?(('['Integer']')*)? (',' type Identifier ('[' ']')?(('['Integer']')*)?)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' | type Identifier ('[' Integer ']')+ ('=' '{' (Integer (',' Integer)*)? '}')? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step12 语义规范 12.1 多维数组按照类似一维数组的初始化方法，不要求实现内部嵌套括号 int a[2][2] = {1, 2, 3, 4}; 会将数组变为 a[0][0] = 1; a[0][1] = 2; a[1][0] = 3; a[1][1] = 4; 12.2 数组传参是支持不定长度的 int fun(int a[]) 是被支持的，由于传参不需要申请完整的数组的空间，不会产生需要计算数组空间的问题 "},"docs/step13/readme.html":{"url":"docs/step13/readme.html","title":"选做二说明","keywords":"","body":"选做实验二说明 选做实验二是给希望继续深入了解编译器知识的同学设计的实验部分，这部分内容具有较大难度，请同学们依据自己的时间安排情况决定是否选做。由于我们的实验框架并非为实现这个Step设计，改动部分可能较大，请确保你对框架有完整的了解再开始实验。这部分以报告评分，没有额外的测试样例。 "},"docs/step13/intro.html":{"url":"docs/step13/intro.html","title":"实验要求","keywords":"","body":"实验指导 step13：寄存器分配算法改进 step13 的目标是实现论文 TOPLAS'1996: Iterated Register Coalescing 提出的寄存器分配算法，并以此代替 step5 中提到的当前代码框架中的分配算法。 语法上没有改动。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 7 的实验报告需要放在 stage-7 这个 branch 下的 ./reports/stage-7.pdf。整个 stage 7 只需要提交一份报告。 你需要： 改进你的编译器，支持上面提到的寄存器分配算法。 除了替换位于 backend/reg/bruteregalloc.py 的分配算法外，你可能还需要修改其他文件以适配算法的需求。如果你忘了这部分内容，可以看看 step 6 的数据流分析一节。 你需要为代码添加合理的注释以便批阅。 你需要设计新测例（见本节实验指导），用以检测新分配算法的优化效果。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 详细说明你的代码的运行逻辑 举例说明：对于某几个测例，你在本节实验之前的代码编译出什么？本节实验之后编译出什么？它是如何被优化的？ 对于本节实验的新测例，分别使用本节实验之前之后的代码进行编译，测量并统计运行时间。改进后的编译器编译出的代码的运行效率需要有显著提升，但效率提升的高低不会作为评分的考察点。 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step13/example.html":{"url":"docs/step13/example.html","title":"实验指导","keywords":"","body":"step13 实验指导 本节实验要求实现论文 TOPLAS'1996: Iterated Register Coalescing 提出的寄存器分配算法。推荐大家完整读一遍论文，并通过论文作者的讲解课件，（如果前面的链接失效了，可以打开这个链接）辅助理解。论文文末的附录有完整的伪代码，你可以在它的基础上完成本次实验。 下面简要介绍一些你可能需要的预备知识。 回顾：启发式寄存器分配算法 在step 6 的数据流分析一节中，提到了活跃变量的概念。即对于一个临时变量来说，如果它在某个执行点处具有的值会在这个执行点以后被用到，那么它在这个执行点处是活跃的。 而在step5 中提到了一个简单的启发式寄存器分配算法。在给一个变量分配寄存器时，它的大致思路如下： 首先检查是否存在空闲的寄存器，有则直接分配给当前变量。 否则，检查是否存在寄存器，使得它关联的临时变量在当前位置已经不是活跃变量了，如是则把它关联到当前变量。 否则，说明所有寄存器所关联的变量都是活跃的。此时随机选择某个寄存器，把它关联的临时变量存到栈帧上（这叫做溢出（spill）到内存），然后把它关联到当前变量。 基于图染色的寄存器分配算法 我们可以换一种角度去思考寄存器分配问题：两个变量在什么情况下不能被分配到同一个寄存器？当且仅当两个变量同时活跃时，它们不能被分到同一个寄存器。可以把这样的一对变量定义为相干的(interference)，或者说相互冲突的。 重用一下 step 6 中活跃变量的例子： TAC 代码 活跃变量集合 相干寄存器 _T0 = 4 {_T0} _T1 = 3 {_T0, _T1} (_T0,_T1) _T2 = _T0 * _T1 {_T0} _T3 = _T0 * _T0 {_T0, _T3} (_T0,_T3) _T2 = _T3 * _T3 {_T0, _T2, _T3} (_T0,_T2),(_T0, _T3),(_T2, _T3) _T2 = _T0 * _T2 {_T2, _T3} (_T2,_T3) _T1 = _T2 * _T3 {_T1} return _T1 {} 这时我们再提出一个问题：最少可以用多少个寄存器完成上面代码的寄存器分配？ 容易发现，至少需要3个寄存器。因为 _T0,_T2,_T3 相互冲突，需要各一个寄存器，而 _T1 可以跟 _T2 或者 _T3 共用寄存器。 这个思路相比代码框架中的启发式寄存器分配算法有以下好处： 尽量减少使用的寄存器个数，在函数调用或返回时需要保存或恢复尽量少的 callee save/caller save 寄存器，减少变量溢出到内存的次数。这一部分对运行效率的影响很大，因为访存通常比访问寄存器慢很多。 方便全局优化寄存器分配，减少基本块之间的 move 指令。 事实上，我们可以用图染色问题去描述“相互冲突的变量”： 图染色问题：有 n 个结点，m 条边，你需要给每个结点指定一个颜色，使得任意两个有边直接相连的结点的颜色不同。 寄存器分配问题：有 n 个变量，m 组冲突的变量。你需要给每个变量指定一个寄存器，使得任意两个冲突的变量的寄存器不同。 上面这两个问题描述是一一对应的。如图所示（暂时先忽略图中的虚线边），如果把每个字母看成一个变量，每种颜色看成一个寄存器，那么图中的染色方案就对应了一个寄存器分配方案。 如何找到所有冲突的变量 这里只提一个最简单的思路：看上面我们分析时列出的表格，先列举出每一步的活跃变量集合，然后两两连边。 如何解决寄存器分配对应的图染色问题 假定我们有 k 种颜色可用于染色（对应 k 个寄存器可用于存放变量），那么可以依照下面的顺序执行 寻找图中是否有连接了少于 k 条边的结点，如果有，把它记录下来然后从图中删除。重复这个步骤直到不存在少于 k 条边的结点。 如果图中已经没有结点，则进入步骤3；否则，此时图中所有点都连接了至少 k 条边。这时，选择一个点（可以随机选，但可以通过其他信息来优化你的选择），把它记录下来然后从图中删除。然后重复步骤1。 按删除的逆序恢复所有结点。 当恢复一个从步骤1删除的结点时，因为当前它连接了少于 k 条边，所以我们总能为它指定一个颜色，使之不和相邻的最多 k-1 个点的颜色冲突。 当恢复一个从步骤2删除的结点时，检查它连接的所有边。如果我们足够幸运，与它相邻的所有点没有用完所有 k 种颜色，那么我们可以为这个点指定一个不冲突的颜色。否则，为它选择一个颜色，这意味着它和另一个变量被分配到同一个寄存器里。别担心，这不会导致算法失败，只是会使得这个变量在使用时需要从栈帧保存与恢复，对应启发式寄存器分配算法中溢出（spill）到内存的情况。 将每种颜色对应到寄存器上，生成后端代码。 基于复制指令的寄存器合并 在图染色的基础上有一种合并寄存器的进阶方法：合并通过复制指令(copy instructions)（其实就是赋值）传值的寄存器。 例如下面的代码 int f() { int a = 1; int b = a; int c = a + 2; int d = b + 3; return a + b + c + d; } 用上面提过的活跃变量分析可以算出，在 c = a + 2 执行时 a 和 b 都是活跃变量。但观察代码可以发现 a b 事实上存的是同样的值，只需要用同一个寄存器存就行。这篇论文使用了这个优化，并改进了前人的类似优化方案。 这样我们可以在图染色问题中把仅因复制（其实就是赋值）指令相互冲突的一对点之间的连边标记成虚线，表示如果它们最终染同一种颜色，就可以删去这条边然后合并这两个点。这有助于把上述图染色算法中从步骤2删去的点挪到步骤1删去，避免溢出到内存的情况。 可以直接合并这两个点吗？ 可以，但可能会导致产生出连接许多边的结点，反而使得后续染色困难，不得不溢出到内存。这实际上是更早的 Chaitin 的解决方案。 可以在保证合并后边数 的情况下合并这两个点吗？ 可以，但这样合并的点数比较少，优化效果差。这实际上是更早的 Briggs 的解决方案。 可以不合并但强制这两个点同色吗？ 不可以。如下图所示，j，b因复制指令冲突，j,f因其他指令冲突，但b,f之间没有冲突，所以涂色算法中有可能会把 b,f涂成相同颜色。这样就会导致 j 的颜色和 b 相同，从而意外地和 f 相同，导致溢出到内存。 这篇实验要求实现的论文的解决方案 把图中当前所有结点中，连接了至少 k 条边的结点标记为 significant-degree 的。看上述图染色算法流程，可以发现如果一个点不是 significant-degree 的，它会在步骤1被删除。 对于仅因复制指令相互冲突的一对点 (a,b)，可以如此检查它们是否可以合并： 统计与 a 或者 b有边相连的所有结点中有多少个 significant-degree 点。如果有 个，说明最多有 k-1 个结点不会在在步骤1被删除，因此如果 a b 合并，这个合并后的点也会在步骤1被删除。在步骤1被删除就意味着合并后的 a 和 b 一定能找到一种不和周围任何一个点冲突的颜色，从而不会出现上图的情况。 如果不能合并，那么把 a 和 b 中间的虚线边改为实线，表示不再考虑二者合并的情况。 上面的说明只是简要介绍了算法的原理，请阅读论文 TOPLAS'1996: Iterated Register Coalescing 获取更详细的说明。别忘了论文末尾的附录有完整的伪代码实现。 如何比较新的寄存器分配算法有哪些提升 下面是两个例子，分别是有大量活跃变量和大量分支语句，助教以C的语法编写，不符合minidecaf语法，你可以设计类似的测试样例来说明新的寄存器分配算法的效果（不一定要按照下面的例子来，主要是你的测试样例能体现新算法相对于之前算法的效果）。你可以比较运行时间以及生成的汇编代码： int test_many_branches() { int a = 0, b = 1, c = 2, d = 3; int result = 0; for (int x = 0; x int test_many_live_variables() { int a = 1, b = 2, c = 3, d = 4, e = 5; int f = 6, g = 7, h = 8, i = 9, j = 10; int k = 11, l = 12, m = 13, n = 14, o = 15; int p = 16, q = 17, r = 18, s = 19, t = 20; int result = 0; for (int x = 0; x "},"REFERENCE.html":{"url":"REFERENCE.html","title":"参考资料","keywords":"","body":"参考资料 Writing a C Compiler: by Nora Sandler An Incremental Approach to Compiler Construction : by Abdulaziz Ghuloum Monkey: The programming language that lives in books C17 标准草案 N2176（N2176 是 C17 标准正式发布前的最后一版草案，根据 C17 标准的编者之一 Jens Gustedt 的博文，其与 C17 标准相比只有表述上的差异） RISC-V 手册 RISC-V（非官方）汇编指令用法 "}}