{"./":{"url":"./","title":"实验简介","keywords":"","body":"MiniDecaf 编译实验 实验概述 MiniDecaf 1 是一个 C 的子集，去掉了include/define等预处理指令，多文件编译支持，以及结构体/指针等语言特性。 本学期的编译实验要求同学们通过多次“思考-实现-重新设计”的过程，一步步实现从简单到复杂的 MiniDecaf 语言的完整编译器，能够把 MiniDecaf 代码编译到 RISC-V 汇编代码。进而深入理解编译原理和相关概念，同时具备基本的编译技术开发能力，能够解决编译技术问题。MiniDecaf 编译实验分为多个 stage，每个 stage 包含多个 step，共包含 11 个 step。每个 step 大家都会完成一个可以运行的编译器，把不同的 MiniDecaf 程序代码编译成 RISC-V 汇编代码，可以在 QEMU/SPIKE 硬件模拟器上执行。随着实验内容一步步推进，MiniDecaf 语言将从简单变得复杂。每个步骤都会增加部分语言特性，以及支持相关语言特性的编译器结构或程序（如符号表、数据流分析方法、寄存器分配方法等）。下面是采用 MiniDecaf 语言实现的快速排序程序，与 C 语言相同。为了简化实现，MiniDecaf 不支持以数组作为函数参数，因此快速排序的数组以全局数组的形式给出： int a[1000]; int qsort(int l, int r) { int i = l; int j = r; int p = a[(l+r)/2]; while (i p) j = j - 1; if (i > j) break; int u = a[i]; a[i] = a[j]; a[j] = u; i = i + 1; j = j - 1; } if (i l) qsort(l, j); return 0; } 2021 年秋季学期基本沿用了 2020 年秋季学期《编译原理》课程的语法规范，为降低实验难度，进一步去掉了指针等语言特性。和 2020 年秋季学期课程实验所不同的是，为了贴合课程教学内容，提升训练效果，课程组设计了比较完善的编译器框架，包括词法分析、语法分析、语义分析、中间代码生成、数据流分析、寄存器分配、目标平台汇编代码生成等步骤，并采用 C++ 与 Python 两种语言实现。每个 step 同学们都会面对一个完整的编译器流程，但不必担心，实验开始的几个 step 涉及的编译器框架知识都比较初级，随着课程实验的深入，将会循序渐进地引入各个编译器功能模块，并通过文档对相关技术进行分析介绍，便于同学们实现相关编译功能模块。 实验起点和基本要求 本次实验一共设置 12 个步骤（其中 step0 为环境配置，主要是 RISC-V 工具链和硬件模拟器的的安装与使用，以及学会使用助教提供的自动测试脚本）。后续的 step1-11 我们将由易到难完成 MiniDecaf 语言的所有特性，由于编译器的边界情况很多，因此你只需通过我们提供的正例与负例即可。 我们以 stage 组织实验，各个 stage 组织如下： 第一个编译器（step0-step1）。我们给的实验框架可以通过所有测试用例，你需要做的事情为跟着文档阅读学习实验框架代码。请各位同学注意，stage0 尤为重要，掌握好实验框架是高质量和高效率完成后续实验的保证。 常量表达式（step2-step4）。在这个 stage 中你将实现常量操作（加减乘除模等）。 变量和语句（step5-step6）。在这个 stage 中你将第一次支持变量声明与赋值，以及条件跳转语句。 块语句和循环（step7-step8）。在这个 stage 中你将支持块语句，所谓块语句，就是多个语句组成一个块，每个块都是一个作用域。作为一种特殊的块语句，你也将实现循环操作。 全局变量和函数（step9-step10）。在这个 stage 中你将支持声明全局变量，并且支持函数的声明和调用。 数组（step11）。在这个 stage 中，你将支持数组，包括全局数组和局部数组。 同时，为了帮助大家通过实验学习语法分析，我们单独设置了一个手工自顶向下语法分析的小实验，需要大家手动实现一个支持 step1 - step6 语法规范的手工 parser。 设置这个实验的目的是为了帮助大家通过实验学习了解语法分析，parser generator（如 Bison）掩盖了很多语法分析的实现细节。 其中，stage0 为环境配置和框架学习，无需进行编程，不计入成绩。 stage1 - stage3 和手工语法分析器为 4 个基础关卡，你需要通过它们以拿到一定的分数（40%，每个关卡 10%）。 stage4 - stage5 为升级关卡，如果你学有余力，完成它们可以减少期末考试在总评中所占的比重（完成一个关卡，替代占总评 10% 的期末考试成绩）。 我们以 step 组织文档，每个 step 的文档都将以如下形式组织：首先我们会介绍当前 step 需要用到的知识点，其次我们会以一个当前 step 具有代表性的例子介绍它的整个编译流程。在之前 step 中已经介绍的知识点，我们会略过，新的知识点和技术会被详细介绍。 在 2021 年秋季学期，我们通过问答墙来集中解决大家在环境配置及完成实验中遇到问题。如果你遇到了任何问题，都可以在问答墙中检索；如果尚未有其他人提问，也欢迎提问，助教会尽快回复的。 实验提交 大家在网络学堂提交 git.tsinghua.edu.cn 的帐号名后，助教会给每个人建立一个私有的仓库，URL 为 https://git.tsinghua.edu.cn/compiler-21/minidecaf-你的学号 ，将作业提交到那个仓库即可。 每个 stage 会对应于一个 branch，当切换到一个新的 branch 上实现时，你可以用 git merge 来合并前一个 branch 所作的修改。 本学期我们使用清华大学代码托管服务（git.tsinghua）的 CI（持续集成）来测试大家的代码实现及提交实验报告。 .gitlab-ci.yml 中描述了如何运行 CI，你不允许修改此文件； prepare.sh 是在测试前会运行的准备脚本，包括安装所需的依赖（python）及编译（c++），如果你想添加新的依赖或者修改编译流程，请修改此文件。 在 CI 中会检查是否通过所有测例及是否有提交报告，只有通过所有测例且提交报告，才会被视为通过 CI。 我们只接受 pdf 格式的实验报告，其提交方式是放在仓库的 ./reports/.pdf，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 ./reports/stage-1.pdf。 实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 评分标准 对于每个阶段（stage）： 80% 的成绩是自动化测试的结果，你可以直接在 git.tsinghua 的 CI 测试中看到。 20% 的成绩是实验报告，其中对实验内容的描述占 10%，对思考题的回答占 10%。 在每阶段截止提交以后，我们一般会在一月内在网络学堂上公布成绩。 如果你认为成绩有问题，请及时与助教联系（关于实验成绩的疑问最晚请在期末考试以前提出，考试以后不能再更改实验成绩）。 补交政策 假设 a 日 23:59 是某个 stage 在网络学堂上的截止时间； 补交时间是这个 stage 的 branch 最后一次触发 CI 的时间； a + k (k a + 14 日 23:59 后不接受补交，此 stage 得 0 分。 学术规范 由于实验有一定难度，同学之间相互学习和指导是提倡的。 对于其他同学的代码（包括实验报告中思考题的回答），可以参考，但禁止直接拷贝。 如有代码交给其他同学参考，必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 请所有同学不要将自己的代码托管至任何公开的仓库上（如 GitHub），托管至私有仓库的请不要给其他同学任何访问权限。 我们将会对所有同学的代码作相似度检查，如发现有代码雷同的情形，拷贝者和被拷贝者将会得到同样的处罚，除非被拷贝的同学提交时已做过声明。 代码雷同情节严重的，课程组有权上报至院系和学校，并按照相关规定严肃处理。 备注 1. 关于名字由来，由于往年的实验叫 Decaf，我们在新的且更简单的语言规范下复用了 Decaf 的编译器框架，所以今年的实验就叫 MiniDecaf 了。 ↩ "},"docs/step0/errate.html":{"url":"docs/step0/errate.html","title":"勘误表","keywords":"","body":"勘误表 在这里我们会列出与实验相关的勘误，它会和问答墙上的勘误部分保持一致。同学们遇到问题时，请先在勘误表中查找查看是否已有解答。   Q：Python 框架无法正确输出三地址码？ A：非常抱歉，框架中输出时有一个小错误。在 main.py 中，输出三地址码时，请使用 prog.printTo() 语句；此外，想要输出带有缩进格式的抽象语法树，请使用如下语句： printer = TreePrinter(indentLen=) printer.work(prog)   Q： Python框架 step7 中，由 multi_nesting.c 生成的以下中间代码无法成功生成目标代码。 经过使用 print 法调试，发现是 _T1 所对应的寄存器在 return _T1 前就被释放了，后端会尝试到栈中寻找 _T1 并且不会找到，出现报错： utils.error.IllegalArgumentException: error: encounter a non-returned basic block 请问是后端实现上有问题，还是这一部分本来就需要我们自己修改呢？ A：Python 框架的后端除了要修改指令选择部分之外，还需要修改基本块 CFG，可以参见 BruteRegAlloc 的注释里给出的提示。   Q：我怎样才能知道我的提交通过了所有测试用例？ A：在 2021.10.5 更新评测脚本之后，现在通过 CI 结果可以直接判断是否通过了本阶段测例（不过你需要确保你的提交在对应的 branch 上，如 stage1 对应 stage-1 分支）。本地测试不受此次更新影响，因此更新本地的测试仓库 submodule 不是必须的。   Q：实验指导书中step4的目标代码生成部分，给出的IR对应汇编指令不正确，修改了原有寄存器的值？ A：原先的汇编指令确实有问题，我们已经修正。 "},"docs/step0/riscv_env.html":{"url":"docs/step0/riscv_env.html","title":"RISC-V 环境配置","keywords":"","body":"RISC-V 环境配置 必做：RISC-V 的 gcc 和 qemu 我们的编译器只生成 RISC-V 汇编，然后再使用 gcc 把 RISC-V 汇编变成 RISC-V 可执行文件，最后用 qemu/spike 等模拟器来运行 RISC-V 可执行文件。 注意这里的 gcc 和常说的 gcc 不一样。 常说的 gcc 运行在我们的 x86 机器上、把 C 编译到 x86 可执行文件； 而这里的 gcc 虽然也运行在我们的 x86 机器上，却要编译到 RISC-V 可执行文件。 这种“gcc 跑在 x86 却编译出 RISC-V 代码”的操作被称为交叉编译（cross compilation）。 因此我们不能直接使用有些系统自带的 gcc，这种 gcc 生成的可执行程序只能在你本机（x86）上运行。 我们需要下载安装 riscv64-unknown-elf-gcc，用来生成 RISC-V 可执行程序。 建议各位同学使用我们提供的 RISC-V 工具链，由 SiFive 预编译的较新版本的工具链对 32 位的支持存在问题。 我们提供了预编译的 riscv64-unknown-elf-gcc 和 qemu/spike 模拟器，不过只能在 Linux/Mac 下运行（qemu 对应 Linux，spike 对应 Mac），Windows 的同学可以使用 WSL，或者运行一个虚拟机。 命令行基础操作我们就不赘述了，大家可以自己在网上查找资料。 下面是环境配置指南，请阅读自己的系统的那一小节。 你的编译器 gcc qemu/spike MiniDecaf 源文件 ------------> RISC-V 汇编 -----> 可执行文件 --------> 输出 Windows 用户环境配置指南 下面描述了 WSL 的一种参考方法。 你还可以开一个 Linux 虚拟机，使用 Virtualbox 或 VMWare 等，然后参考下面 Linux 配置。 Win10 设置 参考 https://blog.csdn.net/daybreak222/article/details/87968078 ，设置“开发者模式”以及“启用子系统功能”。 打开Microsoft Store，搜索Ubuntu，选择ubuntu20.04. 按照下面的 Linux 用户环境配置指南安装 riscv 工具链。 Ubuntu 用户环境配置指南 建议使用 Ubuntu 20.04 及更高的版本，你可以直接使用 apt 来安装用户态的 qemu，即 apt install qemu-user。 如果使用的是低版本的 WSL，通过 Windows 应用商店可以很容易地安装 Ubuntu 20.04 LTS; 如果在机器上直接安装了较低版本的 Ubuntu, 可以参考这个教程进行升级，升级时注意备份。 如果出于某些原因必须使用低版本的 Ubuntu，你需要自己编译出可用的用户态 QEMU。 git clone https://mirrors.tuna.tsinghua.edu.cn/git/qemu.git cd qemu && ./configure --prefix=/usr/local --target-list=riscv32-linux-user make make install qemu-riscv32 --version # 检查是否安装成功 从这里下载预编译好的 RISC-V 工具链并解压。 安装工具链 cp riscv64-unknown-elf-gcc-10.1.0-2020.08.2-x86_64-linux-ubuntu14/* /usr/ -r 在第 2. 步，你可以选择不安装到系统目录下。相应的，你需要设置环境变量： 首先把文件夹riscv64-unknown-elf-gcc-10.1.0-2020.08.2-x86_64-linux-ubuntu14/改名为 riscv-prebuilt（这一步实际不是必须的，主要为缩短文件夹名字的长度），然后修改~/.bashrc 文件, 把export PATH=$PATH:/path/to/riscv-prebuilt/bin加入到.bashrc文件的末尾。注意，此处的/path/to 需要替换解压文件夹所在目录。每次修改.bashrc文件后，都需要执行命令source ~/.bashrc使修改生效。 （如果你不用系统自带的 bash 而是用 zsh 之类的 shell，那加到 ~/.zshrc 等 shell 配置文件里） macOS 用户环境配置指南 从这里下载预编译好的 RISC-V 工具链并解压到你喜欢的目录。 由于 macOS 不支持 QEMU 的用户态模式，我们使用 Spike 模拟器和一个简易内核 riscv-pk 提供用户态程序的运行环境。你可以选择下面两种安装方法中的任意一种： 从这里下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，不过还需要通过 Homebrew 安装依赖 device tree compiler： $ brew install dtc 通过 Homebrew 安装 Spike（会自动安装 dtc）： $ brew tap riscv/riscv $ brew install riscv-isa-sim 然后从这里上下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，只用里面的 pk。 Homebrew 也提供了 riscv-pk，不过那是 64 位的，而我们需要 32 位的，请使用我们预编译的 riscv-pk 或自行编译。 请注意我们提供的预编译 pk 是 x86 版本，如果你是其他平台（如M1 Mac），可以尝试自行根据 pk 的源码进行编译，附 Github 仓库链接。 （可选）设置环境变量，方法与 Linux 一样，见上一节。如果不设置每次使用 gcc 和 spike 时都要输入完整路径。不过对于 pk 设置环境变量不管用，要么把它放到系统目录 /usr/local/bin/pk，要么每次都用完整路径。 测试你 GCC 和 Spike 是否成功安装，详见RISC-V 的工具链使用。 必做：测试你是否正确配置好了环境 创建 test.c 文件，其中写入如下内容 #include int main() { printf(\"Hello world!\\n\"); } 编译 test.c 文件，gcc 应该输出一个可执行文件 a.out。但 a.out 是 RISC-V 可执行文件，所以我们的 X86 计算机无法运行。 $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 test.c $ ls a.out a.out $ ./a.out # 如果没有安装qemu模拟器，则会出现如下错误:\"bash: ./a.out: cannot execute binary file: Exec format error\" 后面RISC-V 的工具链使用总结了 gcc 和 qemu 在编译实验中可能需要的用法。 使用 qemu 执行 a.out，具体操作如下 Linux用户 $ qemu-riscv32 a.out Hello world! 注意：安装了qemu之后，直接运行 ./a.out 往往也可以调用qemu环境正确执行，并得到\"Hello world!\"输出。 Mac OS用户，假设你已经将spike加入环境变量，将pk加入系统目录 $ spike --isa=RV32G pk a.out bbl loader Hello world! 备注 1. 开头的 $ 表示接下来是一条命令，记得运行的时候去掉 $。例如，让你运行 $ echo x，那你最终敲到终端里的是 echo x（然后回车）。如果开头没有 $，那么这一行是上一条命令的输出（除非我们特别说明，这一行是你要输入的内容）。 ↩ "},"docs/step0/riscv.html":{"url":"docs/step0/riscv.html","title":"RISC-V 的工具链使用","keywords":"","body":"RISC-V 相关信息 RISC-V 是一个很像 MIPS 的 RISC 指令集架构，编译实验要求你的编译器把 MiniDecaf 程序编译到 RISC-V 汇编。 指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"。 另外这里也有（非官方的）指令用法说明。 不过事实上，很多时候看 gcc 输出的汇编比看什么文档都有用。 RISC-V 工具使用 我们提供预先编译好的 RISC-V 工具，在环境配置中已经叙述了安装和使用方法。 下面汇总一下。 注意，我们虽然是用的工具前缀是 riscv64， 但我们加上参数 -march=rv32im -mabi=ilp32 以后就能编译到 32 位汇编 1。 使用时记得加这个参数，否则默认编译到 64 位汇编。 我们假设你已经正确设置好了环境变量，否则运行 riscv64-unknown-elf-gcc 或 qemu-riscv32 或 spike 时请用完整路径。 gcc 编译 input.c 到汇编 input.s，最高优化等级（否则输出的汇编会很冗长） # input.c 的内容 $ cat input.c int main(){return 233;} # 编译到 input.s $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c # gcc 的编译结果 $ cat input.s .file \"input.c\" .option nopic .attribute arch, \"rv32i2p0_m2p0\" .attribute unaligned_access, 0 .attribute stack_align, 16 .text .section .text.startup,\"ax\",@progbits .align 2 .globl main .type main, @function main: li a0,233 ret .size main, .-main .ident \"GCC: (SiFive GCC 8.3.0-2020.04.0) 8.3.0\" gcc 编译 input.s 到可执行文件 a.out # input.s 的内容，就是上面汇编输出的简化版本 $ cat input.s .text .globl main main: li a0,233 ret # 编译到 a.out $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 input.s # 输出结果，能看到是 32 位的 RISC-V 可执行文件 $ file a.out a.out: ELF 32-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped 【Linux 用户】qemu 运行 a.out，获取返回码 # 运行 a.out $ qemu-riscv32 a.out # $? 是 qemu 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 【macOS 用户】Spike 模拟器运行 a.out，获取返回码 # 运行 a.out # /usr/local/bin/pk 替换为你自己的 pk 路径 $ spike --isa=RV32G /usr/local/bin/pk a.out bbl loader # $? 是 spike 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 1. 这里的 rv32im 表示使用 RV32I 基本指令集，并包含 M 扩展（乘除法）。本实验中我们不需要其他扩展。 ↩ "},"docs/step0/env.html":{"url":"docs/step0/env.html","title":"实验框架环境配置","keywords":"","body":"实验框架环境配置 C++ 实验框架环境配置 关于操作系统，助教推荐使用 Linux 环境（如 Ubuntu，Debain 或 Windows 下的 WSL 等），当然你也可以在类 Unix 系统环境（Mac OS）中进行开发。助教不推荐直接在 Window 中搭建开发环境。对于 C++ 实验框架，你需要安装或保证如下软件满足我们的要求： Flex Flex 是一个自动生成词法分析器的工具，它生成的词法分析器可以和 Bison 生成的语法分析器配合使用。我们推荐从 Github 下载安装最新版本(在 2021.9.1, 最新版本是 2.6.4,不推荐使用低于 2.6 的版本)。 在 Ubuntu 下，apt-get install flex 安装的 Flex 版本为 2.6，是可用的。 在 Mac OS 下，推荐使用 homebrew 进行安装，brew install flex 安装的 Flex 版本为 2.6，是可用的。 Bison Bison是一个自动生成语法分析器的工具,它生成的语法分析器可以和Flex生成的词法分析器配合使用。 在 Ubuntu 下，我们推荐从官网下载安装最新版本（在2021.9.1, 最新版本是3.7.6，不推荐使用低于3.7的版本,如 Ubuntu apt-get install 安装的3.0.4版本是不可用的）。下载解压 tar.gz 文件后， 在路径下执行./configure && make && make install, 就应该能正确安装。如果发生失败，就尝试sudo ./configure sudo make, sudo make install, 然后bison --version检查一下版本是否为3.7.6就可以了。 在 Mac OS 下，推荐使用 homebrew 进行安装，brew install bison 安装的 Bison 版本为 3.7.6，是可用的。 如果你是 Mac OS 用户，需要注意的是，系统可能已经安装了低版本的 flex 与 bison，安装的新版本工具会被覆盖，需要通过以下命令确认一下二者的版本： $ flex --version $ bison --version 如果版本较低，需要将新安装的工具路径加入环境变量，关于路径，在助教的电脑上是： Flex: /usr/local/Cellar/flex/2.6.4_2/bin Bison: /usr/local/Cellar/bison/3.7.6/bin Boehmgc C++ 语言的实验框架中，为了简化内存分配的处理，使用了一个第三方垃圾回收库，简单来说，使用这个垃圾回收库提供垃圾回收功能后，我们在框架里可以new了之后不用delete也不会出问题。 在 Ubuntu 下，通过 apt-get install libgc-dev 安装的 boehmgc 库是可用的。 在 Mac OS 下，通过 brew install libgc 安装的 boehmgc 库是可用的。 gcc 助教推荐的 gcc 大版本号为 8。当然，只要能通过编译且编译器程序能正确运行，其他版本也可以。 需要注意的是，如果你使用 Mac OS 进行开发，Mac 自带的 g++ 命令极有可能软链接到了 clang，我们的实验框架在某些版本的 clang 下无法编译通过，因此推荐你使用如下方法安装特定版本的 gcc。安装完成之后，你需要使用 gcc-8，g++-8 来调用特定版本的 gcc，g++，同时你需要修改我们提供的 Makefile 中的 CC 与 CXX 选项。 另外，由于你使用了自己安装的 g++-8 编译程序，你需要将 boehmgc 的路径加入 g++ 的环境变量： # 你需要将以下内容加入你终端的配置文件（zsh->.zshrc; bash->.bash_profile) export CPLUS_INCLUDE_PATH=\"$CPLUS_INCLUDE_PATH:/usr/local/include\" export LIBRARY_PATH=\"$LIBRARY_PATH:/usr/local/lib\" export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:/usr/local/lib # Mac OS $ brew install gcc@8 # Ubuntu $ sudo apt-get install gcc-8 需要说明的是，C++ 的环境配置较为复杂，教程可能无法覆盖到所有问题，欢迎随时联系助教。 python 实验框架环境配置 关于操作系统，类似 C++，但由于 python 的跨平台性，理论上也可以在 Windows 下进行开发。但不保证Windows和在线测试环境下程序行为的一致性。 python 3.9 框架本身在 python 3.9 下进行开发，使用了 python 3.9 的新特性并仅在这一版本下经过测试。请保证你所使用的 python 版本高于此版本。 Linux环境下安装Python 3.9可以尝试如下命令： > sudo add-apt-repository ppa:deadsnakes/ppa > sudo apt update > sudo apt install python3.9 修改~/.bashrc文件，在末尾加上alias python='/usr/bin/python3.9'。然后运行： > source ~/.bashrc 此外，也可以通过update-alternatives命令修改python版本使用的优先级，对所有服务器用户都有效，具体用法可参见这里。 框架里已经提供了需要的 python 包列表文件 requirements.txt，你可以直接通过 pip 命令安装下文提到的 python 依赖包 ply 和 argparse： $ pip install -r ./requirements.txt argparse 框架使用了 argparse 以处理命令行参数。官方文档中提供了它的教程。 ply ply是一个自动生成词法分析器和语法分析器的工具，其中ply.lex为词法分析相关的模块而ply.yacc为语法分析相关。我们提供了 ply 的文档。 助教推荐使用类似 Miniconda 的系统以最小化出现奇怪依赖问题的风险。助教推荐在项目中使用 type hints，如果你习惯在 vscode 中进行开发的话同时推荐使用 pylance 这一插件。 必做：测试你是否正确配置好了环境 C++ 实验框架 确定各工具的版本 # g++ $ g++-8 -v # Flex $ flex --version # Bison $ bison --version "},"docs/step0/testing.html":{"url":"docs/step0/testing.html","title":"运行实验框架","keywords":"","body":"推荐：运行实验框架 配好环境以后，我们强烈推荐你构建运行我们提供的实验框架初始代码。 接下来我们会用到 git。 git 的安装和使用会在软件工程课上讲述，同学们也自行查阅相关资料，也可以参考这里 。 按照本文档的前几节（RISCV 环境配置和实验框架环境配置）配置好实验环境。 助教已经为每位同学在 git.tsinghua.edu.cn 创建了一个仓库，其中 minidecaf 的测例仓库为其中的一个子模块，你可以通过以下指令来在克隆主仓库的同时克隆子模块 git clone --recursive 。 由于测例仓库会有所更新，在克隆之后你需要在主仓库目录下使用 git submodule update --remote --merge 来手动更新。 注意：由于子模块使用 ssh 链接，你需要将你的 ssh 公钥添加到你的 git.tsinghua 账号上，才能将其克隆下来。 如果你使用的是 C++ 语言的框架，你需要使用 make 来编译实验框架，你可以在下方仓库的 src/ 目录下手动 make，或者直接运行脚本 bash ./prepare.sh。 按照测例的 README 运行测试 step1，实验框架给出的初始代码可以通过 step1 的所有测例。 测试运行的 输出结果 大致如下。 $ STEP_UNTIL=1 ./check.sh gcc found qemu found parallel found OK testcases/step1/multi_digit.c OK testcases/step1/newlines.c ...... 其他测试点，太长省略 "},"docs/step1/arch.html":{"url":"docs/step1/arch.html","title":"MiniDecaf 编译器结构","keywords":"","body":"MiniDecaf 编译器结构 MiniDecaf 编译器大致划分为三个部分：前端、中端、后端。通过编译器前端，可以读入 MiniDecaf 源程序，然后通过词法分析和语法分析将源程序转化为一个抽象语法树（Abstract Syntax Tree, AST)，接下来通过扫描 AST 进行语义分析，检查是否存在语义错误；在编译器中端，通过扫描 AST 生成中间代码 —— 三地址码；在编译器后端中，将三地址码转换为 RISC-V 汇编代码。下面依次介绍上述编译步骤，以及对应框架代码的位置。 我们在这里针对每个步骤只是简要介绍，目的是给同学们一个大致的印象：编译器到底是由哪些部分组成的，这些部分又有什么作用。具体的技术点，我们将在用到的 step 作详细介绍。 词法分析和语法分析 此部分对应框架源码位置： C++ 框架：词法分析程序位于 src/frontend/scanner.l；语法分析程序位于 src/frontend/parser.y；语法树位于 src/ast/。 Python 框架：词法分析程序位于 frontend/lexer；语法分析程序位于 frontend/parser；语法树位于 frontend/ast。 编译器前端分为两个子任务，一是词法分析，二是语法分析。词法分析的功能是从左到右扫描 MiniDecaf 源程序，识别出程序源代码中的标识符、保留字、整数常量、算符、分界符等单词符号（即终结符），并把识别结果返回给语法分析器，以供语法分析器使用。语法分析是在词法分析的基础上针对所输入的终结符串建立语法树，并对不符合语法规则的 MiniDecaf 程序进行报错处理。一般而言，这一步所生成的语法树并非表示了所有语法细节的语法分析树，而是只表示其树形结构的抽象语法树（Abstract Syntax Tree, AST）。比如，对于下面这一段简单的MiniDecaf 代码： if (i) i = 1; 它对应的完整语法分析树可能长这样： if_stmt |- \"if\" |- \"(\" |- Identifier(\"i\") |- \")\" |- assign_stmt |- Identifier(\"i\") |- \"=\" |- Int(1) |- \";\" 其中双引号下的和大写字母开头的都为词法分析器产出的终结符。而对应的抽象语法树可能长这样： if_stmt |- (condition) Identifier(\"i\") |- (body) assign_stmt |- (lh) Identifier(\"i\") |- (rh) Int(1) AST省略掉了完整的语法分析树中不必要的细节，有利于简化树的结构与后续对树的处理。 词法分析和语法分析的最终结果是一棵跟所输入的 MiniDecaf 源程序相对应的语法树。本阶段的实验重点是掌握 LEX 和 YACC 的用法，了解编译器自动构造工具的特点，并且结合实验内容理解正规表达式、自动机、LALR(1) 分析等理论知识在实践中的应用。 语义分析 此部分对应框架源码位置： C++ 框架：符号表构建位于 src/translation/build_sym.cpp；类型检查位于 src/translation/type_check.cpp；符号表相关的数据结构位于src/symb；作用域相关数据结构位于 src/scope。 Python 框架：符号表构建位于 frontend/typecheck/namer.py；类型检查位于 frontend/typecheck/typer.py；符号表相关的数据结构位于frontend/symbol；作用域相关数据结构位于 frontend/scope。 语法分析树的建立可以说明所输入的 MiniDecaf 源程序在语法规范上是合法的，但是要进行有效的翻译，编译器还需要理解每个程序语句的含义。了解程序含义的过程称为语义分析。 可以把语义分析过程分为两个部分：分析符号含义和检查语义正确性。分析符号含义是指对于表达式中所出现的符号，找出该符号所代表的内容，这个工作主要通过检索符号表来实现。检查语义正确性指的是检查每条语句是否合法，比如检查每个表达式的操作数是否符合要求，每个表达式是否为语言规范中所规定的合法的表达式，使用的变量是否都经过定义等。程序代码通过了词法和语法分析，其语义未必正确，因此未必是合法的语句。不合法的语句具体含义在语言规范中没有规定，从而使得编译器无法确定这些语句的确切含义，所以检查语义的正确性是很有必要的。如果一个程序成功通过语义分析，则说明这个程序的含义对于编译器来说是明确的，翻译工作可以继续进行。 具体来说，在这一阶段中，我们需要对 AST 进行两遍扫描，分别完成以下的检查： 符号表构建：声明了哪些标识符，待编译程序使用的标识符对应于哪个位置的声明。 类型检查：各语句和表达式是否类型正确。 如果在语义分析阶段发现错误，那么整个编译过程在这一阶段结束后将终止，并报告编译错误。所有的语义错误都应该在这一阶段，且只能够在这一阶段报告。下面分别介绍符号表构建和类型检查的内容。 符号表构建 针对 MiniDecaf 程序中所有定义的标识符，包括函数名和变量名，我们统一用一种具有层次结构的符号表来维护。使用符号表的好处包括：(1) 在分析各语句和表达式时，若它们引用了某些标识符，我们可以在符号表中查询这些标识符是否有定义以及相关信息（如类型）；(2) 符号表的层次结构与作用域是一一对应的，便于检查出符号定义是否有冲突，以及确定不同作用域引用的标识符。 Step1-4 中只需要考虑常量的计算，直到 Step5 才需要考虑符号表构建。 类型检查 完成符号表构建后，我们就可以自顶向下地遍历 AST，对每个语句和表达式逐一进行类型检查，并在 AST 上进行类型标注。对于静态类型（statically-typed）语言，在语言设计之初，设计者都会考虑该语言支持表达哪些类型，并给出定型规则（typing rules）。 在已知定型规则的情况下编码实现类型检查算法并不困难——往往只要逐条将其翻译为代码即可。 事实上，由于 MiniDecaf 代码的基本类型只有整数类型（int），因此我们在类型检查时只需要考虑 int 和 int 数组两种类型。在支持数组（step11）之前，都基本不需要考虑类型检查。 中间代码生成 C++ 框架：三地址码定义位于 src/tac；中间代码生成位于 src/translation/translation.cpp。 Python 框架：三地址码定义位于 utils/tac；中间代码生成位于 frontend/tacgen/tacgen.py。 在对 AST 进行语义分析后，我们将在这一阶段把带有类型标注的 AST 翻译成适合后端处理的一种中间表示。中间表示（也称中间代码，intermediate representation / IR）是介于语法树和汇编代码之间的一种程序表示。 它不像语法树一样保留了那么多源程序的结构，也不至于像汇编一样底层。 由于源语言（MiniDecaf）和目标语言（RISC-V 汇编）一般存在较大的差别，因此直接把源语言翻译为目标语言中的合法程序通常是比较困难的。大多数编译器实现中所采取的做法，是首先把源语言的程序翻译成一种相对接近目标语言的中间表示形式，然后再从这种中间表示翻译成目标代码。中间表示（IR）的所带来的优势如下： 缩小调试范围，通过把 AST 到汇编的步骤一分为二。如果目标代码有误，通过检查 IR 是否正确就可以知道：是AST 到 IR 翻译有误，还是 IR 到汇编翻译有误。 将 AST 转换到汇编的过程分成两个步骤，每个步骤代码更精简，更易于调试。 通过 IR 可以适配不同指令集（RISC-V, x86, MIPS, ARM...）和源语言（MiniDecaf, C, Java...）。由于不同源语言的 AST 不同，直接从 AST 生成汇编的话，为了支持 N 个源语言和 M 个目标指令集，需要写 N * M 个目标代码生成模块。如果有了 IR，只需要写 N 个 IR 生成器和 M 个汇编生成器，只有 N + M 个模块。 接下来，将对我们所使用的中间代码 —— 三地址码 (TAC) 做简要介绍，后续的实验步骤中需要同学们添加恰当的三地址码指令来完成特定的功能。为了降低实验难度，给出部分参考实现，各位同学可以依据参考实现完成设计，也可以自行设计三地址码。 三地址码 三地址码（Three Address Code, TAC）看起来很像汇编，与汇编最大的区别在于 —— 汇编里面使用的是目标平台（如 risc-v, x86, mips）规定的物理寄存器，其数目有限；而 TAC 使用的是“伪寄存器”，我们称为临时变量，其数目不受限制，可以任意使用（这意味着直接将临时变量转化为寄存器可能会出现寄存器不够用的情况）。在后端生成汇编代码时，我们再考虑如何为临时变量分配物理寄存器的问题。 main: # main 函数入口标签 _T0 = 1 # 加载立即数 _T1 = _T0 # 临时变量赋值操作 _T2 = ADD _T0, _T1 # 加法操作 _T2 = _T0 + _T1 _T3 = NEG _T0 # 取负操作 _T3 = -_T0 return _T2 # 函数返回 以上给出了一份 TAC 示例程序。请注意 TAC 代码只是一种中间表示，并不需要像汇编语言那样有严格的语法。因此，同学们可以自由选择输出 TAC 代码的格式，只要方便自己调试即可。例如，你也可以将 _T2 = ADD _T0, _T1 输出成 _T2 = _T0 + _T1。 TAC 程序由标签和指令构成： 标签用来标记一段指令序列的起始位置。从底层实现的角度来看，每个标签本质上就是一个地址，且往往是某一段连续内存的起始地址。在我们的实验框架中，标签有两个作用：作为函数入口地址（如上例中的 main 函数入口），以及作为分支语句的跳转目标（TAC 指令不支持 MiniDecaf 语言中条件和循环控制流语句，而是将它们都翻译成更加底层的跳转语句）。 TAC 指令与汇编指令类似，每条 TAC 指令由操作码和操作数（最多3个）构成。 操作数可能会有：临时变量、常量、标签（可理解为常量地址）和全局变量（全局变量的处理比较特殊，由于 Step10 才需要考虑，届时再介绍其处理方法）。如上例所示，TAC 中的临时变量均用 \"_Tk\" 的形式表示（k表示变量的编号）。 TAC 程序是无类型的，或者说它仅支持一种类型：32位（4字节）整数。为了简化实验内容，MiniDecaf 只支持 int 类型和 int 数组类型，其值和地址都可以用一个32位整数存储，故 MiniDecaf 程序中的变/常量和 TAC 中的变/常量可以直接对应。 数组类型无法用临时变量直接表示，可以用一段连续内存的起始地址表示。其实现细节将在 Step11 详细讨论。 控制流、数据流分析和寄存器分配 C++ 框架：数据流图定义及优化在 src/tac/flow_graph.cpp 及 src/tac/dataflow.cpp 中；寄存器分配在 src/asm/riscv_md.cpp中 Python 框架：数据流图定义及优化在 backend/dataflow/ 中；寄存器分配在 backend/reg/ 中 控制流和数据流分析 一般来说，在三地址码的基础上是可以直接翻译为目标代码的，但是这样的直接翻译会导致所产生的代码的效率比较差，所以多数编译器都会进行一定的优化工作。为了进行更深入的优化，编译器需要了解程序语义的更多内容，例如一个变量的某个赋值在当前指令中是否有效、一个变量在当前指令以后是否还会被使用、当前运算指令的两个操作数是否都能够在编译的时候计算出来、循环体中某些代码是否能够提出到循环外面、循环次数是不是编译的时候已知的常数等等，这些语义分析和代码优化离不开控制流分析和数据流分析。 所谓控制流分析，是指分析程序的执行路径满足什么性质，包括基本块划分、流图构造、以及分析循环或其他控制区域（region）。而所谓数据流分析，是指分析各种数据对象在程序的执行路径中的状态关系，例如一个变量在某个语句以后是否还被用到等。依据数据流分析的结果，可以进行后续的中间代码优化以及寄存器分配等相关步骤。 关于数据流分析的细节，我们将在 step7 做详细介绍。 寄存器分配 所谓寄存器分配，是指为中间代码中的虚拟寄存器分配实际的物理寄存器。对中间代码来说，通常假设虚拟寄存器的数量是无限的，这导致我们在分配物理寄存器时无法简单的对虚拟寄存器做一一映射，需要有一个调度与分配算法来合理使用有限的物理寄存器。本实验框架中使用了一种暴力寄存器分配算法，具体细节将在 Step5 中详细说明，当然如果你感兴趣，你也可以基于我们的框架实现更高级的干涉图分配算法，具体不作要求。 目标平台汇编代码生成 C++ 框架：目标平台汇编代码生成在 src/asm 中。 Python 框架：目标平台汇编代码生成在 backend/asm.py | backend/asmemitter.py | backend/subroutineemitter.py | subroutineinfo.py 以及 backend/riscv/ 中。 通常我们认为的目标代码生成步骤包含寄存器分配、指令选择。寄存器分配是指为中间代码中的虚拟寄存器分配实际的物理寄存器，涉及物理寄存器的调度分配。指令选择是指选用合适的汇编指令来翻译中间代码指令，如中间代码生成章节提供的例子中，使用 addi 汇编指令来翻译 ADD 中间代码指令。需要特别提出的是，RISC-V 指令集的设计思路是尽可能简洁，因此有些指令并没有直接提供，需要用多条简单指令代替。如相等、大于等于、逻辑与、逻辑或等等，同学们实现时需要特别注意。 课程实验的目标平台为 RISC-V，RISC-V 是一个与 MIPS 类似的 RISC 指令集架构，编译实验要求所实现的编译器把 MiniDecaf 程序编译到 RISC-V 汇编代码。指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"，另外这里也有（非官方的）指令用法说明。下图给出了 RISC-V 的32个整数寄存器的相关说明，其中需要特别注意的寄存器有 ra（存放函数返回地址）、sp（存放当前栈顶地址）、fp（存放当前栈底地址）、a0&a1（存放函数返回值）。为了简单起见，我们简化了 RISC-V 的调用约定，由调用者（caller）负责保存寄存器内容，因此，无需关心某个寄存器是 caller-saved 还是 callee-saved。 "},"docs/step1/provided.html":{"url":"docs/step1/provided.html","title":"已提供的语法特性","keywords":"","body":"已经提供的语法特性 为了方便同学们完成实验，我们提供的实验框架中已经完成了部分语言特性的实现。对于某些步骤，同学们可以参照已实现的特性完成剩余的部分。例如，根据提供的 while 循环实现，同学们可以参考着完成 do-while 和 for 循环的实现。 下面我们列出了所有框架中已经完成的特性： Step1 中我们提供了所有实现。 Step2 中我们提供了取负运算的实现。 Step3 中我们提供了加法运算的实现。 Step5 中我们提供了基础数据结构——符号表的实现。 Step6 中我们提供了 if 语句的实现。 Step7 中我们提供了基础数据结构——作用域栈的实现。 Step8 中我们提供了 while 循环以及 break 语句的实现。 此外，我们提供了 Step1-6 需要的语法树节点和中间代码指令，以及后端中的寄存器分配算法。 "},"docs/step1/example.html":{"url":"docs/step1/example.html","title":"通过例子学习","keywords":"","body":"通过例子学习，一个仅有 return 的主函数编译全流程： 本步骤主要涉及的语法为主函数和 return 语句，完成本步骤之后，你的编译器将支持将一个仅有 return 的主函数编译为 32 位 RISC-V 汇编代码，并通过 RISC-V 工具链生成可以在硬件模拟器上正确运行的程序。因为这是大家首次接触 MiniDecaf 编译实验框架，我们给大家的代码框架中已经包含所有 step1 的实现，大家可以直接运行通过 step1 的测试用例。并且，我们在每个步骤的文档中会详细梳理介绍在当前步骤中需要用到的知识点以及对应的代码片段和注释，如果我们认为当前步骤并不需要了解某部分知识点（如数据流分析、寄存器分配），我们会在后续的步骤中进行知识点的讲解。 下面我们将通过一个简单的 step1 测试用例，一起走过它的编译全流程： int main() { return 2021; } 请注意，这里给出的生成结果（抽象语法树、三地址码、汇编）只是一种参考的实现，同学们可以按照自己的方式实现，只要能够通过测试用例即可。但是，严格杜绝抄袭现象，如果代码查重过程中发现有抄袭现象，抄袭者与被抄袭者将被记为0分。 词法分析 & 语法分析 在词法分析 & 语法分析这一步中，我们需要将输入的程序字符流按照语法规范转化为后续步骤所需要的 AST，我们使用了 lex/yacc 库来实现这一点。yacc 是一个根据 EBNF 形式的语法规范生成相应 LALR parser 的工具，支持基于属性文法的语法制导的语义计算过程。你可以根据我们的框架中对 lex/yacc 的使用，结合我们的文档，来快速上手 lex/yacc，完成作业；也可以选择阅读一些较为详细的文档，来系统地进行 lex/yacc 的入门，但这不是必须的。 为了方便同学们理解框架，我们将同时在这一段中说明为了加入取负运算所需要的操作。在 C++ 框架中，我们使用的是 lex/yacc 的高级替代 flex/bison，其使用方法和 lex/yacc 极为相似。在 Python 框架中，我们使用的是 lex/yacc 的一个纯 python 实现，称为 python-lex-yacc（简称 ply），其使用方法与 lex/yacc 有一些差异。 C++ flex/bison 快速入门 Python-lex-yacc 快速入门 C++ 框架 Makefile 中调用了 flex 和 bison 来处理 parser.y 和 scanner.l。flex 和 bison 会将这两个文件中的语法/词法描述翻译为 C++ 实现。 概述 src/frontend/scanner.l 为词法描述。flex 生成的词法分析器，会将示例程序解析为这样的一串 Token： Int Identifier(\"main\") LParen RParen LBrace Return IntConst(2021) Comma RBrace 这个程序的具体语法树中用到的语法规则如下: Program -> Functions Functions -> Type Identifier LParen RParen LBrace Statements RBrace Statements -> ReturnStmt ReturnStmt -> Return IntConst(2021) Comma parser.y 生成的语法分析器，分析获得的抽象语法树为： Program |-FoDList |- FuncDefn |- (ret_type) Type INT |- (name) Identifier \"main\" |- (stmts) StmtList |- ReturnStmt |- Expr int_const 2021 框架中 scanner.l 和 parser.y 是配合使用的，简单来说，scanner.l 定义了词法规则，parser.y 定义了语法规则。bison 生成的语法分析器，会调用 flex 生成的 yylex() 函数，这个函数的作用为获取 token 流的下一个 token。 具体代码 让我们看看示例对应的 parser 代码： scanner.l 中生成一个 Token 的规则，形如: \"-\" { return yy::parser::make_MINUS(loc); } # 该规则将一个'-'字符，解析为parser中的MINUS token。 yy::parser::make_MINUS() 函数是在 parser.y 中声明 MINUS 这个 token 之后，yacc 自动生成的 token 构造函数。loc 是表示当前扫描位置的行列的全局变量。下面一段就是 parser.y 中声明 MINUS 这个 token 的位置。具体语义可参考 Bison 教程。 %define api.token.prefix {TOK_} %token //more tokens... MINUS \"-\" //more tokens... ; 具体语义可参考链接。 一元负号对应的语法树节点为 NegExpr，相关定义分散在 src/ast/ast.hpp，src/ast/ast.cpp，src/ast/ast_neg_expr.cpp，src/ast/visitor.hpp，src/define.hpp 中。注意 ast.hpp 中定义了节点的枚举类型 NodeType，ast.cpp 中定义了一个字符数组按顺序存储这些节点的名称，请保持和 NodeType 中的顺序一致。 // src/ast/ast.hpp class NegExpr : public Expr { public: //these member functions defined in src/ast/ast_neg_expr.cpp NegExpr(Expr *e, Location *l); virtual void accept(Visitor *); virtual void dumpTo(std::ostream &); public: Expr *e; }; 在 parser.y 中，要为一元负号编写对应的语法规则和动作。省略 Expr 对应的其他规则，形如： Expr : MINUS Expr %prec NEG { {% math %} = new ast::NegExpr($2, POS(@1));} ; 其中，$2 意味着右侧的 Expr 语法树节点，基于此，调用 ast::NegExpr 构造函数，获得新的 NegExpr，赋值给{% endmath %}，作为这一级语法分析返回的节点。%prec NEG 注明的是这条规则的优先级，和优先级定义中的 NEG 相同。 /* SUBSECTION 2.2: associativeness & precedences */ %nonassoc QUESTION %left OR %left AND %left EQU NEQ %left LEQ GEQ LT GT %left PLUS MINUS %left TIMES SLASH MOD %nonassoc LNOT NEG BNOT %nonassoc LBRACK DOT 这是 parser.y 中的优先级定义，自上而下优先级越来越高。%left, %nonassoc 标注了结合性。注意，非终结符也需要声明。如 parser.y 中 %nterm Expr 表示 Expr 非终结符对应的语法树节点是 mind::ast::Expr* 类型（的指针）。我们将非终结符都声明为语法树结点的指针类型。每条语法规则里对应的动作会构建一个新的语法树结点，像刚才看到的 NegExpr。之后，你可能需要自己增加 token 的定义、语法树节点的定义。 Python 框架 程序的入口点在 main.py，它通过调用 frontend.parser.parser（位于 frontend/parser/ply_parser.py）来完成语法分析的工作，而这一语法分析器会自动调用位于 frontend/lexer/ply_lexer.py 的词法分析器进行词法分析。语法的定义和语法分析器都位于 frontend/parser/ply_parser.py，而词法的定义位于 frontend/lexer/lex.py。AST 节点的定义位于 frontend/ast/tree.py 中。以下表示中的符号都出自于这几个文件。 当程序读入上述程序的字符流之后，它首先会被 lexer 处理，并被转化为如下形式的一个 Token 流： Int Identifier(\"main\") LParen RParen LBrace Return Integer(2021) Comma RBrace 并被 yacc 生成的 LALR(1) parser 转化为如下形式的 AST： Program |- (children[0]) Function |- (ret_t) TInt |- (ident) Identifier(\"main\") |- (body) Block |- (children[0]) Return |- (expr) IntLiteral(2021) 得到的这个 AST 也就是 main.py 中 step_parse 这一函数里 parser.parse(...) 的输出。 如果我们想把返回值从 2021 变成 -2021，则在这一步中你可能需要进行以下操作（实际上这些实现已经在框架里提供）： 在 frontend/ast/tree.py 里加入新的 AST 节点定义（以及相应的其它东西），可能长这样： class Unary(Expression): def __init__(self, op: Operator, operand: Expression): ... 并在 `frontend/ast/visitor.py` 中加入相应的分派函数。 它将在后续的 parser 语义计算中被用到。 在 frontend/lex/lex.py 里加入新的 lex token 定义: t_Minus = \"-\" 在 ply 的 lexer 中，定义的新 token 需要以 `t_`开头。更具体的解释见文件注释或[文档](https://www.dabeaz.com/ply/ply.html)。 在 frontend/parser/ply_parser.py 里加入新的 grammar rule，可能包含（不限于）以下的这些： def p_expression_precedence(p): # 定义的新语法规则名。可以随便起，但必须以 `p_` 开头以被 ply 识别。 \"\"\" expression : unary unary : primary \"\"\" # 以 [BNF](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form) 定义的新语法规则，以 docstring 的形式提供。 p[0] = p[1] # 这条语法规则相应的语义计算步骤，下标对应着产生式中的相应符号。 # 语法分析器直接产生的实际上是一棵语法分析树，而构建 AST 这一数据结构则通过相应语法制导的语义计算过程来完成。 def p_unary_expression(p): \"\"\" unary : Minus unary \"\"\" p[0] = tree.Unary(UnaryOp.Neg, p[2]) 更多的用法同样可参见[文档](https://www.dabeaz.com/ply/ply.html)。 这样就基本完成了词法 & 语法分析步骤里加入取负运算的所有步骤。后续步骤中可能需要在某些 visitor 中实现相应的检查、转化至 TAC 的逻辑。 另外需要留意的一点是，python 框架中解决运算符结合律、优先级和悬吊 else 问题的方法与 C++ 框架中略有不同：C++ 框架下使用了 yacc 的特性直接指定了相应语法规则的优先级和结合律，但在 python 框架中我们通过对相应语法规则进行变换来达到这一目的，这些变换方法（优先性级联、规定左结合/右结合、最近嵌套匹配）在学习 CFG 时应有涉及，此处不多赘述。 语义分析 在 step1 语义分析步骤中，我们要遍历 AST，检验是否存在如下的语义错误： main 函数是否存在。 return 语句是否有返回值。 返回值是否在 int 合法的范围内。 在实际操作中，我们遍历 AST 所用的方法就是的 Visitor 模式，通过 Visitor 模式，我们可以从抽象语法树的根结点开始，遍历整颗树的所有语法结点，并针对特定的语法结点作出相应的操作，如名称检查和类型检查等。在编译器中，这种基于 Visitor 的对语法树进行一次遍历，完成某种检查或优化的过程，称为遍（pass）。不难想到，一个现代编译器是由很多遍扫描组成的，如 gcc 根据优化等级不同会有数百个不等的 pass。下面，我们将指出，step1 中我们是如何实现符号表构建 pass 和类型检查 pass 的，选择不同语言的同学，可以选择去看相应的代码注释与实现细节。 Python 框架 frontend/typecheck/namer.py 和 typer.py 分别对应了符号表构建和类型检查这两次遍历。在框架中，Namer 和 Typer 都是继承 frontend/ast/visitor.py 中的 Visitor 类来通过 Visitor 模式遍历 AST 的。其实现细节参见代码。 C++ 框架 translation/build_sym.hpp 和 translation/type_check.hpp 及相应 cpp 文件分别对应了符号表构建和类型检查这两次遍历。在框架中，两者都是继承 ast/visitor.hpp 中的 Visitor 类来通过 Visitor 模式遍历 AST 的。在新增 AST 节点后，必须在两者中增加对应的 visitXXX 函数。其实现细节参见代码。 中间代码生成 在通过语义检查之后，编译器已经掌握了翻译源程序所需的信息（符号表、类型等），下一步要做的则是将抽象语法树翻译为便于移植和优化的中间代码，在本实验框架中就是三地址码。如何翻译抽象语法树？当然还是无所不能的 Visitor 模式，我们在中间代码生成步骤中再遍历一次语法树，对每个结点做对应的翻译处理。具体来说，在 step1 当中，我们只需要提取 return 语句返回的常量，为之分配一个临时变量，再生成相应的 TAC 返回指令即可。不难看出，本例对应的三地址码为： main: # main 函数入口标签 _T0 = 2021 # 为立即数2021分配一个临时变量 return _T0 # 返回 下面，我们同样也指出了在代码中我们是怎样实现这个中间代码生成 pass 的，大家可以参考注释和代码了解实现细节。 Python 框架 frontend/tacgen/tacgen.py 中通过一遍 AST 扫描完成 TAC 生成。和语义分析一样，这部分也使用了 Visitor 模式。 frontend/utils/tac 目录下实现了生成 TAC 所需的底层类。其中 tacinstr.py 下实现了各种 TAC 指令，同学们可以在必要时修改或增加 TAC 指令。提供给生成 TAC 程序流程的主要接口在 funcvisitor.py 中，若你增加了 TAC 指令，则需要在 FuncVisitor 类中增加生成该指令的接口。在本框架中，TAC 程序的生成是以函数为单位，对每个函数（step1-8 中只有 main 函数）分别使用一个 FuncVisitor 来生成对应的 TAC 程序。除此之外的 TAC 底层类，同学们可以不作修改，也可以按照自己的想法进行修改。 C++ 框架 translation/translation.hpp 及相应 .cpp 文件中通过一遍 AST 扫描完成 TAC 生成。和语义分析一样，这部分也使用了 Visitor 模式。 tac 目录下实现了生成 TAC 所需的底层类。其中 tac/tac.hpp 下实现了各种 TAC 指令，同学们可以在必要时修改或增加 TAC 指令。tac/trans_helper.hpp 及相应 cpp 文件中的 TransHelper 类用于方便地生成 TAC 指令流，若你增加了 TAC 指令，则需要在 TransHelper 类中增加生成该指令的接口。除此之外的 TAC 底层类，同学们可以不作修改，也可以按照自己的想法进行修改。 目标代码生成 目标代码生成步骤是对中间代码的再一次翻译，在本例中，你需要了解并掌握的知识点有: 如何将一个立即数装载到指定寄存器中？ RISC-V 提供了 li 指令来支持加载一个 32 位立即数到指定寄存器中，其中 表示寄存器名， 表示立即数值，如：li t0, 2021，就是将立即数 2021 加载到寄存器 t0 中。 如何设置返回值？ 在 RISC-V 中，a0 和 a1 是 gcc 调用约定上的存储返回值的寄存器，返回值会按照其大小和顺序存储在 a0 和 a1 中。也就是说，如果你有一个 32 位的返回值，你可以放在 a0 中返回，如果你有两个 32 位的返回值，你就需要把它们分别放在 a0 和 a1 中返回。更多的返回值会全部放入内存返回，如约定好的栈的某个位置，这取决于函数调用约定。 在我们的实验要求中，返回值均是单个 32 位的值。因此在当前步骤中你只需要了解，将需要返回的值放入 a0 寄存器中，然后在后面加上一条 ret 指令即可完成函数返回的工作。 综上所述，我们上述中间代码翻译成如下 RISC-V 汇编代码： .text # 代码段 .global main # 声明全局符号 main main: # 主函数入口符号 li t0, 2021 # 加载立即数2021到t0寄存器中 mv a0, t0 # 将返回值放到a0寄存器中 ret # 返回 关于实现细节，对应的代码位置在下面给出，代码中提供注释供大家学习： Python 框架 Python 框架中关于目标代码生成的文件主要集中 backend 文件夹下，step1 中你只需要关注 backend/riscv 文件夹中的 riscvasmemitter.py 以及 utils/riscv.py 即可。具体来说 backend/asm.py 中会先调用 riscvasmemitter.py 中的 selectInstr 方法对每个函数内的 TAC 指令选择相应的 RISC-V 指令，然后会进行数据流分析、寄存器分配等流程，在寄存器分配结束后生成相应的 NativeInstr 指令（即所有操作数都已经分配好寄存器的指令），最后通过 RiscvSubroutineEmitter 的 emitEnd 方法生成每个函数的 RISC-V 汇编。 C++ 框架 C++ 框架中关于目标代码生成的文件主要集中在 src/asm 文件夹下，step1 中你只需要关注 src/asm/riscv_md.cpp 即可。具体来说，riscv_md.cpp 中的 emitPiece 函数是整个目标代码生成模块的入口。你只需要顺着函数调用的逻辑，以及我们提供的注释，就能够走通整个编译的流程。 "},"docs/step1/visitor.html":{"url":"docs/step1/visitor.html","title":"Visitor 模式速成","keywords":"","body":"Visitor 模式速成 编译器的构造中会使用到很多设计模式，Visitor 模式就是常见的一种。 基础的设计模式都在 OOP 课程中覆盖，这里重提一下 Visitor 模式，并以框架中的代码为示例进行介绍。 我们知道，编译器里有很多的树状结构。最典型的就是，源程序通过上下文无关文法解析后，得到的抽象语法树。在语义分析和中间表示生成两个步骤中，我们都需要遍历整个抽象语法树。Visitor 模式的目的，就是对遍历树状结构的过程进行封装，本质就是一个 DFS 遍历。 让我们考虑 step1 的文法： program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer 以这个文法对应的一段 MiniDecaf 代码为示例： int main() { return 2; } 它会对应如下的 AST 结构： program function type(int) identifier(main) param_list return int(2) 我们用缩进表示树结构，其中 program, function, type, identifier, param_list, block, return, int 等均为 AST 上的结点类型。 Python 框架 在框架中，我们有以下的 AST 结点类实现（进行了适当的简略）： ''' frontend/ast/node.py ''' class Node: # 所有 AST 结点的基类 # ... ''' frontend/ast/tree.py ''' class Program(ListNode[Union[\"Function\", \"Declaration\"]]): # 程序，AST 的根结点类型 # ... class Function(Node): # 函数 # ... class Statement(Node): # 语句基类 # ... class Return(Statement): # return 语句 # ... class TypeLiteral(Node): # 类型基类 # ... class TInt(TypeLiteral): # 整型 # ... 假设在经过了词法分析和语法分析后，我们已经成功将 MiniDecaf 代码转化为了 AST 结构。现在，我们想要编写代码对 AST 进行扫描。很容易写出递归的 DFS 遍历： def dfs(node: Node): if isinstance(node, Program): for func in node.functions: dfs(func) elif isinstance(node, Function): # do something for scanning a function node elif isinstance(node, Return): # ... dfs 函数接收一个结点，根据这个结点的类型进行深度优先遍历。容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的遍历逻辑。 那么我们把这些遍历逻辑封装到一个类里面，就得到了一个最简单的 Visitor。此外，为了便于实现，我们不使用 isinstance 来判断结点类型，而是调用结点自身的一个 accept 函数，并把不同的 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口。 ''' frontend/ast/node.py ''' class Node: # 所有 AST 结点的基类 def accept(self, v: Visitor[T, U], ctx: T) -> Optional[U]: raise NotImplementedError ''' frontend/ast/tree.py ''' class Program(ListNode[Union[\"Function\", \"Declaration\"]]): # ... def accept(self, v: Visitor[T, U], ctx: T): return v.visitProgram(self, ctx) class Function(Node): # ... def accept(self, v: Visitor[T, U], ctx: T): return v.visitFunction(self, ctx) # ... ''' frontend/ast/visitor.py ''' class Visitor(Protocol[T, U]): def visitOther(self, node: Node, ctx: T) -> None: return None def visitProgram(self, that: Program, ctx: T) -> Optional[U]: return self.visitOther(that, ctx) def visitFunction(self, that: Function, ctx: T) -> Optional[U]: return self.visitOther(that, ctx) # ... 之后，如果我们想要编写一种遍历 AST 的方法，可以直接继承 Visitor 类，并在对应结点的 visit 成员方法下实现对应的逻辑。例如，框架中用如下的方法进行符号表构建： class Namer(Visitor[ScopeStack, None]): def visitProgram(self, program: Program, ctx: ScopeStack) -> None: # ... for child in program: if isinstance(child, Function): child.accept(self, ctx) def visitFunction(self, func: Function, ctx: ScopeStack) -> None: # ... # ... 如果想要访问某个子结点 child，直接调用 child.accept(self, ctx) 即可。 C++ 框架 在框架中，我们有以下的 AST 结点类实现（进行了适当的简略）： // ast/ast.hpp class ASTNode { // 所有 AST 结点的基类 public: virtual NodeType getKind (); // 返回结点类型 // ... }; class FuncDefn : public ASTNode { // 所有函数 // ... }; class Statement : public ASTNode { // 语句基类 // ... }; class ReturnStmt : public Statement { // return 语句 // ... }; class Type : public ASTNode { // 类型基类 // ... }; class IntType : public Type { // 整型 // ... }; 假设在经过了词法分析和语法分析后，我们已经成功将 MiniDecaf 代码转化为了 AST 结构。现在，我们想要编写代码对 AST 进行扫描。很容易写出递归的 DFS 遍历： void dfs(ASTNode *node) { if (node->getKind() == NodeType::PROGRAM) { for (auto &&item : ((Program*)node)->func_and_globals) { dfs(item); } } else if (node->getKind() == NodeType::FUNC_DEFN) { // do something for scanning a function node } else if (node->getKind() == NodeType::RETURN) { // ... } } dfs 函数接收一个结点，根据这个结点的类型进行深度优先遍历。容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的遍历逻辑。 那么我们把这些遍历逻辑封装到一个类里面，就得到了一个最简单的 Visitor。此外，为了便于实现，我们不使用 getKind 来判断结点类型，而是调用结点自身的一个 accept 函数，并把不同的 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口。 // ast/ast.hpp class ASTNode { // 所有 AST 结点的基类 public: virtual void accept(Visitor *) = 0; }; class Program : public ASTNode { public: void accept(Visitor *v) override { // 仅作示意，实际实现在对应的 .cpp 文件里 v->visit(this); } }; class FuncDefn : public ASTNode { public: void accept(Visitor *v) override { // 仅作示意，实际实现在对应的 .cpp 文件里 v->visit(this); } }; // ast/visitor.hpp class Visitor { public: virtual void visit(Program *) {} virtual void visit(FuncDefn *) {} }; 之后，如果我们想要编写一种遍历 AST 的方法，可以直接继承 Visitor 类，并在对应结点的 visit 成员方法下实现对应的逻辑。例如，框架中用如下的方法进行符号表构建： class SemPass1 : public Visitor { void visit(ast::Program* prog) { // ... // visit global variables and each function for (auto it = prog->func_and_globals->begin(); it != prog->func_and_globals->end(); ++it) { (*it)->accept(this); // ... } // ... } } 如果想要访问某个子结点 child，直接调用 child.accept(self, ctx) 即可。 "},"docs/step1/spec.html":{"url":"docs/step1/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step1 语法规范 我们采用 EBNF (extended Barkus-Naur form) 记号书写语法规范，采用类似 ANTLR 的记号： 小写字母打头的是非终结符（如 program），大写字母打头的是终结符（如 Identifier），可以用字符串字面量表示终结符（如 'int'） 后面会用到：( 和 ) 表示分组，| 表示选择，* 零或多次，+ 一或多次，? 零或一次。 很容易通过增加新的非终结符，去掉这些符号。例如 x+ 就可以被替换成新的非终结符 y，并且 y : x | x y。 EBNF 也有很多写法，另一种是用尖括号表示非终结符 ::= 等。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer step1 语义规范 1.1 MiniDecaf 的 int 类型具体指 32 位有符号整数类型，范围 [-2^31, 2^31-1]，补码表示。 1.2 编译器应当只接受 [0, 2^31-1] 范围内的整数常量, 不支持负整数常量，如果整数不在此范围内，编译器应当报错。引入负号-后，可以用负号配合正整数常量来间接表示负整数常量。 1.3 如果输入程序没有 main 函数，编译器应当报错。 "},"docs/step2/intro.html":{"url":"docs/step2/intro.html","title":"任务概述","keywords":"","body":"实验指导 step2：一元运算符 step2 中，我们要给整数常量增加一元运算：取负 -、按位取反 ~ 以及逻辑非 !。 语法上，我们需要修改 expression 的定义，从 expression : Integer 变成： expression : unary unary : Integer | ('-'|'!'|'~') unary 三个操作的语义和 C 以及常识相同，例如 ~0 == -1，!!2 == 1。 稍微一提，关于按位取反，我们使用补码存储 int；关于逻辑非，只有 0 表示逻辑假，其他的 int 都是逻辑真。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step2/example.html":{"url":"docs/step2/example.html","title":"通过例子学习","keywords":"","body":"step2 实验指导 我们按照上一节划分的编译器阶段，分阶段给出 step2 实验指导。本实验指导使用的例子为： 需要注意的是，我们为了简化描述，提取出了测试用例中和本步骤最相关的部分，实际的测试用例还是一个完整的，带有主函数的 MiniDecaf 程序。 -1 词法语法分析 在 step2 中，我们引入了一元运算，因此需要引入新的抽象语法树节点（框架中已经提供）： 对于Python是: 节点 成员 含义 Unary 操作数 operand，运算类型 op 一元运算 注意由于各种一元运算的形式是一样的，只是运算规则不同，所以用统一的一元运算节点来表示，在后续步骤中，再根据具体的运算种类翻译为不同的 TAC 与 RISC-V 指令。 对于C++是: 节点 成员 含义 NegExpr 操作数 e 一元负号 NotExpr 操作数 e 逻辑取反 BitNotExpr 操作数 e 按位取反 这些语法树节点，在C++的parser写语法规则时，可以都用Expr符号来表示，正如NegExpr和AddExpr语法树节点对应的语法规则里都是Expr符号。 语义分析 没有特别需要修改的地方。但请注意，由于现在 return 语句的返回值不再是整型常量，而是表达式，因此语义分析时需要递归地访问运算操作结点的子结点，才能访问到作为叶子结点的整型常量，完成 step1 中实现的整型常量越界检查。 中间代码生成 在 step1 中，我们只需为 return 语句的返回的整型常量分配一个临时变量即可。而从 Step2 开始，语法树上出现了各种运算操作结点。在生成 TAC 的过程中，我们需要为运算结点分配一个临时变量，并生成一条指令，该指令根据子结点的临时变量进行计算，将结果赋予该结点的临时变量。 针对取负操作，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 NEG T0 对参数取负 按照上文说的，-1 在语法树上对应父-子两个结点，父结点为取负操作，子结点为常量 1。在生成过程中，首先使用 Visitor 模式递归地访问子结点，我们使用一个临时变量加载该立即数。之后，在父结点，我们根据子结点的临时变量，生成一条取负指令，将这条指令得到的目标临时变量设置为父结点的临时变量。 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = NEG _T0 目标代码生成 step2 目标代码生成步骤的关键点在于，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。以 NEG 中间表达指令为例，RISC-V 汇编中有 neg 指令与其对应，因此上述中间代码可以翻译为如下的 RISC-V 汇编： li t0, 1 neg t1, t0 关于目标代码生成有一个小技巧，如果你实在不知道某个运算符应该翻译成怎样的汇编代码，可以参考 gcc 的输出结果。例如，你可以通过 gcc 编译如下程序来了解如何翻译逻辑非运算符到 RISC-V 汇编 riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 foo.c -S -O3 -o foo.s（记得加 -O3 选项）： int foo(int x) { return !x; } 不出意外你会获得如下结果： foo: seqz a0,a0 ret 思考题 我们在语义规范中规定整数运算越界是未定义行为，运算越界可以简单理解成理论上的运算结果没有办法保存在32位整数的空间中，必须截断高于32位的内容。请设计一个 minidecaf 表达式，只使用-~!这三个单目运算符和从 0 到 2147483647 范围内的非负整数，使得运算过程中发生越界。 提示：发生越界的一步计算是-。 总结 本步骤中其他运算符的实现逻辑和方法与取负类似，大家可以借鉴取负的实现方法实现剩下的逻辑非和按位非。并且，我们在实验框架中已经给出了取负的参考实现，希望能够帮助大家快速上手编译实验。 "},"docs/step2/spec.html":{"url":"docs/step2/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step2 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : unary unary : Integer | ('-'|'!'|'~') unary step2 语义规范 2.1 运算符 - 的结果是其操作数的相反数。 2.2 运算符 ~ 的结果是其操作数的二进制反码（也就是说，结果中的每一个二进制位是 1 当且仅当其对应的二进制位是 0）。 2.3 当操作数不等于 0 时，逻辑非运算符 ! 的结果为 0；当操作数等于 0 时，其结果为 1。 2.4 MiniDecaf 中，负数字面量不被整体作为一个 token。它被看成是一个取负符号、后面是它的绝对值。 所以我们无法用字面量表示 -2147483648，但可以写成 -2147483647-1（待我们加上四则运算后）。 2.5 整数运算越界是未定义行为（undefined behavior），即对程序的行为无任何限制。 例如 -(-2147483647-1) 是未定义行为。这一条规则对于后续 step 引入的运算符也都适用。 对于含有未定义行为的 C/C++ 程序，在启用优化选项编译时，编译器可能产生意料之外的结果。 "},"docs/step3/intro.html":{"url":"docs/step3/intro.html","title":"任务概述","keywords":"","body":"实验指导 step3：加减乘除模 step3 我们要增加的是：加 +、减 -、乘 *、整除 /、模 % 以及括号 ( )。 语法上我们继续修改 expression，变成 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1+2*(4/2+1) == 7。 我们这种表达式语法写法可能比较繁琐，但它有几个好处： 和 C17 标准草案保持一致 把优先级和结合性信息直接编码入语法里，见优先级和结合性一节。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step3/example.html":{"url":"docs/step3/example.html","title":"通过例子学习","keywords":"","body":"step3 实验指导 本实验指导使用的例子为： 1+3 词法语法分析 在 step3 中，我们引入了算术运算，因此需要引入新的抽象语法树节点（框架中已经提供）： 对于Python: 节点 成员 含义 Binary 左操作数 lhs，右操作数 rhs，运算类型 op 二元运算 对有兴趣的同学：虽然 -2 和 2-3 里面的 - 意义不同，但 lexer 不知道这点（parser 才知道），所以它们都会用同样的 token kind - 表示。 但有时，可能需要后续阶段告诉 lexer（或 parser）一些信息，最经典的例子是 “typedef-name identifier problem”。 对于C++: 类似step2，对每种二元运算实现了不同的语法树节点 节点 成员 含义 AddExpr 左操作数 e1，右操作数 e2 加法运算 SubExpr 左操作数 e1，右操作数 e2 减法运算 MulExpr 左操作数 e1，右操作数 e2 乘法运算 DivExpr 左操作数 e1，右操作数 e2 除法运算 ModExpr 左操作数 e1，右操作数 e2 取模运算 语义分析 语义分析无需修改。 中间代码生成 与一元操作类似，针对加法，我们需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 作用 ADD T0,T1 将两个参数相加 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = 3 _T2 = ADD _T0, _T1 目标代码生成 step3 目标代码生成步骤的关键点与 step2 相同，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。 li t0, 1 li t1, 3 add t2, t0, t1 思考题 我们知道“除数为零的除法是未定义行为”，但是即使除法的右操作数不是 0，仍然可能存在未定义行为。请问这时除法的左操作数和右操作数分别是什么？请将这时除法的左操作数和右操作数填入下面的代码中，分别在你的电脑（请标明你的电脑的架构，比如 x86-64 或 ARM）中和 RISCV-32 的 qemu 模拟器中编译运行下面的代码，并给出运行结果。（编译时请不要开启任何编译优化） #include int main() { int a = 左操作数; int b = 右操作数; printf(\"%d\\n\", a / b); return 0; } 总结 本步骤中其他运算符的实现逻辑和方法与加法类似，可以参考二元加法的实现方法设计实现其他二元运算符。 "},"docs/step3/precedence.html":{"url":"docs/step3/precedence.html","title":"优先级和结合性","keywords":"","body":"优先级和结合性 操作符有优先级和结合性的概念，在之前的编程经历中大家应该已经对这两个概念已经有了直观的理解，这里用例子进一步解释一下： 优先级是两个操作符之间的关系，例如*的优先级比+高，所以表达式1 + 2 * 3应该解析成语法树add (1 mul (2 3))（前序表示），不能解析成mul (add (1 2) 3) 结合性是一个操作符的性质，例如-是左结合的，所以表达式1 - 2 - 3应该解析成sub (sub (1 2) 3)，不能解析成sub (1 sub (2 3)) 我们给出的语法规范已经表示了这样的性质，因此理论上我们不需要再额外定义操作符的优先级和结合性了。你可以自己试试，按照本步给出的语法规则，上面的两个表达式确实只能解析成我们期望的结果。 但是有一个问题：这样的语法规范虽然是正确的，也确实可以直接用来实现语法分析器了，但并不符合直观：我们一开始学习C或者别的编程语言的时候，讲的就是一个二元表达式由两个子表达式和中间的操作符组成，并且操作符有优先级和结合性。也就是这样的： expression : expression ('+'|'-') expression | expression ('*'|'/'|'%') expression | ('-'|'~'|'!') expression | Integer | '(' expression ')' 当然，它是有歧义的，你也可以自己试试，如果只有这些产生式的话，上面的两个表达式都可以解析成正确或者错误的结果。所以如果想基于这个规范来实现语法分析器，就必须告诉语法分析工具这些操作符的优先级和结合性是什么。 之后每一步给出的语法都是没有歧义，本身就能体现优先级和结合性的。如果你确实想借助优先级和结合性来实现，需要两个步骤： 把我们给出的语法规范转化成类似上面这样“更模糊”，有歧义的语法规范。我们相信这个方向的转化应该是容易的。 指定每个操作符的优先级和结合性。可以参考https://en.cppreference.com/w/c/language/operator_precedence，它给出了C语言操作符的优先级和结合性，因为我们的MiniDecaf语言是C语言的一个子集，所以这张表格也足够我们的语言使用了。 "},"docs/step3/spec.html":{"url":"docs/step3/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step3 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step3 语义规范 3.1 二元操作符 * 的结果是操作数的乘积。 3.2 二元操作符 / 的结果是第一个操作数除以第二个操作数所得的商的整数部分（即所谓“向零取整”），二元操作符 % 的结果是第一个操作数除以第二个操作数所得的余数。在两种操作中，如果第二个操作数为 0，则其行为都是未定义的。当 b 不为 0 时，表达式 (a/b)*b + a%b 应该等于 a。 3.3 二元操作符 + 的结果是操作数的和。 3.4 二元操作符 - 的结果是第一个操作数减去第二个操作数所得的差。 3.5 除非特别声明，子表达式求值顺序是未规定行为（unspecified behavior），即其行为可以是多种合法的可能性之一。也就是说，以任意顺序对子表达式求值都是合法的。 例如：执行 int a=0; (a=1)+(a=a+1); 之后 a 的值是未规定的（待我们加上变量和赋值运算符后，这个问题才会产生真正切实的影响）。 "},"docs/step4/intro.html":{"url":"docs/step4/intro.html","title":"任务概述","keywords":"","body":"实验指导 step4：比较和逻辑表达式 step4 我们要增加的是： 比较大小和相等的二元操作：、、>=, >, ==, != equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive 逻辑与 &&、逻辑或 || expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1=2 是逻辑真（int 为 1）。 但特别注意，C 中逻辑运算符 || 和 && 有短路现象，我们不要求。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step4/example.html":{"url":"docs/step4/example.html","title":"通过例子学习","keywords":"","body":"step4 实验指导 本实验指导使用的例子为： 1 词法语法分析 对于Python: 本 step 中引入的运算均为二元运算，在 step3 中引入的二元运算节点中进行修改即可。 对于C++: 新引入的每个运算都有一个对应的语法树节点. 节点 成员 含义 LesExpr 左操作数 e1，右操作数 e2 小于 GrtExpr 左操作数 e1，右操作数 e2 大于 LeqExpr 左操作数 e1，右操作数 e2 小于等于 GeqExpr 左操作数 e1，右操作数 e2 大于等于 EquExpr 左操作数 e1，右操作数 e2 等于 NeqExpr 左操作数 e1，右操作数 e2 不等于 AndExpr 左操作数 e1，右操作数 e2 逻辑与 OrExpr 左操作数 e1，右操作数 e2 逻辑或 语义分析 语义分析无需修改。 中间代码生成 针对小于符号，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 LT T0,T1 给出 T0结果，成立为1，失败为0 需要特别注意的是，在 C 语言中，逻辑运算符 || 和 && 有短路现象，我们的实现中不要求大家考虑它们的短路性质。 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = 2 _T2 = LT _T0, _T1 目标代码生成 step4 目标代码生成步骤的关键点与 step3 相同，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。 li t0, 1 li t1, 2 slt t2, t0, t1 逻辑表达式会麻烦一点，因为 gcc 可能会用跳转来实现&&和||，比较难以理解，所以下面直接给出 land 和 lor 对应的不使用跳转的汇编。 IR 汇编 lor or t3,t1,t2 ; snez t3,t3 land snez t3,t1 ; snez t4,t2 ; and t3,t3,t4 注意 RISC-V 汇编中的 and 和 or 指令都是位运算指令，不是逻辑运算指令。 思考题 在 MiniDecaf 中，我们对于短路求值未做要求，但在包括 C 语言的大多数流行的语言中，短路求值都是被支持的。为何这一特性广受欢迎？你认为短路求值这一特性会给程序员带来怎样的好处？ 总结 本步骤中其他运算符的实现逻辑和方法与小于符号类似，可以参考小于符号的实现方法设计实现其他逻辑运算符。 恭喜你！到目前为止，你已经成功实现了一个基于 MiniDecaf 语言的计算器，可以完成基本的数学运算和逻辑比较运算了，成就感满满！然而，目前你的计算器还只能支持常量计算，这大大降低了计算器的使用体验，因此，在下一个 Stage，我们将一起实现对变量以及分支语句的支持。无论如何，当前的任务已经完成，好好休息一下吧☕️ "},"docs/step4/spec.html":{"url":"docs/step4/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step4 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step4 语义规范 4.1 关系操作符 （小于）、>（大于）、（小于等于）和>=（大于等于）的结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。 关系操作符可能导致表达式的含义与数学文献中常见的含义不同，例如 0 的含义与 (0 相同，即“如果 0 小于 1，那么判断是否有 1 小于 2，否则判断是否有 0 小于 2”。 4.2 判等操作符 ==（等于）和 !=（不等于）类似于关系操作符，结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。但判等操作符的优先级比关系操作符更低。对于任意一对操作数，这两个操作符中有且仅有一个结果为 1。 其优先级的设定会导致其含义在某些时候可能会反直观，例如，0 的运算结果为 1。 4.3 当操作数都非 0 时，逻辑与操作符 && 的结果为 1；否则其结果为 0。 4.4 当操作数有一个非 0 时，逻辑或操作符 || 的结果为 1；否则其结果为 0。 4.5 逻辑操作符 || 和 && 依然遵循语义规范 3.5，即其操作数的求值顺序是未指定行为。 换言之，我们不对逻辑表达式的短路求值做要求，可以将操作数两个以任意顺序计算出，再计算逻辑操作的结果。 "},"docs/step5/intro.html":{"url":"docs/step5/intro.html","title":"任务概述","keywords":"","body":"实验指导 step5：局部变量和赋值 这一步我们终于要增加变量了，包括 变量的声明 变量的使用（读取/赋值） 并且，虽然还只有一个 main 函数，但 main 函数可以包含多条语句和声明了。 为了加入变量，我们需要确定：变量存放在哪里、如何访问。 为此，我们会引入 栈帧 的概念，并介绍它的布局。 语法上，step5 的改动如下： function : type Identifier '(' ')' '{' statement* '}' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression primary : Integer | '(' expression ')' | Identifier 并且我们也要增加语义检查了：变量不能重复声明，不能使用未声明的变量。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step5/example.html":{"url":"docs/step5/example.html","title":"通过例子学习","keywords":"","body":"step5 实验指导 本实验指导使用的例子为： int main() { int x = 2021; return x; } 词法语法分析 针对局部变量定义和赋值操作，我们需要设计 AST 节点来表示它，给出的参考定义如下（框架中已经提供）： 对于python: 节点 成员 含义 Identifier 名称 val 标识符（用于表示变量名） TInt 无 整型 Assignment 同 Binary 赋值运算 请注意，赋值操作是一种特殊的二元运算，因此可以将它合并到 Binary 节点里，也可以单独设置一种节点继承 Binary 类来处理它。 对于C++: 节点 成员 含义 VarDecl 名称 name 类型type 初始化值init 变量声明 AssignExpr 左值left, 赋值的表达式e 赋值表达式 VarRef 变量名var 左值(变量) IntType 无 整数类型 StmtList 若干Statement 语句列表 语义分析 从 step5 开始，我们需要在语义分析阶段对局部变量的规范进行检查。具体来说，我们需要名为符号表的数据结构。符号表的实现已经在框架中给出。因此，你只需要修改语义分析部分的代码，在必要时调用符号表的接口即可。 在符号表构建过程中，我们要按照语句顺序，逐一访问所有变量定义声明。在访问变量声明时，我们需要为该变量赋予一个变量符号，并将它存入符号表中。由于变量不能重复声明，在定义变量符号前需要在符号表中检查是否有同名符号。 类似地，在访问表达式时，如果遇到变量的使用，我们也需要在符号表中检查，避免使用未声明的变量。例如，如果我们将测例修改为： int main() { int x = 2021; return x + y; } 那么在扫描到加法操作的 AST 结点时，会依次检查该操作的两个操作数 x 和 y。这两个操作数均为变量标识符，因此我们需要到符号表中搜索 x 和 y 对应的符号。符号 x 可以在符号表中找到（我们在扫描 int x = 2021; 这条语句后已经为其定义），而 y 无法找到，因此编译器需要在扫描到 y 对应的结点时报错。 符号表总是和作用域相关的。例如，在 C 语言中，我们可以在全局作用域中定义名为 \"a\" 的全局变量，同时在 main 函数中定义名为 \"a\" 的局部变量，这并不产生冲突。不过由于 Step5 还无需支持全局变量和块语句，同学们不用考虑这一点，只考虑 main 函数作用域对应的单张符号表即可。 此外，在本 step 中，我们引入了赋值操作。赋值可以看作一种特殊的二元运算，但需要注意，赋值号左侧必须为一个左值。具体来说，同学们需要检查赋值号左侧只能是变量名标识符。在 step11 中，我们会将左值的范围进一步包括数组元素。 Python 框架 frontend/symbol 目录下为符号的实现。其中 symbol.py 为符号类的基类，varsymbol.py 为变量符号。在本 step 中，同学们只需要考虑变量符号即可。 frontend/scope 目录下为符号表的实现。其中 scope.py 为作用域类，在本 step 中由于只有一个局部作用域，因此无需考虑作用域栈。同学们只需要新建一个 Scope 对象，用以维护 main 函数中所有出现过的变量符号即可。 C++ 框架 src/symb 目录下为符号的实现。symb/symbol.hpp 中，Symbol 类为符号类的基类，Variable 类为变量符号。在本 step 中，同学们只需要考虑变量符号即可。 src/scope 目录下为符号表的实现。scope.hpp 中，Scope 类为作用域基类，其下有 GlobalScope（全局作用域）、FuncScope（函数作用域）、LocalScope（局部作用域）等子类。在本步骤中，由于只有一个局部作用域，不需要实现作用域栈。同学们只需要新建一个 Scope 对象，用以维护 main 函数中所有出现过的变量符号即可。 建立符号表后，需要记录语法树结点与符号的对应关系，可以使用语法树结点中以 ATTR 宏标记的成员变量，也可以增加额外的成员变量进行记录。在框架代码中，宏 ATTR 用以区分语法树结点本身的成员变量和中端新加入的成员变量。这个宏只是便于修改成员变量的名字，并无其他语义。例如，VarDecl::name 是语法树结点本身的成员变量，表示变量名；而 VarDecl::ATTR(sym) 则是新增的成员变量，记录此变量对应的符号 中间代码生成 我们首先来看 step5 测试用例所对应的中间代码： main: _T1 = 2021 _T0 = _T1 return _T0 针对赋值操作，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 ASSIGN T0,T1 临时变量的赋值 从中间代码可以看出，尽管我们在 Step5 引入了变量的概念，但是在比较低级的中间代码上，数据的存储和传递仍然是基于虚拟寄存器进行的。由于 MiniDecaf 语言中的基本类型只有 int 型，而 TAC 里的临时变量也是 32 位整数，因此，我们可以把 MiniDecaf 局部变量和 TAC 临时变量对应起来。 在扫描到 int x = 2021; 这条语句时，中间代码先把立即数 2021 加载到临时变量 _T0 中，然后再把 _T0 的值赋给临时变量 _T1，此时 _T1 已经成为了变量 x 的“替身”。每次需要用到变量 x 的值时，我们都会去访问 _T1。例如，测例中直接用返回 _T1 代替了返回变量 x 的值。因此，为了在后续使用变量 x 时能快速找到 _T1 这个临时变量，在符号表中存储 x 这个符号时，应当为该符号设置一个成员，存储 x 对应的临时变量。每当在 AST 上扫描到一个变量标识符结点时，我们都直接调用该变量对应的临时变量作为结点的返回值。 Python 框架 请注意 frontend/symbol/varsymbol.py 中，变量符号的定义里有该变量对应的 TAC 临时变量成员。 C++ 框架 假设 tr 是一个 TransHelper 类（用于创建 TAC 的辅助类）的对象。对于一个 Variable（变量符号）对象 sym，可通过 sym->attachTemp(tr->getNewTempI4()) 为其分配一个 int 类型的临时变量。分配后，可通过 sym->getTemp 获取此临时变量。 目标代码生成 Step5 的示例对应如下 RISC-V 汇编代码： .text .global main main: li t1, 2021 mv t0, t1 # 我们使用 mv 指令来翻译中间表示里的 ASSIGN 指令 mv a0, t0 ret 在 step5 中，我们已经引入了变量的概念，其对应的中间代码使用虚拟寄存器来存储变量的值。如果所使用的虚拟寄存器的个数，超过了目标机器实际拥有的物理寄存器数目，将无法生成正确的目标代码。此时，需要采用寄存器分配算法，调度和分配数目有限的物理寄存器资源，保证所有临时变量（虚拟寄存器或伪寄存器）都有合适的物理寄存器与之对应。在程序执行的任何时刻，都需要保证不会出现寄存器分配冲突，即两个同时有效且将被引用的临时变量（虚拟寄存器）被分配到同一个物理寄存器中，寄存器分配冲突将造成程序运行结果的错误。然而，寄存器分配问题是 NP 完备问题（可归约成 3-SAT 问题），这意味着对于一个含有大量临时变量的程序，为了获得最优寄存器分配方案，编译器将耗费可观的计算时间用于寄存器分配。因此，考虑到执行效率问题，实际的编译器实现中一般采用启发式算法。在所提供的实验框架中，采用了一种简单的基于活跃性分析的启发式分配算法。 简单的启发式寄存器分配算法 实验框架中所采用的启发式寄存器分配算法基于活跃性分析。为避免一次性介绍过多的知识，将在 step7 详细介绍活跃性分析的相关理论。大家目前只需要了解，活跃性分析是为了求解每个临时变量是否会在程序某点之后被引用，如果被引用，这个临时变量就是活跃的。 基于活跃性分析的启发式寄存器分配算法的基本思路：针对每一条 TAC 指令（例如 _T2 = ADD _T1, _T0），对于每个源操作数对应的临时变量（本例中 _T1 和 _T0），我们检查该临时变量是否已经存放在物理寄存器中，如果不是，则分配一个物理寄存器，并从栈帧中把该临时变量加载到寄存器中；对于目标操作数对应的临时变量（本例中的 _T2），如果该临时变量没有对应的物理寄存器，则为其分配一个新的物理寄存器。寄存器分配过程中，将为临时变量和为该变量分配的物理寄存器之间建立一种关联关系。 在分配寄存器时，首先检查是否存在空闲的寄存器（即尚未跟任何临时变量建立关联关系的寄存器），有则选择该寄存器作为分配结果。否则，检查有没有这样的寄存器，其所关联的临时变量在当前位置已经不是活跃变量了，这说明该寄存器所保存的数据未来不会被用到，可以回收使用这个寄存器而不用担心引起数据错误。一种可能的情况是，所有寄存器所关联的变量都是活跃的，即不存在空闲的寄存器。此时，将把某个寄存器所关联的暂时不用的变量存到栈帧（内存的一部分）中，腾出这个寄存器，这也称为溢出（spill）到内存。所腾空的寄存器是随机选取的，因此，所采用的寄存器分配算法有些暴力，存在进一步优化空间。 上面的描述中提到，在分配寄存器的时候从栈帧中加载数据，以及将暂时不用的变量存储到栈帧中，接下来介绍栈帧的概念。 栈帧 栈帧的概念 在汇编语言课程学习中，大家应该已经接触到栈帧的概念，下面简单回顾一下。在程序执行过程中，每次调用和执行一个函数，都会在栈上开辟一块新的存储空间，这块存储空间就叫做“栈帧”。栈帧中存放了函数执行所需的各种数据，包括需要临时保存的局部变量、在栈上临时申请的存储空间（如数组，在 step11 中介绍）、被调用者负责保存的寄存器等。栈帧是函数正确调用和执行的保证。 需要注意的是，由于我们目前只支持一个 main 函数，直到 step9 才会有多函数支持。所以现在关于栈帧的讨论，就只针对 main 函数的栈帧，并且集中于临时变量的存储和加载。 假设当前函数被某个函数调用，下图给出当前函数的栈帧。如图所示，当前函数的栈帧由被调用者负责保存的寄存器、保存的临时变量以及局部变量三个部分组成，fp 指向当前栈帧的栈底，sp 指向当前栈帧的栈顶，fp 和 sp 之间的部分就是当前函数的栈帧。当前实验步骤中，需要关注的是临时变量保存区域，正是在这个区域中，保存了为腾空物理寄存器而取出的临时变量（仍然活跃的临时变量）。值得一提的是，临时变量保存区域中还保存了基本块出口处仍活跃的临时变量（关于基本块的概念，将在 step7 介绍，在当前的步骤不需要考虑）。 栈帧的建立与销毁 栈帧是函数运行所需要的上下文的一部分，在进入函数的时候需要建立对应的栈帧，在退出函数的时候需要销毁其对应的栈帧。栈帧对于函数的运行非常重要。那么程序在运行的过程中如何建立和销毁栈帧呢？实际上，建立栈帧的操作是由编译器生成代码完成的。在每个函数的起始位置，由编译器生成的用于建立栈帧的那段汇编代码称为函数的 prologue。prologue 所做的事情包括：分配栈帧空间和保存相应寄存器的值。相应的，在每个函数的末尾，用于销毁栈帧的那段汇编代码称为函数的 epilogue。epilogue 所做的事情包括：设置返回地址，回收栈帧空间，以及从当前被调用函数过程返回 貌似创建和销毁栈帧是一个大工程？实际不然，确定栈帧只需要维护好两个寄存器，sp 和 fp，它们分别保存当前栈帧的栈顶地址和栈底地址。当新的函数被调用时，需要把旧栈帧的栈底地址（fp）保存起来，用旧栈帧的栈顶地址（sp）表示新栈帧的栈底地址（新fp）。不难看出，新老栈帧在栈内存中是连续的存储空间。此外，每个函数体中需要分配的局部变量以及需要保存的临时变量在编译过程中是可知的。因此，栈帧的大小在编译期可以计算得出，即存储寄存器的空间，临时变量存储空间与局部变量空间三者之和。在求得栈帧大小之后，可以通过修改栈顶指针（sp）的值来分配恰当的栈帧空间。 在实验框架中已经给出寄存器分配以及栈帧创建、销毁的代码，下面给出代码所在位置，感兴趣的同学可以参考代码和注释进行深入学习。 Python 框架： 寄存器分配算法主要集中在 backend/reg/bruteregalloc.py 中，主要有以下几个函数： accept：根据每个函数的 DFG（数据流图）进行寄存器分配，寄存器分配结束后生成相应汇编代码。 bind：将一个 Temp（临时变量）与寄存器绑定。 unbind：将一个 Temp（临时变量）与相应寄存器解绑定。 localAlloc：根据活跃变量信息对一个 BasicBlock（基本块）内的指令进行寄存器分配。 allocForLoc：每一条指令进行寄存器分配。 allocRegFor：根据活跃变量信息决定为当前 Temp（临时变量）分配哪一个寄存器。 C++ 框架： 寄存器分配算法主要集中在 src/asm/riscv_md.cc 中，主要有以下几个函数： getRegForRead：为源操作数对应的临时变量分配寄存器。 getRegForWrite：为目标操作数对应的临时变量分配寄存器。 selectRegToSpill：当物理寄存器不足时，溢出到栈内存的寄存器选择算法是随机的。 栈帧建立和销毁分别位于 emitProlog 函数和 emitTrace 函数中。 思考题 TODO 总结 Step5 主要涉及的知识为符号表、寄存器分配和栈帧，对于大家来说有一定的跳跃性和挑战性，希望大家能够尽早开始。 "},"docs/step5/spec.html":{"url":"docs/step5/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step5 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement* '}' type : 'int' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step5 语义规范 5.1 每一条变量声明（定义）指定了对标识符的解释和属性。当变量被定义时，应当有一块存储空间为这个变量所保留。当变量声明之后，若与这个变量的名称相同的标识符作为操作数（operand）出现在一个表达式中时，其就应被指派（designate）为这个变量。 5.2 变量的初始化表达式指定了变量的初始值。 5.3 同一个标识符应只能作为至多一个变量的名字，即是说，不允许声明重名变量。 5.4 对未声明的变量的使用是错误。 5.5 没有被初始化的（局部）变量的值是不确定的。 在初始化表达式中，正在被初始化的变量已被声明，但其值尚未被初始化。 例如，int a = a + 1;，这样一条声明在语义上等价于 int a; a = a + 1; 5.6 局部变量的名字可以为 main。 5.7 赋值运算 = 的左操作数必须是一个可修改的左值（modifiable lvalue）。左值（lvalue）即一个会被指派为某个变量的表达式，如在 int a; a = 1; 中，a 即是一个会被指派为变量的表达式。左值可修改是指被指派的变量不能是一个左值数组。 就 step5 来说，这一点其实几乎已经被语法保证，因为其 = 的左边只能是一个标识符，只需再要求其是一个已经声明过的变量的名字即可。 详见后面 step12 的讨论。 5.8 在赋值运算（=）中，右操作数的值会被存在左操作数所指派的变量中。 5.9 赋值表达式的结果，为赋值运算完成后左操作数所指派的变量的值，但这个结果本身并非左值。 5.10 一个函数中可以有任意多条 return 语句。 5.11 当 main 函数执行至 } 时，应终止执行并返回 0。 "},"docs/step6/intro.html":{"url":"docs/step6/intro.html","title":"任务概述","keywords":"","body":"实验指导 step6： step6 我们要支持 if 语句和条件表达式（又称三元/三目表达式，ternary expression）。 语法上的改动是： if 表达式 statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? 条件表达式 assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional block_item：为了下一阶段做准备 function : type Identifier '(' ')' '{' block_item* '}' block_item : statement | declaration if 语句的语义和 C 以及常识相同，条件表达式优先级只比赋值高。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step6/example.html":{"url":"docs/step6/example.html","title":"通过例子学习","keywords":"","body":"step6 实验指导 本实验指导使用的例子为： int main() { int x = 1; if (x) x = 2; else x = 3; return x; } 词法语法分析 针对 if 语句，我们需要设计 AST 节点来表示它，给出的参考定义如下（框架中已经提供）： 对于Python: 节点 成员 含义 If 分支条件 cond，真分支 then，假分支 otherwise if 分支语句 仿照 if 节点，还需要类似地实现条件表达式节点（框架中已经提供）。 对于C++: 节点 成员 含义 IfStmt 分支条件 condition，真分支 true_brch，假分支 false_brch if 分支语句 IfExpr 分支条件 condition，真分支 true_brch，假分支 false_brch if 条件表达式 悬吊 else 问题 这一节引入的 if 语句既可以带 else 子句也可以不带，但这会导致语法二义性：else 到底和哪一个 if 结合？ 例如 if(a) if(b) c=0; else d=0;，到底是 if(a) {if(b) c=0; else d=0;} 还是 if(a) {if(b) c=0;} else d=0;（其中有大括号，step7中会支持，不过意思不难理解）？ 这个问题被称为 悬吊 else（dangling else） 问题。 如果程序员没有加大括号，那么我们需要通过一个规定来解决歧义。 我们人为规定：else 和最近的 if 结合，也就是说上面两种理解中只有前者合法。 为了让 parser 能遵守这个规定，一种方法是设置产生式的优先级，优先选择没有 else 的 if。 按照这个规定，parser 看到 if(a) if(b) c=0; else d=0; 中第一个 if 时，选择没有 else 的 if； 而看到第二个时只能选择有 else 的 if ，也就使得 else d=0; 被绑定到 if(b) 而不是 if(a) 了。 需要说明的是 bison 默认在 shift-reduce conflict 的时候选择shift，从而对悬挂else进行就近匹配。 语义分析 本步骤中语义分析没有特别需要增加的内容，只需要在扫描到 if 语句和条件表达式时递归地访问其子结点即可。请注意 if 语句不总是有 else 分支，所以在递归到子结点时，请先判断子结点是否存在。 中间代码生成 从本步骤开始，由于 MiniDecaf 程序出现了分支结构，我们需要开始考虑跳转语句了。在 Step1-4 中，TAC 代码中的标签只有标志 main 函数入口这一个功能。而现在，我们需要使用标签来指示跳转指令的目标位置。我们用 _Lk 来表示跳转用标签，以此和函数入口标签区分开来。 为了实现 if 语句，我们需要设计两条中间代码指令，分别表示条件跳转和无条件跳转，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 作用 BEQZ T0, Label 若 T0 的值为0，则跳转到 LABEL 标签处 JUMP Label 跳转到 LABEL 标签处 现在让我们来看看示例所对应的 TAC 代码： main: _T1 = 1 _T0 = _T1 BEQZ _T0, _L1 _T2 = 2 _T0 = _T2 JUMP _L2 _L1: _T3 = 3 _T0 = _T3 _L2: return _T0 在这段 TAC 代码中，x 对应的临时变量为 _T0。如果 x 的值为真（不等于0），那么应当执行 then 分支 x = 2;，否则执行 else 分支 x = 3;。因此，我们设置了两个跳转标签 _L1 和 _L2，分别表示 else 分支开始位置和整个 if 语句的结束位置。如果 x 为假，那么应当跳转到 _L1 处，我们使用一条 BEQ 指令来执行。如果 x 为真，那么按顺序执行 then 分支的代码，并在该分支结束时，用一条 JMP 指令跳转到 if 语句的结束位置，从而跳过 else 分支。在 TAC 生成过程中，每当扫描到 if 语句时，都需要调用 TAC 的底层接口，新建两个跳转标签，并按照这种方式生成中间代码。 当然，如果一条 if 语句没有 else 分支，那么只需要一个跳转标签即可。例如我们将例子中的 if 语句修改为 if (x) x = 2;，则对应的 TAC 代码可简化为： main: _T1 = 1 _T0 = _T1 BEQ _T0, _L1 _T2 = 2 _T0 = _T2 _L1: return _T0 同样地，条件表达式也可以使用类似的方法完成中间代码生成。要注意的是，条件表达式是一种特殊的表达式，因此有返回值。同学们在实现的时候不要忘记为其分配临时变量。 目标代码生成 step6 中目标代码生成主要是指令的选择以及 label 的声明，RISC-V 提供了与中间代码中 BEQ 和 JMP 类似的指令： step6: # RISC-V 汇编标签 beqz t1, step6 # 如果t1为0，跳转到 step6 标签处 j step6 # 无条件跳转到 step6 标签处 思考题 TODO 总结 本节主要就是引入了跳转，后面 step8 循环语句还会使用。 "},"docs/step6/spec.html":{"url":"docs/step6/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step6 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' block_item* '}' type : 'int' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier 注意：if 的 then 分支和 else 分支需要是一个语句（statement）而非声明（declaration）。 例如 if (1) int a; 不是合法的 MiniDecaf 程序。 step6 语义规范 6.1 条件表达式会先对第一个操作数求值，再根据其值选择计算第二个或第三个操作数。当且仅当第一个操作数的值不等于 0，我们会对第二个操作数求值。当且仅当第一个操作数的值等于 0，我们会对第三个操作数求值。当第一个操作数的值为 0 时，条件表达式的求值结果为第二个操作数所求得的值；当第一个操作数的值非 0 时，条件表达式的求值结果为第三个操作数所求得的值。 不论选择第二个操作数或者是第三个操作数去求值，都必须首先计算完第一个操作数，之后才能开始第二个或第三个操作数的求值计算。 6.2 对于 if 语句而言，当控制条件不等于 0 时，会执行第一个子句；当控制条件等于 0 时，如果有 else 分支，就会执行第二个语句，否则整个 if 语句的执行便已经完成。 6.3 如果出现悬吊 else（dangling else），要求 else 优先和最接近的没有匹配 else 的 if 匹配。 例如 if (0) if (0) ; else ; 等价于 if (0) { if (0) ; else; } 而非 if (0) { if (0) ; } else ;。 "},"docs/step7/intro.html":{"url":"docs/step7/intro.html","title":"任务概述","keywords":"","body":"实验指导 step7：作用域和块语句 step7 我们要增加块语句的支持。 虽然块语句语义不难，就是把多个语句组成一个块，每个块都是一个作用域。 随之而来一个问题是：不同变量可以重名了。 重名的情况包括作用域内部声明覆盖（shadowing）外部声明，以及不相交的作用域之间的重名变量。 因此，变量名不能唯一标识变量了，同一个变量名 a 出现在代码不同地方可能标识完全不同的变量。 我们需要进行 名称解析（name resolution），确定 AST 中出现的每个变量名分别对应那个变量。 语法上改动不大 function : type Identifier '(' ')' compound_statement compound_statement : '{' block_item* '}' statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement 语义检查我们也要修改了，只有在同一个作用域里，变量才不能重复声明。 当然，如果变量在使用前还是必须先被声明。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step7/example.html":{"url":"docs/step7/example.html","title":"通过例子学习","keywords":"","body":"step7 实验指导 本实验指导使用的例子为： int main() { int x = 1; { x = 2; int x = 3; } x = 4; return x; } 词法语法分析 针对块语句，我们需要设计 AST 节点来表示它，给出的参考定义如下： 对于Python: 节点 成员 含义 Block 子语句列表 children 语句块 对于C++: 节点 成员 含义 CompStmt 子语句列表 stmts 语句块 语义分析 从 Step7 开始，我们需要考虑作用域和代码块。简而言之，一份代码中可能有多个代码块的嵌套，因此作用域开始出现了层次结构。例如，在示例中，尽管 main 函数里定义了变量 x，但随后我们开启了一个新的代码块。在这个代码块中，赋值语句 x = 2; 中的 x 就是指 main 作用域中定义的 x，而随后通过 int x = 3; 我们定义了另一个变量 x，这个 x 只在内部大括号括起的作用域内生效。 在 Step5 中，我们只维护了 main 的作用域，所有符号都在这个作用域的符号表中维护。现在，为了维护层次嵌套的作用域，我们引入了作用域栈（Scope Stack）这个数据结构。在进行符号表构建的扫描过程中，我们需要动态维护作用域栈，保存当前扫描结点所在的从内到外所有作用域。每次我们开启一个代码块时，要新建一个作用域并压栈；而当退出代码块时，要弹栈关闭此作用域。 接下来针对上述代码示例，讲述作用域栈的维护方式。首先，栈底有一个全局作用域，其符号表里只有 main 函数。由于目前不需要考虑函数和全局变量，可以暂时忽略全局作用域。进入 main 函数时，开启一个局部作用域，在扫描 int x = 1; 时定义变量符号 x，并将其加入栈顶作用域对应的符号表中。如下所示： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域（栈顶） 变量 x 接下来，扫描到一个局部代码块，由此建立一个局部作用域并压栈。在扫描 x = 2; 时，我们需要分析 x 这个变量对应着哪个作用域里的符号。此时的作用域栈是这样的： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域 变量 x 局部作用域（栈顶） 空 对变量x的查找从栈顶开始，由上向下依次查找对应的符号表，直至找到变量 x 为止。由于在栈顶作用域对应的符号表中不存在变量符号 x，于是向下继续查找。在 main 函数对应的作用域中，可以找到变量符号 x。因此，语句 x = 2; 中的 x 对应 main 函数作用域里定义的变量 x。 接下来，当扫描到语句 int x = 3; 时，定义了另一个变量 x。此时，只需要在栈顶作用域中查找该变量是否存在。若不存在，即在符号表中加入对应符号。此时的作用域栈如下： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域 变量 x 局部作用域（栈顶） 变量 x 请务必注意上表中的两个变量 x 是不同的变量。 接下来，退出代码块，将其对应的作用域弹出栈，此时的作用域栈如下： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域（栈顶） 变量 x 最后，扫描语句 x = 4; 时，从栈顶作用域符号表查找 x，所找到的变量 x 为 main 作用域定义的 x 变量。 中间代码生成 本步骤中无须新增新的 TAC 指令。 让我们来看看示例所对应的 TAC 代码： main: _T1 = 1 _T0 = _T1 # int x = 1; _T2 = 2 _T0 = _T2 # x = 2 _T4 = 3 _T3 = _T4 # int x = 3; _T5 = 4 _T0 = _T5 # x = 4; return _T0 显然，两个代码块里的变量 x 是不同的变量，因此它们分别对应着不同的临时变量。其中，_T0 对应着 main 作用域里的 x，而 _T3 则对应着内层代码块定义的变量 x。只要同学们在符号表构建阶段把每个变量和正确作用域的变量符号关联起来，这一步就非常简单了：找到对应变量符号，使用该符号对应的临时变量即可。 目标代码生成 由于不需要新增新的中间代码指令，本步骤中目标代码生成模块没有新的工作，但这是建立在你之前的实现没有错误基础上的。 思考题 TODO "},"docs/step7/dataflow.html":{"url":"docs/step7/dataflow.html","title":"数据流分析","keywords":"","body":"数据流分析 编译优化的基础是数据流分析。 基本块（basic block）和控制流图（control-flow graph）是用于进行上述分析的数据结构。 以下讲述数据流分析的内容中，所有的 CondBranch 指令为条件跳转指令，Branch 指令为跳转指令。 基本块 基本块是指一段这样的代码序列： 除出口语句外基本块中不含任何的 Branch、Beqz（条件为假时跳转）、Bnez（条件为真时跳转）或者 Return 等跳转语句（但可以包含 Call 语句）。 除入口语句外基本块中不含任何的 Label 标记，即不能跳转到基本块中间。 在满足前两条的前提下含有最多的连续语句，即基本块的头尾再纳入一条语句将会违反上面两条规则。 下面的例子中，代码中不同的基本块被标以不同的颜色： 也就是说，基本块内的代码执行过程总是从基本块入口开始，到基本块出口结束的，中间不会跳到别的地方或者从别的地方跳进来。 控制流图 控制流图是一个有向图：它以基本块作为结点，如果一个基本块 A 执行完之后，有可能跳转到另一个基本块 B，则图中包含从 A 对应结点到 B 对应结点的有向边。对于以 Branch 语句或者任何非跳转语句结尾的基本块，其后继只有一个结点；对于以 CondBranch 语句结尾的基本块，其后继含有两个结点，分别对应跳转条件为真和假的情况。不难想像，控制流图的有向边组成的每一个环路都对应着程序中的一个循环结构。由于该图给出程序控制流的各种可能执行路径，因此也称为控制流图。 为进行编译优化，建立控制流图是必不可少的一步。已知一个操作序列，如何根据这个操作序列建立对应的控制流图呢？通常分为两步进行： 划分基本块。 建立基本块之间的连接关系。 基本块的划分算法比较简单：从头到尾扫描操作序列，当遇到以下情况时结束当前基本块，并开始一个新的基本块建立过程： 当遇到一个 Label 标记而且存在跳转语句跳转到这个行号时。 当遇到 Branch、CondBranch 或者 Return 等跳转语句时。 整个操作序列扫描完毕后，我们就成功建立了所有基本块。 在划分好基本块之后，需要从头到尾依次扫描所有的基本块建立控制流图： 如果当前基本块以 Branch 结尾，则在当前基本块与所跳转到的目标基本块之间加入一条有向边。 如果当前基本块以 CondBranch 结尾，则在当前基本块和跳转条件成立与不成立的目标基本块之间分别加入一条有向边（共 2 条边）。 如果当前基本块以 Return 结尾，则不需要加入新的边。 在所有的基本块都扫描完毕后，即建立了控制流图。基于控制流图，可以进行控制流分析。 上面例子对应的控制流图如下： 活跃变量和活跃变量方程 从编译器中端出来的中间代码中，我们对 TAC 中使用的临时变量的个数并没有做任何限制。但是在实际机器中，物理寄存器的数量是有限的。 因此我们需要想办法把这些无限多的临时变量“塞”到有限个物理寄存器里面：如果两个临时变量不会在同一条指令中被用到，那么我们可以让这两个临时变量使用同一个物理寄存器（把一部分当前指令用不到的临时变量保存到栈上）。 根据这样的原则，大多数的临时变量都可以用有限的几个物理寄存器对应起来，而“塞不下”的那些临时变量，则可以暂时保存到内存里面（因为访问内存的时间比访问寄存器的时间多得多，因此临时变量应尽可能一直存放在物理寄存器中，尽量不要 spill 到栈上）。 由于一个物理寄存器在确定的时刻只能容纳一个临时变量，因此为了把若干个变量塞到同一个物理寄存器里面，我们需要知道各个临时变量分别在哪条指令以后不会再被用到（以便腾出当前临时变量占用的物理寄存器给别的临时变量）。此时我们需要用到活性分析（liveness analysis），或者称为“活跃变量分析”。 一个临时变量在某个执行点是活的（也叫“活跃”、live），是指该临时变量在该执行点处具有的值会在这个执行点以后被用到，换句话说，就是在该执行点到给这个临时变量重新赋值的执行点之间存在着使用到这个临时变量的语句。活性分析是指分析每一个临时变量在程序的每一个执行点处的活跃情况，通常是通过计算出每个执行点处的活跃变量集合来完成。 下面代码中每行语句右边都给出了执行完该语句后的活跃变量集合： TAC 代码 活跃变量集合 _T0 = 4 {_T0} _T1 = 3 {_T0, _T1} _T2 = _T0 * _T1 {_T0} _T3 = _T0 * _T0 {_T0, _T3} _T2 = _T3 * _T3 {_T0, _T2, _T3} _T2 = _T0 * _T2 {_T2, _T3} _T1 = _T2 * _T3 {_T1} return _T1 空集 一般来说，活性分析是通过求解活跃变量方程来完成的。为了介绍活跃变量方程的概念， 我们需要先引入下面四种针对基本块的集合： Def 集合：一个基本块的 Def 集合是在这个基本块内被定值的所有变量。所谓的定值 （definition），可以理解为给变量赋值，例如加法语句给目标变量定值等（注意：Store 语句不给任何变量定值，Load 语句则会给对应变量定值）。 LiveUse 集合：一个基本块的 LiveUse 集合是在这个基本块中所有在定值前就被引用过的变量，包括了在这个基本块中被引用到但是没有被定值的那些变量。 LiveIn 集合：在进入基本块入口之前必须是活跃的那些变量。 LiveOut 集合：在离开基本块出口的时候是活跃的那些变量。 其中 Def 和 LiveUse 是基本块本身的属性，对每个基本块从后往前遍历基本块内的指令便可以求出。 有了基本块的这四个集合的概念，我们给出控制流图中每个基本块满足的活跃变量方程: 该方程说的是一个基本块的 LiveOut 集合是其所有后继基本块的 LiveIn 集合的并集，而且 LiveIn 集合是 LiveUse 集合的变量加上 LiveOut 集合中去掉 Def 集合以后的部分。 这个方程的直观意义是： 一个基本块的任何一个后继基本块入口处活跃的变量在这个基本块的出口必须也是活跃的。 在一个基本块入口处需要活跃的变量是在该基本块中没有定值就被使用的变量，以及在基本块出口处活跃但是基本块中没有定值过的变量（因为它们的初值必定是在进入基本 块之前就要具有的了）。 根据这个方程，我们可以通过迭代更新的办法求出每个基本块的 LiveIn、LiveOut 集合，以下是求解的伪代码： for i 获得了每个基本块的 LiveIn 和 LiveOut 集合以后，我们需要进一步地计算基本块内每个 TAC 语句的 LiveIn 和 LiveOut 集合。如果我们把基本块内所有 TAC 语句分别看成是一个独立的基本块，则不难想像，前面提到的活跃变量方程仍然有效，不同之处在于，一个基本块对应的 “控制流图” 有以下三种特点： 每个节点的出度都是 1，也就是说 LiveOut(B) = LiveIn(Succ(B))。 由于每个结点只含有一个语句，因此其 Def 集要么是空集，要么只含有一个元素。 由于每个结点对应的语句里所引用的所有变量在使用的时候都未在该基本块中经过定值，其 LiveUse 集合就是源操作数对应的所有变量。 基于上面三个特点，已经求出基本块的 LiveOut 集合的前提下我们只需要在每个基本块内从后往前遍历基本块内的指令就可以对每条基本块内指令求出 LiveIn、LiveOut。 "},"docs/step7/spec.html":{"url":"docs/step7/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step7 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step7 语义规范 7.1 根据其声明的位置，每一个标识符都属于一个作用域。目前我们有两种作用域：文件级和块级。如果是在块中声明，则标识符其声明所属的块的作用域中，例如局部变量；否则标识符在文件级（全局）作用域中，例如全局变量。 7.2 （更新 5.6）如果一个标识符在两个作用域里面，这两个作用域必然是嵌套的，即一个内层作用域完全被另一个外层作用域所覆盖。且在内层作用域中，外层作用域里该标识符所指派（designate）的变量或函数是不可见的。 在初始化表达式中，其正在初始化的变量已被声明，会隐藏（shadow）外层作用域的同名变量，但其值不确定。例如在下面的代码片段中，a + 1 的值是不确定的。 int a = 1; { int a = a + 1; } 7.1 （更新 5.3）对于同一个标识符，在同一个作用域中至多有一个声明。 7.3 （更新 5.4）使用不在当前开作用域中的变量名是不合法的。 "},"docs/step8/intro.html":{"url":"docs/step8/intro.html","title":"任务概述","keywords":"","body":"实验指导 step8：循环语句 step8 我们要增加对循环语句，以及 break/continue 的支持： statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' 循环语句的语义和 C 的也相同，并且我们要检查 break/continue 不能出现在循环外。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step8/example.html":{"url":"docs/step8/example.html","title":"通过例子学习","keywords":"","body":"step8 实验指导 本实验指导使用的例子为： for (int i = 0; i 词法语法分析 针对 for 和 break 语句，我们需要设计 AST 节点来表示它，给出的参考定义如下： 节点 成员 含义 For 初始语句 init，循环条件 cond，更新语句 update，循环体 body for 循环语句 Break 无 break 语句 语义分析 本步骤语义分析阶段的处理方式和 Step6 中的 if 语句相类似，但是请额外注意以下两点： for 循环要自带一个作用域。在示例里，for (int i = 0; i 语句里定义的循环变量处于一个独自的作用域里。这也就是说，我们可以在循环体内部定义同名变量。如果我们把示例修改为：for (int i = 0; i 这也是合法的 MiniDecaf 程序。因此，在符号表构建阶段，扫描到 for 结点时，不要忘记开启一个局部作用域。 break 和 continue 语句必须位于循环体内部才合法。因此，在扫描过程中，需要记录当前结点位于多少重循环内。扫描到 break 和 continue 结点时，若当前不处于任何循环内，则报错。 中间代码生成 本步骤中没有需要新增的 TAC 指令。不过为了实现循环语句，需要仔细地考虑如何将 MiniDecaf 循环语句翻译成 TAC 的分支跳转指令。由于 while 循环、do-while 循环都可以看作 for 循环的特例，我们选择了 for 循环作为示例。 让我们先来看看示例对应的 TAC 代码： _T1 = 0 _T0 = _T1 # int i = 0; _L1: # begin label _T2 = 5 _T3 = LT _T0, _T2 BEQZ _T3, _L3 # i 为了实现所有可能的跳转，对每个 for 循环我们都需要定义三个跳转标签：begin, loop 和 break。它们的作用如下： begin 标签（示例中的 _L1）是循环体的开始位置。初次进入循环时，从这个标签的位置开始执行，并判断循环条件是否满足，若不满足，则跳转到 break 标签（示例中的 _L3）处。 loop 标签（示例中的 _L2）是执行 continue 语句时应当跳转到的位置。 break 标签是整个循环结束后的位置。如果循环条件不满足，或者执行了 break 语句，那么应当跳转到此处，执行循环之后的指令。 请注意，示例给出的只是一种循环语句参考实现，同学们也可以设计自己的实现方法。 由于循环语句可以嵌套，所以 TAC 语句生成过程中需要动态维护 loop 标签和 break 标签，这样才能确定每一条 continue 和 break 语句跳转到何处。因此，在 TAC 生成时，需要使用栈结构维护从内到外所有的 loop 标签和 break 标签。 Python 框架 utils/tac/funcvisitor.py 里的 FuncVisitor 类里实现了维护 TAC 生成时需要的上下文信息的功能。同学们可以在这个类中增加对循环所需的 continue/break 标签的维护。 C++ 框架 同学们可以直接在 translation/translation.hpp 中的 Visitor 中用成员变量维护 continue/break 标签。 目标代码生成 由于不需要增加新的中间代码指令，本步骤中目标代码生成模块没有新的内容。除非之前步骤的实现有误，否则这个步骤应该不会出现错误。 思考题 TODO "},"docs/step8/spec.html":{"url":"docs/step8/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step8 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step8 语义规范 方便起见，我们称 for 循环括号中的三个表达式/声明自左向右依次为 init、ctrl 和 post。 例如 for (i=0; i 中，i=0 是 init，i 是 ctrl，i=i+1 是 post。 8.1 有三种循环语句：for 循环、while 循环和 do 循环。执行一条循环语句，意味着反复执行一条语句（即循环体），直到其控制表达式等于 0。 8.2 while 循环的控制表达式的求值在循环体的每次执行之前。 8.3 do 循环的控制表达式的求值在循环体的每次执行之后。 8.4 对于 for 循环而言：如果 init 是一个声明，其声明发生在控制表达式的第一次求值之前；如果 init 是一个表达式，其求值会在控制表达式的第一次求值之前。ctrl 即是控制表达式，其求值在循环体的每次执行之前。post 的求值在循环体的每次执行之后。 8.5 for 循环的 init、ctrl 和 post 都可以被省略。省略 ctrl 等价于将其替换为一个非零常数，比如 1。 8.6 循环语句有其自己的作用域，且是它所在的作用域的子集。循环体也有其作用域，且是循环语句的作用域的子集。如果 for 循环的 init 是一条声明，则其所声明的变量所属的作用域是整个 for 循环语句的作用域（包含 init、ctrl、post 和循环体）。 例如，for (int i=0;;i=i+1) { int i=1; return i; } 是合法的代码片段。 8.7 continue 语句和 break 语句要么出现在循环体里，要么其就是循环体。 8.8 执行一条 continue 语句，意味着将程序的执行跳转至该条 continue 语句所在的最小的循环语句的循环体的末尾。 例如，for (int i=0;i 等价于 for (int i=0;i。 8.9 执行一条 break 语句，意味着终止该条 break 语句所在的最小的循环语句的执行。 "},"docs/step9/intro.html":{"url":"docs/step9/intro.html","title":"任务概述","keywords":"","body":"实验指导 step9：函数 step9 开始，我们要支持多函数了。 我们需要支持函数的声明和定义： program : function* function : type Identifier '(' parameter_list ')' (compound_statement | ';') parameter_list : (type Identifier (',' type Identifier)*)? 我们还需要支持函数调用： expression_list : (expression (',' expression)*)? unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' 语义检查部分，我们需要检查函数的重复定义、检查调用函数的实参（argment）和形参（parameter）的个数类型一致。 我们不支持 void 返回值，直接忽略 int 返回值即可。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step9/example.html":{"url":"docs/step9/example.html","title":"通过例子学习","keywords":"","body":"step9 实验指导 本实验指导使用的例子为： int func(int x, int y) { return x + y; } int main() { return func(1, 2); } 词法语法分析 针对函数特性，我们需要设计 AST 节点来表示它，给出的参考定义如下： 节点 成员 含义 Function 返回类型 return_type，函数名 ident，参数列表 params，函数体 body 函数 Parameter 参数类型 var_type，变量名 ident 函数参数 语义分析 本步骤中引入了函数，和局部变量类似，不允许调用未定义的函数，也不允许重复定义同名函数。因此，需要在全局作用域的符号表里维护函数符号。函数符号存放在栈底的全局作用域中，在遍历 AST 构建符号表的过程中，栈底符号表一直存在，不会被弹出。 此外，由于函数体内部除了局部变量以外，还有函数参数（argument）。因此，我们进入一个函数，开启函数体局部作用域时，需要将所有的参数加进该作用域的符号表中。举例来说，如果我们将示例改成： int func(int x, int y) { int x = 1; return x + y; } 那么语义检查时应当报错。 Python 框架 frontend/symbol/funcsymbol.py 里实现了函数符号。 C++ 框架 symb/symbol.hpp 中 Function 类表示函数符号。scope/scope.hpp 中，FuncScope 表示函数作用域。 中间代码生成 为了实现函数，我们需要设计两条中间代码指令，分别表示设置参数和函数，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 PARAM T0 将 T0 设置为下一个参数 CALL LABEL 调用函数 LABEL 假设我们有若干个参数，可以依次使用 PARAM 命令将它们加入参数列表。在调用函数时，这些参数的值会自动依次按顺序装载到临时变量 _T0, _T1 ... 中。比如我们有这样一段 TAC 程序： PARAM A PARAM B PARAM C XX = CALL XXX 那么，在进入 XXX 函数时，相当于执行了： _T0 = A _T1 = B _T2 = C 因此，示例可以对应如下的 TAC 程序： func: _T2 = ADD _T0, _T1 return _T2 # 参数 x 和 y 分别对应 _T0, _T1 main: _T0 = 1 PARAM _T0 # 将 _T0 的值作为参数 x _T1 = 2 PARAM _T1 # 将 _T1 的值作为参数 y _T3 = CALL func # 调用函数 return _T3 同学们可以使用这种参考的实现形式，也可以自行思考传参的处理方法。 在 step9 之后，C++ 框架中出现了新的三地址码指令（PARAM、CALL等），因此你需要参考 tac/dataflow.cpp 文件开始的注释修改相应指令的数据流信息，具体的修改方式取决于你定义的三地址码指令的输入和输出特点。 目标代码生成 接下来详细介绍函数调用的步骤和约定，以及函数调用及返回过程中栈帧的变化。 函数调用 程序代码里的一个函数调用，包含了下面一系列的操作： 准备参数，完成传参。 （汇编）保存 caller-saved 寄存器。 执行汇编中的函数调用指令，开始执行子函数直至其返回。 （汇编）回复 caller-saved 寄存器。 拿到函数调用的返回值，作为函数调用表达式的值。 上述步骤 1-5 称为调用序列（calling sequence）。然而，调用序列中有一些问题需要解决：如何进行参数传递？如何获取函数返回值？调用者（caller）和被调用者（callee）需要保存哪些寄存器，如何保存？调用者和被调用者通常对以上问题约定解决方式，并同时遵守这些约定。这些调用者与被调用者共同遵守的约定称为调用约定（calling convention）。调用约定通常在汇编层级使用，汇编语言课上也有涉及。因为汇编语言是低级语言，缺乏对函数的语言特性支持，只有标号、地址、寄存器，所以需要调用约定，规定如何用汇编的语言机制模拟函数调用。 调用约定 如上所述，调用约定是 caller 和 callee 之间的一种约定。因此，调用约定并不唯一，只要 caller 和 callee 之间的调用约定相同，函数调用就可以顺利进行。在课程实验文档中，我们将给出两种参考的调用约定：一种是 gcc 使用的 32 位 RISC-V 标准调用约定，一种是简化之后的非标准调用约定。 需要说明的是，实验测例中没有与 gcc 编译的文件相互调用的要求，因此，大家实现简化版的调用约定即可。但是，如果对自己的编译器要求较高（比如，希望与用 gcc 编译所得的目标文件一起链接并进行相互的函数调用），那么就需要实现标准调用约定。 RISC-V 的标准调用约定（gcc 使用的、和 MiniDecaf 相关的） caller-saved 和 callee-saved 寄存器 上表给出 RISC-V 中 32 个整数寄存器的分类。所谓 caller-saved 寄存器（又名易失性寄存器），是指不需要在各个调用之间保存的寄存器，如果调用者认为在被调用函数执行结束后仍然需要用到这些寄存器中的值，则需要自行保存。所谓 callee-saved 寄存器（又名非易失性寄存器），指这些寄存器需要在各个调用之间保存，调用者可以期望在被调用函数执行结束后，这些寄存器仍保持原来的值。这要求被调用者，如果使用这些寄存器，需要先进行保存，并在调用返回之前恢复这些 callee-saved 寄存器的值。 具体的保存方法并不限制，但一般都使用栈来保存。 函数参数以及返回值的传递 函数参数（32 位 int）从左到右存放在 a0 - a7 寄存器中，如果还有其他参数，则以从右向左的顺序压栈，第 9 个参数在栈顶位置。同学们可以使用编写一个带有多个参数的函数并进行调用，然后用 gcc 编译程序进行验证。 返回值（32 位 int）放在 a0 寄存器中。 简化版的非标准调用约定 caller-saved 和 callee-saved 寄存器 callee 只需要保存 fp 和 ra 寄存器。其中 fp 寄存器中存储调用者栈帧的栈底地址，用于在函数调用结束之后恢复调用者的栈帧，ra 寄存器保存函数返回地址。程序实验框架中提供了数据流分析模块，caller 只需保存活跃变量对应的寄存器内容（数据流分析和活跃变量见 step7）。 函数参数及返回值的传递 不使用寄存器进行传参，所有参数从右往左压栈，第 1 个参数在栈顶。 返回值（32 位 int）放在 a0 寄存器中。 函数调用过程中的栈帧变化（使用非标准调用约定） 为了帮助大家更好的理解，我们使用上述的简化版的非标准调用约定，画出了一段具有代表性的程序，其整个运行过程中栈帧的组成部分以及变化。代表性程序如下： int bar (int x, int y) { return x + y; } int foo () { int a = 1; int b = 2; int c = foo(a, b); // return a+c 的目的是为了讲解保存活跃变量的情况 return a + c; } （1） foo 函数被调用，栈帧建立，变量 a 与 b 被分配对应寄存器。 （2）调用 bar 函数，由于变量 a 在函数调用结束之后还需要被使用（a+c），是活跃变量，需要保存到栈中。另外，按照调用约定对函数参数进行压栈传参。 （3）bar 函数内部进行运算，主要关注寄存器变化，栈帧方面仅仅是建立了 bar 函数的栈帧。 （4）bar 函数调用返回，其栈帧被销毁。 （5）foo 函数调用返回，其栈帧被销毁。 思考题 TODO "},"docs/step9/spec.html":{"url":"docs/step9/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step9 语法规范 灰色部分表示相对上一节的修改。 program : function* function : type Identifier '(' parameter_list ')' compound_statement type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier 我们暂不要求支持不包含函数体的函数声明。 step9 语义规范 9.1 在函数调用中，实参和形参的参数个数必须相同，同一位置的参数类型也必须相同。 9.2 在准备函数的调用时，所有的实参会被求值，然后赋给相应位置上的形参。 在函数体中，形参的值可能会被改变，但即便实参是一个可修改的左值，被调用函数中形参的改变也不会影响实参的值。 9.3 函数是可以递归调用的。 9.4 （更新 5.10）执行一条 return 语句，意味着终止当前函数的执行，并将控制权交还给调用当前函数的 caller，语句中的表达式的值会返还给 caller 作为函数调用的表达式的值。一个函数可以有任意多条 return 语句。 9.5 函数的形参可以被视为在函数体的开头被定义（被以实参的值初始化）的局部变量。所有形参均为左值，且不能被在函数体中直接重定义（除非是在一个更小的嵌套的块中）。 例如，int f(int x) { int x; } 不合法，但 int f(int x) { { int x; } } 合法。 9.6 如果一个不是 main 的函数执行到了它的 }，且其返回值被 caller 所使用，则这是一个未定义行为。 对于感兴趣的同学：C 语言中规定只有使用了返回值才是未定义行为，而 C++ 中规定不管返回值有没有被使用，都是未定义行为。 我们没有支持 void 类型，但可以忽略返回值达到类似的效果。 “执行到了 }” 意味着执行时没有通过 return 返回，例如 int f(){if(0) return 0;}。 实现的时候，你可以直接让所有函数都默认返回 0，语义规范说 main 之外的函数没有 return 是未定义行为，未定义行为的意思就是你想怎么处理都可以，所以全部默认返回 0 当然也是可以的，而且更清晰简单。 "},"docs/step10/intro.html":{"url":"docs/step10/intro.html","title":"任务概述","keywords":"","body":"实验指导 step10：全局变量 step10 我们要支持的是全局变量，语法改动非常简单： program : (function | declaration)* 全局变量和局部变量不同，它不是分配在栈上，而是放在某个固定地址，写在汇编的 .bss 段或 .data 段里。 访问它也不能通过 fp 加偏移量，而是需要通过它的符号加载它的地址，通过它的地址访问它。 汇编课上应该讲过，实际中（包括 gcc 和 qemu）使用的可执行文件的格式是 ELF（Executable and Linking Format）。 .text 是其中存放代码的段（section），.bss 和 .data 都是其中存放数据的段，前者零初始化后者须指定初始值。 对有兴趣的同学： 全局变量地址不是被狭义上的编译器（compiler）确定的，也不是被汇编器（assembler）确定的，而是被链接器（linker）或加载器（loader）确定的。 简单的说，狭义上的编译器把源代码变成文本汇编，汇编器把文本汇编给编码到二进制代码，然后通过链接器变成可执行文件，运行时由加载器加载到内存中运行。 当然，广义上的编译器就囊括了这所有阶段。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step10/example.html":{"url":"docs/step10/example.html","title":"通过例子学习","keywords":"","body":"step10 实验指导 本实验指导使用的例子为： int x = 2021; int main() { return x; } 词法语法分析 针对全局变量，我们需要新设计 AST 节点来表示它，只需修改根节点的孩子类型即可：原先表示整个 MiniDecaf 程序的根节点只能有函数类型的子节点，现在还可以允许变量声明作为子节点。 语义分析 本步骤引入全局变量，在引入全局变量之后，AST 根结点的直接子结点不只包括函数，还包括全局变量定义。全局变量符号存放在栈底的全局作用域符号表中。在遍历 AST 构建符号表的过程中，栈底的全局作用域符号表一直都存在，不会被弹出。 中间代码生成 经过 Step5 的学习，我们知道局部变量是存储在寄存器或栈中的，可以直接访问。然而，全局变量存储在特别的内存段中，不能直接访问。课程实验建议的加载全局变量方式为：首先加载全局变量符号的地址，然后根据地址来加载数据。因此，需要定义两个中间代码指令，完成全局变量值的加载： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 LOAD T1, offset 临时变量 T1 中存储地址，加载与该地址相差 offset 个偏移的内存地址中的数据 LOAD_SYMBOL symbol symbol 为字符串，加载 symbol 符号所代表的地址 有了上述两条指令，可以将测试用例翻译如下： main: _T0 = LOAD_SYMBOL x _T1 = LOAD _T0, 0 return T1 需要说明的是，你也可以把两条指令合并为一条指令，直接加载全局变量的值，但分为两条指令的方式可扩展性更好些。 请注意，翻译所得的 TAC 代码中没有为全局变量赋予初始值（2021）。可以将变量的初始值存放在变量符号对应的符号表里，在后端代码生成时通过读取符号表得到初值。此处给出的只是一种参考实现，大家也可以将全局变量的定义显式翻译为 TAC 代码，这样可以使中端与后端完全解耦。 在 step9 之后，C++ 框架中出现了新的三地址码指令（PARAM、CALL等），因此你需要参考 tac/dataflow.cpp 文件开始的注释修改相应指令的数据流信息，具体的修改方式取决于你定义的三地址码指令的输入和输出特点。 目标代码生成 Step10 中目标代码生成的主要任务有：翻译中间代码，将全局变量放到特定的数据段中。 翻译中间代码 实际上，我们提供的中间代码设计和 RISC-V 汇编的思想是一致的，RISC-V 汇编中有对应 LOAD 和 LOAD_SYMBOL 的指令，我们直接给出翻译结果： main： la t0, x # _T0 = LOAD_SYMBOL x lw t1, 0(t0) # _T1 = LOAD _T0, 0 mv a0, t1 ret 将全局变量放到特定的数据段中 到目前为止，翻译中间代码的方式是有问题的，问题在于，需要加载的 x 变量符号究竟存在哪里，如果所生成的汇编程序不给出 x 的定义，程序是有bug的。实际上，RISC-V 提供了一系列的汇编指令，用以声明全局变量 x 所对应的数据段。 下面给出 RISC-V 用以全局变量声明的汇编指令，其他全局变量的声明只需修改变量名称和初始值即可： .data .globl x x: .word 2021 上例中，.data 表示输出到 data 数据段；.globl x 声明 x 为全局符号；.word 后是一个 4 字节整数，是 x 符号对应的初始值。 按照汇编约定，data 段中存放已初始化的全局变量，未初始化的全局变量则存放在 bss 段中。举例而言，下面的示例将未初始化的全局变量 x 存放到 bss 段中。其中，.space 表示预留一块连续的内存，4 表示存储空间大小为 4 字节。 .bss .globl x x: .space 4 思考题 TODO "},"docs/step10/spec.html":{"url":"docs/step10/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step10 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' compound_statement type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step10 语义规范 10.1 对于全局变量的初始化，我们仅对初始化表达式是整数字面量的情况做要求（例如 2123），对初始化表达式是非字面量的情况不做任何要求（例如 a 或 f() 或 2+3）。 C 其实也支持非字面量的编译期常量，例如 int a=1+3;。编译器可以计算出 1+3==4 然后让它等价于 int a=4;。 但为了实现简便，我们就不要求支持这点。 C 不允许 int a=f(); 因为 f() 不是编译器常量； 而 C++ 甚至可以支持 int a=f();，其大致实现为 int a=0; 然后在 main 之前执行的初始化函数中 a=f();。 10.2 我们对全局变量的重复声明不做任何要求或限定；但全局变量不能被重复定义，即不能有同名的被初始化的全局变量。 int a; int a=2; int a; int main(){ return a;} 是合法的 C 代码，不过不是合法的 C++ 代码，也许 C++ 的处理方式更符合你的直觉。 为了简单，我们不要求这点。比如对于形如 int a; int a=2; 或 int a; int a; 的代码片段，你可以以任意方式处理。 10.3 如果一个全局变量没有被初始化，我们认为其拥有一个默认初始值 0。 "},"docs/step11/intro.html":{"url":"docs/step11/intro.html","title":"任务概述","keywords":"","body":"实验指导 step11：数组 step11 的目标是支持数组： 语法上没有太大改动， 数组的声明： declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' 数组的下标操作 postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' step11 难度不大，但有了数组让我们能够写很多有意思的程序了，step11 之前甚至 MiniDecaf 连快速排序都写不了。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step11/example.html":{"url":"docs/step11/example.html","title":"通过例子学习","keywords":"","body":"step11 实验指导 本实验指导使用的例子为： int x[10]; int main() { int y[10]; return 0; } 词法语法分析 针对数组，我们需要设计 AST 节点来表示它，给出的参考定义如下： 节点 成员 含义 IndexExpr 索引基底 base，索引下标 index 索引运算 语义分析 由于 Step11 里引入了数组，现在我们的变量类型不只是 int 型了，还包括 int 型数组。因此，为了保证所有表达式中变量的类型均合法，需要进行类型检查。 Python 框架 frontend/type/array.py 里实现了数组类型，同学们可以使用它完成实验，也可以自行对其进行修改。 C++ 框架 type/type.hpp 中的 ArrayType 表示数组类型，同学们可以使用它完成实验，也可以自行对其进行修改。 中间代码生成 数组和普通变量类似，可以分为局部数组和全局数组。 全局数组的处理与全局变量类似，由于是升级关卡，我们留给同学自行思考（和全局变量究竟有什么不同，是不是需要的内存空间更大？提示：1. 需要申请更大的 bss 段内存）。 针对局部数组，给出一种参考实现，实际上不只存在一种实现方法。实验文档给出一种参考实现方法，定义了一条中间代码指令 ALLOC 用于分配内存空间： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 ALLOC size 分配 size 字节的内存，并返回内存首地址 采用 ALLOC 指令，测试样例中的局部数组部分代码可以翻译为如下中间代码（忽略全局数组部分）： main: T0 = ALLOC 40 # 一个 int 类型为 4 个字节 T1 = 0 return T1 通过这种方式，我们实际上是把内存分配的锅甩给了目标代码生成，这大大提升了目标代码生成的自由度，属于合理分锅。 除了分配数组，我们还需要考虑如何访问数组元素。通过 ALLOC 指令我们得到了数组的首地址，那么任何一个数组元素的地址可以通过在首地址的基础上加上偏移量得到。于是，读取数组元素可以使用 Step10 中引入的 LOAD 指令来实现，我们还需要引入一条类似的 STORE 指令将值写入数组元素。 那么，如何将数组下标对应到偏移地址？对一维数组，下标的常数倍（int 型的大小为 4 个字节，倍数为4）即为偏移量。而对于高维数组，我们可以将其视为一个展开成一维的大数组。对于数组 a[d1][d2]...[dn]，访问元素 a[i1][i2]...[in] 可以等价于访问 a[i1d2d3...dn + i2d3...*dn + ... + in]。在将数组索引翻译成 TAC 时，同学们需要自行将数组下标转换成地址计算指令。这个步骤并不困难，但可能比较繁琐，同学们在实现时要注意细节，避免错误。 在 step9 之后，C++ 框架中出现了新的三地址码指令（PARAM、CALL等），因此你需要参考 tac/dataflow.cpp 文件开始的注释修改相应指令的数据流信息，具体的修改方式取决于你定义的三地址码指令的输入和输出特点。 目标代码生成 同中间代码生成，全局数组自行思考实现。 对于局部数组的内存分配，推荐在栈上为局部数组分配所需的空间，实际上，Step5 栈帧中的局部变量区域，可以用于存储局部数组。因此，大家需要模仿新建栈帧的操作，对栈顶指针 sp 进行修改，在栈上开辟出一块连续内存，并将这块内存的首地址返回即可。后续如有对数组中元素的访问，基于首地址进行偏移操作即可。 思考题 TODO "},"docs/step11/spec.html":{"url":"docs/step11/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step11 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' compound_statement type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step11 语义规范 11.1 一个数组类型描述了一组被连续分配在一段内存空间中的对象，所有对象都具有相同的类型（我们称之为元素类型）。数组类型包含两部分：元素类型，和数组的长度（即元素数量）。数组类型的表达式仅能参与下标运算。 11.2 我们仅要求支持固定长度的数组，即在数组的声明中，其长度是一个正整数字面量。 所以，我们不要求支持变长数组 int a[n]; 或不定长数组 int a[];。 11.3 我们不要求支持数组的初始化。 C 中可以写 int a[2]={1, 2}，但简单起见，我们不做要求。 由于我们不要求数组的初始化，根据 5.5，作为局部变量的数组中的元素初始值未定；根据 10.3，作为全局变量的数组中的元素初始值为 0。 11.4 对于下标运算 a[b]，要求 a 是一个数组类型，b 是一个整数类型，a[b] 是 a 中的第 b 个元素（从 0 开始计数）。 11.5 下标运算越界是未定义行为。 即便是类似 int a[4][5]; a[1][7] 这种，同样也是未定义行为。 "},"REFERENCE.html":{"url":"REFERENCE.html","title":"参考资料","keywords":"","body":"参考资料 Writing a C Compiler: by Nora Sandler An Incremental Approach to Compiler Construction : by Abdulaziz Ghuloum Monkey: The programming language that lives in books C17 标准草案 N2176（N2176 是 C17 标准正式发布前的最后一版草案，根据 C17 标准的编者之一 Jens Gustedt 的博文，其与 C17 标准相比只有表述上的差异） RISC-V 手册 RISC-V（非官方）汇编指令用法 "}}