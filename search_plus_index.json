{"./":{"url":"./","title":"实验简介","keywords":"","body":"MiniDecaf 编译实验 实验手册指北：实验文档看起来会有一些长，是因为编译器本身就是一个庞大的系统，我们希望提供尽可能全面的内容来帮助大家理解框架的构成。请大家认真阅读文档，并且尽可能按照文档去动手试一试，而不是直接开始动手写作业。 实验概述 MiniDecaf 1 是一个 C 的子集，去掉了include/define等预处理指令，多文件编译支持，以及结构体/指针等语言特性。 本学期的编译实验要求同学们通过多次“思考-实现-重新设计”的过程，一步步实现从简单到复杂的 MiniDecaf 语言的完整编译器，能够把 MiniDecaf 代码编译到 RISC-V 汇编代码。进而深入理解编译原理和相关概念，同时具备基本的编译技术开发能力，能够解决编译技术问题。MiniDecaf 编译实验分为多个 stage，每个 stage 包含多个 step。每个 step 大家都会完成一个可以运行的编译器，把不同的 MiniDecaf 程序代码编译成 RISC-V 汇编代码，可以在 QEMU/SPIKE 硬件模拟器上执行。随着实验内容一步步推进，MiniDecaf 语言将从简单变得复杂。每个步骤都会增加部分语言特性，以及支持相关语言特性的编译器结构或程序（如符号表、数据流分析方法、寄存器分配方法等）。下面是采用 MiniDecaf 语言实现的快速排序程序，与 C 语言相同。 int qsort(int a[], int l, int r) { int i = l; int j = r; int p = a[(l+r)/2]; while (i p) j = j - 1; if (i > j) break; int u = a[i]; a[i] = a[j]; a[j] = u; i = i + 1; j = j - 1; } if (i l) qsort(a, l, j); return 0; } 2024 年秋季学期基本沿用了 2023 年秋季学期《编译原理》课程的语法规范。为了贴合课程教学内容，提升训练效果，课程组设计了比较完善的编译器框架，包括词法分析、语法分析、语义分析、中间代码生成、数据流分析、寄存器分配、目标平台汇编代码生成等步骤。每个 step 同学们都会面对一个完整的编译器流程，但不必担心，实验开始的几个 step 涉及的编译器框架知识都比较初级，随着课程实验的深入，将会循序渐进地引入各个编译器功能模块，并通过文档对相关技术进行分析介绍，便于同学们实现相关编译功能模块。 从2023年起，课程组增加了大实验环节，大实验是一个可选环节。可以参考大实验参考文档获取更多信息。 实验起点和基本要求 本次实验一共设置 13 个步骤（其中 step 0 和 step 1 为实验框架熟悉，不需要修改框架代码）。后续的 step 2-13 我们将由易到难完成 MiniDecaf 语言的所有特性，由于编译器的边界情况很多，你只需通过我们提供的正例与负例即可。 我们以 stage 组织实验，各个 stage 组织如下： 第一个编译器（step0-step1）。我们给的实验框架可以通过所有测试用例，你需要做的事情为跟着文档阅读学习实验框架代码。请各位同学注意，stage0 尤为重要，掌握好实验框架是高质量和高效率完成后续实验的保证。 常量表达式（step2-step4）。在这个 stage 中你将实现常量操作（加减乘除模等）。 变量和赋值（step5）。在这个 stage 中你将第一次支持变量声明与赋值。 作用域和块语句（step6）。在这个 stage 中你的编译器将支持作用域，以便支持后续的条件和循环。 条件和循环（step7-step8）。在这个 stage 中你将支持条件判断和循环语句，此时，你的编译器可以编译的程序就从线性结构程序到了有分支结构的程序。 函数（step9）。在这个 stage 中你将支持函数的声明和调用，这样你就可以写很多有意思的代码了。 全局变量和数组（step10-step12）。在这个 stage 中，你将支持全局变量和数组，数组中包括全局数组和局部数组。 寄存器分配算法（step13）。在这个 stage 中，你将实现基于图染色的寄存器分配算法，替代当前框架中简单的启发式算法。 其中，stage0 为环境配置和框架学习，无需进行编程，不计入成绩。 stage1 - stage5 为 5 个基础关卡，你需要通过它们以拿到一定的分数（35%）。 stage6 为升级关卡，如果你学有余力，完成它们可以减少期末考试在总评中所占的比重（完整完成可以获得占总评 7% 的成绩并替代期末考试对应权重）。 stage7 为进阶关卡，如果你依然学有余力，你可以在这里实现一些编译优化（完整完成可以获得占总评 8% 的成绩并替代期末考试对应权重）。注意，你需要在完成 stage6 后才能尝试 stage7，否则无法获得对应分数。 我们以 step 组织文档，每个 step 的文档都将以如下形式组织：首先我们会介绍当前 step 需要用到的知识点，其次我们会以一个当前 step 具有代表性的例子介绍它的整个编译流程。在之前 step 中已经介绍的知识点，我们会略过，新的知识点和技术会被详细介绍。 我们通过问答墙来集中解决大家在环境配置及完成实验中遇到的问题。如果你遇到了任何问题，都可以在问答墙中检索；如果你的问题尚未有其他人提问过，欢迎向助教提问，助教会尽快回复的。 诚信守则 请注意，诚信守则是参加本课程的学生应遵守的道德行为规范。实验指导中给出的生成结果（抽象语法树、三地址码、汇编）只是一种参考的实现，同学们可以按照自己的方式实现，只要能够通过测试用例即可。但是，严格杜绝抄袭现象，如果代码查重过程中发现有抄袭现象，抄袭者与主动提供抄袭信息的被抄袭者将被记为0分。 实验提交 大家在网络学堂提交 git.tsinghua.edu.cn 的帐号名后，助教会给每个人建立一个私有的仓库，URL 为 https://git.tsinghua.edu.cn/compiler24/stu24/minidecaf-你的学号 ，将作业提交到那个仓库即可。 每个 stage 会对应于一个 branch，当切换到一个新的 branch 上实现时，你可以用 git checkout -b 来创建一个新的分支。 本学期我们使用清华大学代码托管服务（git.tsinghua）的 CI（持续集成）来测试大家的代码实现及提交实验报告。 .gitlab-ci.yml 中描述了如何运行 CI，你不允许修改此文件； prepare.sh 是在测试前会运行的准备脚本，包括安装所需的依赖（python），如果你想添加新的依赖或者修改编译流程，请修改此文件。 在 CI 中会检查是否通过所有测例及是否有提交报告，只有通过所有测例且提交报告，才会被视为通过 CI。 我们只接受 pdf 格式的实验报告。你需要将报告放在仓库的 ./reports/.pdf 路径，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 ./reports/stage-1.pdf。 实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 评分标准 对于每个阶段（stage）： 80% 的成绩是自动化测试的结果，你可以直接在 git.tsinghua 的 CI 测试中看到。 20% 的成绩是实验报告，其中对实验内容的描述占 10%，对思考题的回答占 10%。 评分会以每个 stage 的 branch 最后一次触发的 CI 及触发此次 CI 的 commit 里的实验报告为准，详见补交政策。 如果你认为成绩有问题，请及时与助教联系。 时间安排及补交政策请看实验进度安排。 学术规范 由于实验有一定难度，同学之间相互学习和指导是提倡的。 对于其他同学的代码（包括实验报告中思考题的回答），可以参考，但禁止直接拷贝。 如有代码交给其他同学参考，必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 请所有同学不要将自己的代码托管至任何公开的仓库上（如 GitHub），托管至私有仓库的请不要给其他同学任何访问权限。 我们将会对所有同学的代码作相似度检查，如发现有代码雷同的情形，拷贝者和被拷贝者将会得到同样的处罚，除非被拷贝的同学提交时已做过声明。 代码雷同情节严重的，课程组有权上报至院系和学校，并按照相关规定严肃处理。 相关资源 实验指导书（首页有实验报告提交要求） 实验指导书勘误表 课程问答墙 实验思路指导与问答墙 参考资料 Writing a C Compiler: by Nora Sandler nqcc http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf 备注 1. 关于名字由来，由于往年的实验叫 Decaf，我们在新的且更简单的语言规范下复用了 Decaf 的编译器框架，所以今年的实验就叫 MiniDecaf 了。 ↩ "},"docs/misc/schedule.html":{"url":"docs/misc/schedule.html","title":"实验进度安排","keywords":"","body":"实验进度安排 所有截止时间均为所标日期的23:59:59（UTC+8），即第二天0点之前，如有特殊情况将会在网络学堂通知。 必做部分： 第三周周日（9.29）：Stage 0 截止 熟悉框架和基础知识 （占比：0%） stage 0 不需要你编写任何代码，stage 0的思考题请与stage 1一起提交。 第四周周日（10.6）：Stage 1 截止 常量表达式（占比：7%） 第六周周日（10.20）：Stage 2 截止 变量（占比：7%） 第八周周日（11.3）：Stage 3 截止 作用域（占比：7%） 第十周周日（11.17）：Stage 4 截止 控制语句（占比：7%） 第十四周周日（12.15）：Stage 5 截止 函数（占比：7%） 函数部分由于难度较大，给大家预留了四周时间，请大家不要等到最后一周再开始。 选做部分： 选做部分难度较大，且时间较紧，同学可能需要提前一些开始才能保证完成。 第十五周周日（12.22）：Stage 6 截止 全局变量和数组（占比：7%） 第十六周周日（12.29）：Stage 7 截止 寄存器分配与代码优化（占比：8%） 补交政策 假设 a 日 24:00 是某个 stage 的截止时间； a + k (k 提交/补交时间是该 stage 截止 10 天内这个 stage 的 branch 最后一次触发 CI 的时间； 更具体来讲是创建 pipeline 的时间，而不是 pipeline 更新的时间，这几乎等于你 push 到远端仓库的时间。并且，你也可以随意地 retry 反复运行 CI，这不会对你的提交/补交产生影响。 如果在多次 retry 中你的代码会得到不一致的结果，请联系助教。 选做实验不接受补交。 "},"docs/step0/errate.html":{"url":"docs/step0/errate.html","title":"勘误表","keywords":"","body":"勘误表 在这里我们会列出与实验相关的勘误，它会和问答墙上的勘误部分保持一致。同学们遇到问题时，请先在勘误表中查找查看是否已有解答。   Q：使用 pip install -r ./requirements.txt 命令无法正确安装依赖？ A：如果你安装了多版本的 python，使用 pip 命令未必会对应 3.9 版本的包管理器。请尝试使用 python3.9 -m pip install -r ./requirements.txt 安装依赖。   Q： 代码框架 step7 中，由 multi_nesting.c 生成的以下中间代码无法成功生成目标代码。 经过使用 print 法调试，发现是 _T1 所对应的寄存器在 return _T1 前就被释放了，后端会尝试到栈中寻找 _T1 并且不会找到，出现报错： utils.error.IllegalArgumentException: error: encounter a non-returned basic block 请问是后端实现上有问题，还是这一部分本来就需要我们自己修改呢？ A：代码框架的后端除了要修改指令选择部分之外，还需要修改基本块 CFG，可以参见 BruteRegAlloc 的注释里给出的提示。   Q：我怎样才能知道我的提交通过了所有测试用例？ A：可以通过本地测试或者通过 CI 结果可以判断是否通过了本阶段测例（不过你需要确保你的提交在对应的 branch 上，如 stage1 对应 stage-1 分支）。   Q：如何提交课程报告？ A： 请将实验报告以 pdf 格式提交到 git.tsinghua 自己的仓库中，放在仓库根目录下的 reports/.pdf，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 reports/stage-1.pdf。 最新的 CI 会检查是否通过所有测例及是否有提交报告，只有通过所有测例且正确地提交报告，才会算作 pass。 如果关于报告提交有任何问题，请及时联系助教。 "},"docs/ref/riscv.html":{"url":"docs/ref/riscv.html","title":"RISC-V 参考资料","keywords":"","body":"RISC-V相关内容补充 RISC-V官方资料 不建议阅读，太过冗长，这对于编译知识提升非常有限。 RISC-V 官方 请下载ISA Specifications (Ratified)中的Volume 1, Unprivileged Specification。 如果你时间充足，你可以阅读： Chapter 24 RV32/64G Instruction Set Listings Chapter 25 RISC-V Assembly Programmer’s Handbook 如何快速查询RISC-V指令 在线编译器 你可以使用Compiler Explorer (godbolt.org)来快速获得一个riscv指令的实现 在左边输入以下例子 int mod(int x, int y) { // 注意：此处不要直接写一个可以计算得到结果的式子 // 比如5 % 8会被编译器优化为5 return x % y; } 把右边的编译器选为RISC-V(32-bits)中的任何一个，在编译选项中写上-O2（减少不必要的指令生成），翻译一条指令看看效果。 本地编译器 你可以通过 gcc 编译如下程序来了解如何翻译逻辑非运算符到 RISC-V 汇编 riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 foo.c -S -O3 -o foo.s（记得加 -O3 或者 -O2 选项）： int foo(int x) { return !x; } 不出意外你会获得如下结果： foo: seqz a0,a0 ret "},"docs/step0/intro.html":{"url":"docs/step0/intro.html","title":"实验环境简介","keywords":"","body":"实验环境简介 2024年秋季学期，助教给大家提供了服务器。同学们可以选择使用我们已经配置好的机器，节省一定的时间花费。 服务器环境如下： Ubuntu 23.04 python 3.11.4 注意： 禁止大家在服务器上安装软件、运行与课程实验无关的程序或者破环系统环境。否则将有可能受到惩罚。 为了安全起见，服务器仅可通过校内网络访问。 服务器的地址、账号和密码会通过网络学堂发给大家，请登录网络学堂查收。 提示： 如何使用 ssh 登陆服务器？ ssh username@ip -p port # 假如你的账号为 2024000001，服务器 ip 地址为 192.168.1.1，端口为 223，则命令为： ssh 2024000001@192.168.1.1 -p 223 建议配置 ssh 免密登录，方便大家使用服务器，然后在服务器上运行。你可以参考这里。 vscode 也是可以使用ssh远程写代码的，参考这里。 如果你使用我们提供的服务器，你可以直接来看RISC-V 的工具链使用和运行实验框架。 "},"docs/step0/riscv_env.html":{"url":"docs/step0/riscv_env.html","title":"RISC-V 环境配置","keywords":"","body":"RISC-V 环境配置 必做：RISC-V 的 gcc 和 qemu 我们的编译器只生成 RISC-V 汇编，然后再使用 gcc 把 RISC-V 汇编变成 RISC-V 可执行文件，最后用 qemu/spike 等模拟器来运行 RISC-V 可执行文件。 注意这里的 gcc 和常说的 gcc 不一样。 常说的 gcc 运行在我们的 x86 机器上、把 C 编译到 x86 可执行文件； 而这里的 gcc 虽然也运行在我们的 x86 机器上，却要编译到 RISC-V 可执行文件。 这种“gcc 跑在 x86 却编译出 RISC-V 代码”的操作被称为交叉编译（cross compilation）。 因此我们不能直接使用有些系统自带的 gcc，这种 gcc 生成的可执行程序只能在你本机（x86）上运行。 我们需要下载安装 riscv64-unknown-elf-gcc，用来生成 RISC-V 可执行程序。 建议各位同学使用我们提供的 RISC-V 工具链，由 SiFive 预编译的较新版本的工具链对 32 位的支持存在问题。 我们提供了预编译的 riscv64-unknown-elf-gcc 和 qemu/spike 模拟器，不过只能在 Linux/Mac 下运行（qemu 对应 Linux，spike 对应 Mac），Windows 的同学可以使用 WSL，或者运行一个虚拟机。 命令行基础操作我们就不赘述了，大家可以自己在网上查找资料。 下面是环境配置指南，请阅读自己的系统的那一小节。 你的编译器 gcc qemu/spike MiniDecaf 源文件 ------------> RISC-V 汇编 -----> 可执行文件 --------> 输出 Windows 用户环境配置指南 下面描述了 WSL 的一种参考方法。 你还可以开一个 Linux 虚拟机，使用 Virtualbox 或 VMWare 等，然后参考下面 Linux 配置。 Win10 设置 参考 https://blog.csdn.net/daybreak222/article/details/87968078 ，设置“开发者模式”以及“启用子系统功能”。 打开Microsoft Store，搜索Ubuntu，选择ubuntu20.04. 按照下面的 Linux 用户环境配置指南安装 riscv 工具链。 Ubuntu 用户环境配置指南 建议使用 Ubuntu 20.04 及更高的版本，你可以直接使用 apt 来安装用户态的 qemu，即 apt install qemu-user。 如果使用的是低版本的 WSL，通过 Windows 应用商店可以很容易地安装 Ubuntu 20.04 LTS; 如果在机器上直接安装了较低版本的 Ubuntu, 可以参考这个教程进行升级，升级时注意备份。 如果出于某些原因必须使用低版本的 Ubuntu，你需要自己编译出可用的用户态 QEMU。 git clone https://mirrors.tuna.tsinghua.edu.cn/git/qemu.git cd qemu && ./configure --prefix=/usr/local --target-list=riscv32-linux-user make make install qemu-riscv32 --version # 检查是否安装成功 从这里下载预编译好的 RISC-V 工具链并解压。 安装工具链 cp riscv64-unknown-elf-gcc-10.1.0-2020.08.2-x86_64-linux-ubuntu14/* /usr/ -r 在第 2. 步，你可以选择不安装到系统目录下。相应的，你需要设置环境变量： 首先把文件夹riscv64-unknown-elf-gcc-10.1.0-2020.08.2-x86_64-linux-ubuntu14/改名为 riscv-prebuilt（这一步实际不是必须的，主要为缩短文件夹名字的长度），然后修改~/.bashrc 文件, 把export PATH=$PATH:/path/to/riscv-prebuilt/bin加入到.bashrc文件的末尾。注意，此处的/path/to 需要替换解压文件夹所在目录。每次修改.bashrc文件后，都需要执行命令source ~/.bashrc使修改生效。 （如果你不用系统自带的 bash 而是用 zsh 之类的 shell，那加到 ~/.zshrc 等 shell 配置文件里） macOS 用户环境配置指南 从这里下载预编译好的 RISC-V 工具链并解压到你喜欢的目录。 由于 macOS 不支持 QEMU 的用户态模式，我们使用 Spike 模拟器和一个简易内核 riscv-pk 提供用户态程序的运行环境。你可以选择下面两种安装方法中的任意一种： 从这里下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，不过还需要通过 Homebrew 安装依赖 device tree compiler： $ brew install dtc 通过 Homebrew 安装 Spike（会自动安装 dtc）： $ brew tap riscv/riscv $ brew install riscv-isa-sim 然后从这里上下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，只用里面的 pk。 Homebrew 也提供了 riscv-pk，不过那是 64 位的，而我们需要 32 位的，请使用我们预编译的 riscv-pk 或自行编译。 请注意我们提供的预编译 pk 是 x86 版本，如果你是其他平台（如M1 Mac），可以尝试自行根据 pk 的源码进行编译，附 Github 仓库链接。 （可选）设置环境变量，方法与 Linux 一样，见上一节。如果不设置每次使用 gcc 和 spike 时都要输入完整路径。不过对于 pk 设置环境变量不管用，要么把它放到系统目录 /usr/local/bin/pk，要么每次都用完整路径。 测试你 GCC 和 Spike 是否成功安装，详见RISC-V 的工具链使用。 必做：测试你是否正确配置好了环境 创建 test.c 文件，其中写入如下内容 #include int main() { printf(\"Hello world!\\n\"); } 编译 test.c 文件，gcc 应该输出一个可执行文件 a.out。但 a.out 是 RISC-V 可执行文件，所以我们的 X86 计算机无法运行。 $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 test.c $ ls a.out a.out $ ./a.out # 如果没有安装qemu模拟器，则会出现如下错误:\"bash: ./a.out: cannot execute binary file: Exec format error\" 后面RISC-V 的工具链使用总结了 gcc 和 qemu 在编译实验中可能需要的用法。 使用 qemu 执行 a.out，具体操作如下 Linux用户 $ qemu-riscv32 a.out Hello world! 注意：安装了qemu之后，直接运行 ./a.out 往往也可以调用qemu环境正确执行，并得到\"Hello world!\"输出。 Mac OS用户，假设你已经将spike加入环境变量，将pk加入系统目录 $ spike --isa=RV32G pk a.out bbl loader Hello world! 备注 1. 开头的 $ 表示接下来是一条命令，记得运行的时候去掉 $。例如，让你运行 $ echo x，那你最终敲到终端里的是 echo x（然后回车）。如果开头没有 $，那么这一行是上一条命令的输出（除非我们特别说明，这一行是你要输入的内容）。 ↩ "},"docs/step0/riscv.html":{"url":"docs/step0/riscv.html","title":"RISC-V 的工具链使用","keywords":"","body":"RISC-V 相关信息 RISC-V 是一个很像 MIPS 的 RISC 指令集架构，编译实验要求你的编译器把 MiniDecaf 程序编译到 RISC-V 汇编。 指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"。 另外这里也有（非官方的）指令用法说明。 不过事实上，很多时候看 gcc 输出的汇编比看什么文档都有用。 RISC-V 工具使用 我们提供预先编译好的 RISC-V 工具，在环境配置中已经叙述了安装和使用方法。 下面汇总一下。 注意，我们虽然是用的工具前缀是 riscv64， 但我们加上参数 -march=rv32im -mabi=ilp32 以后就能编译到 32 位汇编 1。 使用时记得加这个参数，否则默认编译到 64 位汇编。 我们假设你已经正确设置好了环境变量，否则运行 riscv64-unknown-elf-gcc 或 qemu-riscv32 或 spike 时请用完整路径。 gcc 编译 input.c 到汇编 input.s，最高优化等级（否则输出的汇编会很冗长） # input.c 的内容 $ cat input.c int main(){return 233;} # 编译到 input.s $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c # gcc 的编译结果 $ cat input.s .file \"input.c\" .option nopic .attribute arch, \"rv32i2p0_m2p0\" .attribute unaligned_access, 0 .attribute stack_align, 16 .text .section .text.startup,\"ax\",@progbits .align 2 .globl main .type main, @function main: li a0,233 ret .size main, .-main .ident \"GCC: (SiFive GCC 8.3.0-2020.04.0) 8.3.0\" gcc 编译 input.s 到可执行文件 a.out # input.s 的内容，就是上面汇编输出的简化版本 $ cat input.s .text .globl main main: li a0,233 ret # 编译到 a.out $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 input.s # 输出结果，能看到是 32 位的 RISC-V 可执行文件 $ file a.out a.out: ELF 32-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped 【Linux 用户】qemu 运行 a.out，获取返回码 # 运行 a.out $ qemu-riscv32 a.out # $? 是 qemu 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 【macOS 用户】Spike 模拟器运行 a.out，获取返回码 # 运行 a.out # /usr/local/bin/pk 替换为你自己的 pk 路径 $ spike --isa=RV32G /usr/local/bin/pk a.out bbl loader # $? 是 spike 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 1. 这里的 rv32im 表示使用 RV32I 基本指令集，并包含 M 扩展（乘除法）。本实验中我们不需要其他扩展。 ↩ "},"docs/step0/env.html":{"url":"docs/step0/env.html","title":"实验框架环境配置","keywords":"","body":"实验框架环境配置 Python 实验框架环境配置 关于操作系统，助教推荐使用 Linux 环境（如 Ubuntu，Debain 或 Windows 下的 WSL 等），当然你也可以在类 Unix 系统环境（Mac OS）中进行开发。助教不推荐直接在 Window 中搭建开发环境。你需要安装或保证如下软件满足我们的要求： python >= 3.9 助教强烈建议使用类似 Miniconda 或venv的系统管理不同的Python环境。你可以方便地使用miniconda安装最新的Python版本，安装好之后使用pip安装依赖即可。 框架本身在 python 3.9 下进行开发，使用了 python 3.9 的新特性，请保证你所使用的 python 版本高于此版本。 如果你没有使用虚拟环境，可以参考下面的指导。Linux 环境下安装 Python 3 可以尝试如下命令： > sudo add-apt-repository ppa:deadsnakes/ppa > sudo apt update > sudo apt install python3 此外，如果安装了多个版本的 python，可以通过 update-alternatives 命令修改 python 版本使用的优先级，对所有服务器用户都有效，具体用法可参见这里。你可以通过此命令来检查当前优先的 Python3 版本： > python3 --version 框架里已经提供了需要的 python 包列表文件 requirements.txt，你可以通过 pip 命令安装下文提到的 python 依赖包 ply 和 argparse： $ python3 -m pip install -r ./requirements.txt argparse 框架使用了 argparse 以处理命令行参数。官方文档中提供了它的教程。 ply ply是一个自动生成词法分析器和语法分析器的工具，其中ply.lex为词法分析相关的模块而ply.yacc为语法分析相关。可以参考 ply 的文档。 助教在项目中使用 type hints，如果你习惯在 vscode 中进行开发的话同时推荐使用 pylance 这一插件。 由于 python 的跨平台性，理论上也可以在 Windows 下进行开发。但不保证Windows和在线测试环境下程序行为的一致性。 "},"docs/step0/testing.html":{"url":"docs/step0/testing.html","title":"运行实验框架","keywords":"","body":"运行实验框架 配好环境以后，我们强烈推荐你构建运行我们提供的实验框架初始代码。 接下来我们会用到 git。 git 的安装和使用会在软件工程课上讲述，同学们也自行查阅相关资料，也可以参考这里 。 按照本文档的前几节（RISCV 环境配置和实验框架环境配置）配置好实验环境。 助教已经为每位同学在 git.tsinghua.edu.cn 创建了一个仓库，其中 minidecaf 的测例仓库为其中的一个子模块，你可以通过以下指令来在克隆主仓库的同时克隆子模块 git clone --recursive 。 由于测例仓库会有所更新，在克隆之后你需要在主仓库目录下使用 git submodule update --remote --merge 来手动更新。 注意：由于子模块使用 ssh 链接，你需要将你的 ssh 公钥添加到你的 git.tsinghua 账号上，才能将其克隆下来。 按照测例的 README 运行测试 step1，实验框架给出的初始代码可以通过 step1 的所有测例。 测试运行的 输出结果 大致如下。 $ STEP_UNTIL=1 ./check.sh gcc found qemu found parallel found OK testcases/step1/multi_digit.c OK testcases/step1/newlines.c ...... 其他测试点，太长省略 "},"docs/step1/arch.html":{"url":"docs/step1/arch.html","title":"MiniDecaf 编译器结构","keywords":"","body":"MiniDecaf 编译器结构 MiniDecaf 编译器大致划分为三个部分：前端、中端、后端。通过编译器前端，可以读入 MiniDecaf 源程序，然后通过词法分析和语法分析将源程序转化为一个抽象语法树(Abstract Syntax Tree, AST)，接下来通过扫描 AST 进行语义分析，检查是否存在语义错误；在编译器中端，通过扫描 AST 生成中间代码 —— 三地址码；在编译器后端中，将三地址码转换为 RISC-V 汇编代码。下面依次介绍上述编译步骤，以及对应框架代码的位置。 我们在这里针对每个步骤只是简要介绍，目的是给同学们一个大致的印象：编译器到底是由哪些部分组成的，这些部分又有什么作用。具体的技术点，我们将在用到的 step 作详细介绍。 词法分析和语法分析 此部分对应框架源码位置： 词法分析程序位于 frontend/lexer/；语法分析程序位于 frontend/parser/；语法树位于 frontend/ast/。 编译器前端分为两个子任务，一是词法分析，二是语法分析。词法分析的功能是从左到右扫描 MiniDecaf 源程序，识别出程序源代码中的标识符、保留字、整数常量、算符、分界符等单词符号（即终结符），并把识别结果返回给语法分析器，以供语法分析器使用。语法分析的功能是在词法分析的基础上针对所输入的终结符串建立语法树，并对不符合语法规则的 MiniDecaf 程序进行报错处理。一般而言，这一步所生成的语法树并非表示了所有语法细节的语法分析树，而是只表示其树形结构的抽象语法树（Abstract Syntax Tree, AST）。比如，对于下面这一段简单的MiniDecaf 代码： if (i) i = 1; 它对应的完整语法分析树可能长这样： if_stmt |- \"if\" |- \"(\" |- Identifier(\"i\") |- \")\" |- assign_stmt |- Identifier(\"i\") |- \"=\" |- Int(1) |- \";\" 其中双引号下的和大写字母开头的都为词法分析器产出的终结符。而对应的抽象语法树可能长这样： if_stmt |- (condition) Identifier(\"i\") |- (body) assign_stmt |- (lh) Identifier(\"i\") |- (rh) Int(1) AST省略掉了完整的语法分析树中不必要的细节（例如条件表达式旁边的括号），有利于简化树的结构与后续对树的处理。 词法分析和语法分析的最终结果是一棵跟所输入的 MiniDecaf 源程序相对应的语法树。本阶段的实验重点是掌握 LEX 和 YACC 的用法，了解编译器自动构造工具的特点，并且结合实验内容理解正规表达式、自动机、LALR(1) 分析等理论知识在实践中的应用。 语义分析 此部分对应框架源码位置： 符号表构建位于 frontend/typecheck/namer.py；类型检查位于 frontend/typecheck/typer.py；符号表相关的数据结构位于frontend/symbol/；作用域相关数据结构位于 frontend/scope/。 语法分析树的建立可以说明所输入的 MiniDecaf 源程序在语法规范上是合法的，但是要进行有效的翻译，编译器还需要理解每个程序语句的含义。了解程序含义的过程称为语义分析。 可以把语义分析过程分为两个部分：分析符号含义和检查语义正确性。分析符号含义是指对于表达式中所出现的符号，找出该符号所代表的内容，这个工作主要通过检索符号表来实现。检查语义正确性指的是检查每条语句是否合法，比如检查每个表达式的操作数是否符合要求，每个表达式是否为语言规范中所规定的合法的表达式，使用的变量是否都经过声明等。程序代码通过了词法和语法分析，其语义未必正确，因此未必是合法的语句。不合法的语句的具体含义在语言规范中没有规定，从而使得编译器无法确定这些语句的确切含义，所以检查语义的正确性是很有必要的。如果一个程序成功通过语义分析，则说明这个程序的含义对于编译器来说是明确的，翻译工作可以继续进行。 具体来说，在这一阶段中，我们需要对 AST 进行两遍扫描，分别完成以下的检查： 符号表构建：声明了哪些标识符，待编译程序使用的标识符对应于哪个位置的声明。 类型检查：各语句和表达式是否类型正确。 如果在语义分析阶段发现错误，那么整个编译过程在这一阶段结束后将终止，并报告编译错误。所有的语义错误都应该在这一阶段，且只应该在这一阶段报告。下面分别介绍符号表构建和类型检查的内容。 符号表构建 针对 MiniDecaf 程序中所有定义的标识符，包括函数名和变量名，我们统一用一种具有层次结构的符号表来维护。使用符号表的好处包括：(1) 在分析各语句和表达式时，若它们引用了某些标识符，我们可以在符号表中查询这些标识符是否有定义以及相关信息（如类型）；(2) 符号表的层次结构与作用域是一一对应的，便于检查出符号定义是否有冲突，以及确定不同作用域引用的标识符。 step1-4 中只需要考虑常量的计算，直到 step5 才需要考虑符号表构建。 类型检查 完成符号表构建后，我们就可以自顶向下地遍历 AST，对每个语句和表达式逐一进行类型检查，并在 AST 上进行类型标注。对于静态类型（statically-typed）语言，在语言设计之初，设计者都会考虑该语言支持表达哪些类型，并给出定型规则（typing rules）。 在已知定型规则的情况下编码实现类型检查算法并不困难——往往只要逐条将其翻译为代码即可。 事实上，由于 MiniDecaf 代码的基本类型只有整数类型（int），因此我们在类型检查时只需要考虑 int 和 int 数组两种类型。在支持数组（step11）之前，都基本不需要考虑类型检查。 中间代码生成 三地址码定义位于 utils/tac/；中间代码生成位于 frontend/tacgen/tacgen.py。 在对 AST 进行语义分析后，我们将在这一阶段把带有类型标注的 AST 翻译成适合后端处理的一种中间表示。中间表示（也称中间代码，intermediate representation / IR）是介于语法树和汇编代码之间的一种程序表示。 它不像语法树一样保留了那么多源程序的结构，也不至于像汇编一样底层。 由于源语言（MiniDecaf）和目标语言（RISC-V 汇编）一般存在较大的差别，因此直接把源语言翻译为目标语言中的合法程序通常是比较困难的。大多数编译器实现中所采取的做法，是首先把源语言的程序翻译成一种相对接近目标语言的中间表示形式，然后再从这种中间表示翻译成目标代码。中间表示（IR）的所带来的优势如下： 通过把 AST 到汇编的步骤一分为二，缩小调试范围。如果目标代码有误，通过检查 IR 是否正确就可以知道：是 AST 到 IR 翻译有误，还是 IR 到汇编翻译有误。 将 AST 转换到汇编的过程分成两个步骤，每个步骤代码更精简，更易于调试。 通过 IR 可以适配不同指令集（RISC-V, x86, MIPS, ARM...）和源语言（MiniDecaf, C, Java...）。由于不同源语言的 AST 不同，直接从 AST 生成汇编的话，为了支持 N 个源语言和 M 个目标指令集，需要写 N * M 个目标代码生成模块。如果有了 IR，只需要写 N 个 IR 生成器和 M 个汇编生成器，只有 N + M 个模块。 接下来，将对我们所使用的中间代码 —— 三地址码 (TAC) 做简要介绍，后续的实验步骤中需要同学们添加恰当的三地址码指令来完成特定的功能。为了降低实验难度，给出部分参考实现，各位同学可以依据参考实现完成设计，也可以自行设计三地址码。需要指出的是，我们使用的 TAC 并非严格按照课本上的定义，并且也没有严格要求只能使用三个寄存器地址，不过绝大多数指令均可以仅使用三个寄存器地址实现（函数调用除外）。 三地址码 三地址码（Three Address Code, TAC）看起来很像汇编，与汇编最大的区别在于 —— 汇编里面使用的是目标平台（如 risc-v, x86, mips）规定的物理寄存器，其数目有限；而 TAC 使用的是“虚拟寄存器”，我们称为临时变量，其数目不受限制，可以任意使用（这意味着直接将临时变量转化为寄存器可能会出现寄存器不够用的情况）。在后端生成汇编代码时，我们再考虑如何为临时变量分配物理寄存器的问题。 main: # main 函数入口标签 _T0 = 1 # 加载立即数 _T1 = _T0 # 临时变量赋值操作 _T2 = ADD _T0, _T1 # 加法操作 _T2 = _T0 + _T1 _T3 = NEG _T0 # 取负操作 _T3 = -_T0 return _T2 # 函数返回 以上给出了一份 TAC 示例程序。请注意 TAC 代码只是一种中间表示，并不需要像汇编语言那样有严格的语法。因此，同学们可以自由选择输出 TAC 代码的格式，只要方便自己调试即可。例如，你也可以将 _T2 = ADD _T0, _T1 输出成 _T2 = _T0 + _T1。 TAC 程序由标签和指令构成： 标签用来标记一段指令序列的起始位置。从底层实现的角度来看，每个标签本质上就是一个地址，且往往是某一段连续内存的起始地址。在我们的实验框架中，标签有两个作用：作为函数入口地址（如上例中的 main 函数入口），以及作为分支语句的跳转目标（TAC 指令不支持 MiniDecaf 语言中条件和循环控制流语句，而是将它们都翻译成更加底层的跳转语句）。 TAC 指令与汇编指令类似，每条 TAC 指令由操作码和操作数（最多3个，函数调用除外，由于函数参数可能有多个，使用严格的三个操作数反而会使得函数一节中实现更为复杂）构成。 操作数可能会有：临时变量、常量、标签（可理解为常量地址）和全局变量（全局变量的处理比较特殊，由于 step10 才需要考虑，届时再介绍其处理方法）。如上例所示，TAC 中的临时变量均用 \"_Tk\" 的形式表示（k表示变量的编号）。 TAC 程序是无类型的，或者说它仅支持一种类型：32位（4字节）整数。为了简化实验内容，MiniDecaf 只支持 int 类型和 int 数组类型，其值和地址都可以用一个32位整数存储，故 MiniDecaf 程序中的变/常量和 TAC 中的变/常量可以直接对应。 数组类型无法用临时变量直接表示，可以用一段连续内存的起始地址表示。其实现细节将在 step11 详细讨论。 控制流、数据流分析和寄存器分配 数据流图定义及优化在 backend/dataflow/ 中；寄存器分配在 backend/reg/ 中 控制流和数据流分析 一般来说，三地址码是可以直接翻译为目标代码的，但是这样的直接翻译会导致所产生的代码的效率比较差，所以多数编译器都会进行一定的优化工作。为了进行更深入的优化，编译器需要了解程序语义的更多内容，例如一个变量的某个赋值在当前指令中是否有效、一个变量在当前指令以后是否还会被使用、当前运算指令的两个操作数是否都能够在编译的时候计算出来、循环体中某些代码是否能够提出到循环外面、循环次数是不是编译的时候已知的常数等等，这些语义分析和代码优化离不开控制流分析和数据流分析。 所谓控制流分析，是指分析程序的执行路径满足什么性质，包括基本块划分、流图构造、以及分析循环或其他控制区域（region）。而所谓数据流分析，是指分析各种数据对象在程序的执行路径中的状态关系，例如一个变量在某个语句以后是否还被用到等。依据数据流分析的结果，可以进行后续的中间代码优化以及寄存器分配等相关步骤。 关于数据流分析的细节，我们将在 step7 做详细介绍。 寄存器分配 所谓寄存器分配，是指为中间代码中的虚拟寄存器分配实际的物理寄存器。对中间代码来说，通常假设虚拟寄存器的数量是无限的，这导致我们在分配物理寄存器时无法简单的对虚拟寄存器做一一映射，需要有一个调度与分配算法来合理使用有限的物理寄存器。本实验框架中使用了一种暴力寄存器分配算法，具体细节将在 step5 中详细说明，当然如果你感兴趣，你也可以基于我们的框架实现更高级的干涉图分配算法，具体不作要求。 目标平台汇编代码生成 目标平台汇编代码生成在 backend/asm.py | backend/asmemitter.py | backend/subroutineemitter.py | subroutineinfo.py 以及 backend/riscv/ 中。 通常我们认为的目标代码生成步骤包含寄存器分配、指令选择。寄存器分配是指为中间代码中的虚拟寄存器分配实际的物理寄存器，涉及物理寄存器的调度分配。指令选择是指选用合适的汇编指令来翻译中间代码指令，如中间代码生成章节提供的例子中，使用 addi 汇编指令来翻译 ADD 中间代码指令。需要特别提出的是，RISC-V 指令集的设计思路是尽可能简洁，因此有些指令并没有直接提供，需要用多条简单指令代替，如相等、大于等于、逻辑与、逻辑或等等。同学们实现时需要特别注意。 课程实验的目标平台为 RISC-V，RISC-V 是一个与 MIPS 类似的 RISC 指令集架构，编译实验要求所实现的编译器把 MiniDecaf 程序编译到 RISC-V 汇编代码。指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"，另外这里也有（非官方的）指令用法说明。下图给出了 RISC-V 的32个整数寄存器的相关说明，其中需要特别注意的寄存器有 ra（存放函数返回地址）、sp（存放当前栈顶地址）、fp（存放当前栈底地址）、a0&a1（存放函数返回值）。为了简单起见，我们简化了 RISC-V 的调用约定，由调用者（caller）负责保存寄存器内容，因此，无需关心某个寄存器是 caller-saved 还是 callee-saved。 "},"docs/step1/provided.html":{"url":"docs/step1/provided.html","title":"已提供的语法特性","keywords":"","body":"已经提供的语法特性 为了方便同学们完成实验，我们提供的实验框架中已经完成了部分语言特性的实现。对于某些步骤，同学们可以参照已实现的特性完成剩余的部分。例如，根据提供的 while 循环实现，同学们可以参考着完成 for 循环的实现。 下面我们列出了所有框架中已经完成的特性： step1 中我们提供了所有实现。 step2 中我们提供了取负运算的实现。 step3 中我们提供了加法和逻辑或操作运算的实现。 step5 中我们提供了基础数据结构——符号表的实现。 step6 中我们提供了基础数据结构——单层作用域的实现。 step7 中我们提供了 if 语句的实现。 step8 中我们提供了 while 循环的实现。 此外，我们提供了 step1-6 需要的语法树节点和中间代码指令，以及后端中的寄存器分配算法。 "},"docs/step1/intro.html":{"url":"docs/step1/intro.html","title":"实验要求","keywords":"","body":"实验指导 step1：一个仅有 return 的 main 函数 实验框架已经完成并通过了本节的测例，因此你不需要在这个阶段修改代码，但需要在 stage 1 的报告中（注意不是 stage 0）完成通过例子学习一节末尾的思考题。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 ./reports/stage-1.pdf。整个 stage 1 只需要提交一份报告，你不需要单独为 step 1 准备报告。 "},"docs/step1/example.html":{"url":"docs/step1/example.html","title":"通过例子学习","keywords":"","body":"通过例子学习，一个仅有 return 的主函数编译全流程： 本步骤主要涉及的语法为主函数和 return 语句，完成本步骤之后，你的编译器将支持将一个仅有 return 的主函数编译为 32 位 RISC-V 汇编代码，并通过 RISC-V 工具链生成可以在硬件模拟器上正确运行的程序。因为这是大家首次接触 MiniDecaf 编译实验框架，我们给大家的代码框架中已经包含所有 step1 的实现，大家可以直接运行通过 step1 的测试用例。并且，我们在每个步骤的文档中会详细梳理介绍在当前步骤中需要用到的知识点以及对应的代码片段和注释，如果我们认为当前步骤并不需要了解某部分知识点（如数据流分析、寄存器分配），我们会在后续的步骤中进行知识点的讲解。 下面我们将通过一个简单的 step1 测试用例，一起走过它的编译全流程： int main() { return 2024; } 词法分析 & 语法分析 在词法分析 & 语法分析这一步中，我们需要将输入的程序字符流按照语法规范转化为后续步骤所需要的 AST，我们使用了 lex/yacc 库来实现这一点。yacc 是一个根据 EBNF 形式的语法规范生成相应 LALR parser 的工具，支持基于属性文法的语法制导的语义计算过程。你可以根据我们的框架中对 lex/yacc 的使用，结合我们的文档，来快速上手 lex/yacc，完成作业；也可以选择阅读一些较为详细的文档，来系统地进行 lex/yacc 的入门，但这不是必须的。 在实验框架中，我们使用的是 lex/yacc 的一个纯 python 实现，称为 python-lex-yacc（简称 ply），其使用方法与 lex/yacc 有一些差异。 Python-lex-yacc 快速入门 程序的入口点在 main.py，它通过调用 frontend.parser.parser（位于 frontend/parser/ply_parser.py）来完成语法分析的工作，而这一语法分析器会自动调用位于 frontend/lexer/ply_lexer.py 的词法分析器进行词法分析。语法的定义和语法分析器都位于 frontend/parser/ply_parser.py，而词法的定义位于 frontend/lexer/lex.py。AST 节点的定义位于 frontend/ast/tree.py 中。以下表示中的符号都出自于这几个文件。 这部分的工作流程如下： 读内容 词法分析 & 语法分析 语义分析 readCode parser.parse Namer.transform & Typer.transform MiniDecaf 源文件 --------> 字节流 -----------> AST -------------------------------> ... 当程序读入程序的字符流之后，它首先会被 lexer 处理，并被转化为如下形式的一个 Token 流： Int Identifier(\"main\") LParen RParen LBrace Return Integer(2024) Semi RBrace 在frontend/lexer/lex.py文件中你可以看到每个 Token 是如何定义的，每个token都会以t_开头。如t_Semi = \";\"代表分号被解析以后会转化为 Semi 这个Token。而对于一些复杂的 Token，我们需要在lexer中定义一个正则表达式来匹配它，lex中通过定义一个函数来实现正则匹配。以匹配整数为例，函数的第一行r\"[0-9]+\"代表匹配用到的正则表达式，而函数的参数t则是被匹配得到的字符串，我们通过python中的类型转换将其变为一个整数，你可以在文件中看到以下代码： def t_Integer(t): r\"[0-9]+\" # can be accessed from `t_Interger.__doc__` t.value = int(t.value) return t 之后，这些 token 会被 yacc 生成的 LALR(1) parser 转化为如下形式的 AST： Program |- (children[0]) Function |- (ret_t) TInt |- (ident) Identifier(\"main\") |- (body) Block |- (children[0]) Return |- (expr) IntLiteral(2024) 得到的 AST 也就是 main.py 中 step_parse 这一函数里 parser.parse(...) 的输出。 在frontend/parser/ply_parser.py文件中，你可以看到我们是如何定义语法规则的，文件的最末尾有parser = yacc.yacc(start=\"program\")代表了parser的入口点是program，而program的定义在p_program函数中，你可以看到这个函数的docstring中定义了program的语法规则。注意docstring（即三个引号之间的内容）在这里并非注释，而是用于定义语法规则。 def p_program(p): \"\"\" program : function \"\"\" p[0] = Program(p[1]) def p_function_def(p): \"\"\" function : type Identifier LParen RParen LBrace block RBrace \"\"\" p[0] = Function(p[1], p[2], p[6]) 我们先看p_program函数，我们定义的语法规则是program由一个function组成，对应的上下文无关表达式就是program -> function，同时代码中的p[0] = Program(p[1])代表了构建AST的计算过程，这里的p[0]代表的是当前语法规则的左部，p[1]代表的是当前语法规则的右部第一个符号（即function），p[2]代表的是当前语法规则的右部第二个符号（这里没有），以此类推。这样递归下去，就能解析完整个程序。p[0] = Program(p[1])最后就会变为p[0] = Program(Function(...))，这里Program、Function类的定义在frontend/ast/tree.py文件中，你可以看到Function这个类的构造函数接受了三个参数，分别是返回值类型、函数名和函数体。 尝试运行 python main.py --input example.c --parse 你应该就能看到类似的输出。（记得自己写一个example.c） 语义分析 在 step1 语义分析步骤中，我们要遍历 AST，检验是否存在如下的语义错误： main 函数是否存在。（frontend/typecheck/namer.py:37） 在实际操作中，我们遍历 AST 所用的方法就是的 Visitor 模式，通过 Visitor 模式，我们可以从抽象语法树的根结点开始，遍历整颗树的所有语法结点，并针对特定的语法结点作出相应的操作，如名称检查和类型检查等。在编译器中，这种基于 Visitor 的对语法树进行一次遍历，完成某种检查或优化的过程，称为遍（pass）。不难想到，一个现代编译器是由很多遍扫描组成的，如 gcc 根据优化等级不同会有数百个不等的 pass。下面，我们将指出，step1 中我们是如何实现符号表构建 pass 和类型检查 pass 的，同学们可以选择去看相应的代码注释与实现细节。 frontend/typecheck/namer.py 和 typer.py 分别对应了符号表构建和类型检查这两次遍历。在框架中，Namer 和 Typer 都是继承 frontend/ast/visitor.py 中的 Visitor 类来通过 Visitor 模式遍历 AST 。 中间代码生成 在通过语义检查之后，编译器已经掌握了翻译源程序所需的信息（符号表、类型等），下一步要做的则是将抽象语法树翻译为便于移植和优化的中间代码，在本实验框架中就是三地址码。如何翻译抽象语法树？当然还是无所不能的 Visitor 模式，我们在中间代码生成步骤中再遍历一次语法树，对每个结点做对应的翻译处理。具体来说，在 step1 当中，我们只需要提取 return 语句返回的常量，为之分配一个临时变量，再生成相应的 TAC 返回指令即可。不难看出，本例对应的三地址码为： main: # main 函数入口标签 _T0 = 2024 # 为立即数 2024 分配一个临时变量 return _T0 # 返回 下面，我们同样也指出了在代码中我们是怎样实现这个中间代码生成 pass 的，大家可以参考注释和代码了解实现细节。 utils/tac 目录下实现了生成 TAC 所需的底层类。其中 tacinstr.py 下实现了各种 TAC 指令，同学们可以在必要时修改或增加 TAC 指令。 frontend/tacgen/tacgen.py 中通过一遍 AST 扫描完成 TAC 生成。和语义分析一样，这部分也使用了 Visitor 模式。这个文件里除了类型TACGen之外还有一个辅助类TACFuncEmitter，它用于处理产生TAC代码过程中一些相对底层的细节。在本框架中，TAC 程序的生成以函数为单位，对每个函数（step1-8 中只有 main 函数）分别使用一个 TACFuncEmitter 来生成对应的 TAC 函数代码。如果你增加了 TAC 指令，则可能需要在 TACFuncEmitter 类中增加生成相应指令的代码。 目标代码生成 目标代码生成步骤是对中间代码的再一次翻译，在本例中，你需要了解并掌握的知识点有: 如何将一个立即数装载到指定寄存器中？ RISC-V 提供了 li 指令来支持加载一个 32 位立即数到指定寄存器中，其中 表示寄存器名， 表示立即数值，如：li t0, 2024，就是将立即数 2024 加载到寄存器 t0 中。 如何设置返回值？ 在 RISC-V 中，a0 和 a1 是 gcc 调用约定上的存储返回值的寄存器，返回值会按照其大小和顺序存储在 a0 和 a1 中。也就是说，如果你有一个 32 位的返回值，你可以放在 a0 中返回，如果你有两个 32 位的返回值，你就需要把它们分别放在 a0 和 a1 中返回。更多的返回值会全部放入内存返回，如约定好的栈的某个位置，这取决于函数调用约定。 在我们的实验要求中，返回值均是单个 32 位的值。因此在当前步骤中你只需要了解，将需要返回的值放入 a0 寄存器中，然后在后面加上一条 ret 指令即可完成函数返回的工作。 综上所述，我们上述中间代码翻译成如下 RISC-V 汇编代码： .text # 代码段 .global main # 声明全局符号 main main: # 主函数入口符号 li t0, 2024 # 加载立即数 2024 到 t0 寄存器中 mv a0, t0 # 将返回值放到 a0 寄存器中 ret # 返回 实验框架中关于目标代码生成的文件主要集中 backend 文件夹下，step1 中你只需要关注 backend/riscv 文件夹中的 riscvasmemitter.py 以及 utils/riscv.py 即可。具体来说 backend/asm.py 中会先调用 riscvasmemitter.py 中的 selectInstr 方法对每个函数内的 TAC 指令选择相应的 RISC-V 指令，然后会进行数据流分析、寄存器分配等流程，在寄存器分配结束后生成真正的汇编指令（即所有操作数都已经分配好寄存器的指令），最后通过 RiscvSubroutineEmitter 的 emitFunc 方法生成每个函数的 RISC-V 汇编。 思考题 在我们的框架中，从 AST 向 TAC 的转换经过了 namer.transform, typer.transform 两个步骤，如果没有这两个步骤，以下代码能正常编译吗，为什么？ int main(){ return 10; } 我们的框架现在对于 return 语句没有返回值的情况是在哪一步处理的？报的是什么错？ 为什么框架定义了 frontend/ast/tree.py:Unary、utils/tac/tacop.py:TacUnaryOp、utils/riscv.py:RvUnaryOp 三种不同的一元运算符类型？ "},"docs/step1/visitor.html":{"url":"docs/step1/visitor.html","title":"Visitor 模式速成","keywords":"","body":"Visitor 模式速成 编译器的构造中会使用到很多设计模式，Visitor 模式就是常见的一种。 基础的设计模式都在 OOP 课程中覆盖，这里重提一下 Visitor 模式，并以框架中的代码为示例进行介绍。 我们知道，编译器里有很多的树状结构。最典型的就是，源程序通过上下文无关文法解析后，得到的抽象语法树。在语义分析和中间表示生成两个步骤中，我们都需要遍历整个抽象语法树。Visitor 模式的目的，就是对遍历树状结构的过程进行封装，本质就是一个 DFS 遍历。 让我们考虑 step1 的文法： program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer 以这个文法对应的一段 MiniDecaf 代码为示例： int main() { return 2; } 它会对应如下的 AST 结构： program function type(int) identifier(main) param_list return int(2) 我们用缩进表示树结构，其中 program, function, type, identifier, param_list, block, return, int 等均为 AST 上的结点类型。 在框架中，我们有以下的 AST 结点类实现（进行了适当的简略）： ''' frontend/ast/node.py ''' class Node: # 所有 AST 结点的基类 # ... ''' frontend/ast/tree.py ''' class Program(ListNode[Union[\"Function\", \"Declaration\"]]): # 程序，AST 的根结点类型 # ... class Function(Node): # 函数 # ... class Statement(Node): # 语句基类 # ... class Return(Statement): # return 语句 # ... class TypeLiteral(Node): # 类型基类 # ... class TInt(TypeLiteral): # 整型 # ... 假设在经过了词法分析和语法分析后，我们已经成功将 MiniDecaf 代码转化为了 AST 结构。现在，我们想要编写代码对 AST 进行扫描。很容易写出递归的 DFS 遍历： def dfs(node: Node): if isinstance(node, Program): for func in node.functions: dfs(func) elif isinstance(node, Function): # do something for scanning a function node elif isinstance(node, Return): # ... dfs 函数接收一个结点，根据这个结点的类型进行深度优先遍历。容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的遍历逻辑。 那么我们把这些遍历逻辑封装到一个类里面，就得到了一个最简单的 Visitor。此外，为了便于实现，我们不使用 isinstance 来判断结点类型，而是调用结点自身的一个 accept 函数，并把不同的 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口。 ''' frontend/ast/node.py ''' class Node: # 所有 AST 结点的基类 def accept(self, v: Visitor[T, U], ctx: T) -> Optional[U]: raise NotImplementedError ''' frontend/ast/tree.py ''' class Program(ListNode[Union[\"Function\", \"Declaration\"]]): # ... def accept(self, v: Visitor[T, U], ctx: T): return v.visitProgram(self, ctx) class Function(Node): # ... def accept(self, v: Visitor[T, U], ctx: T): return v.visitFunction(self, ctx) # ... ''' frontend/ast/visitor.py ''' class Visitor(Protocol[T, U]): def visitOther(self, node: Node, ctx: T) -> None: return None def visitProgram(self, that: Program, ctx: T) -> Optional[U]: return self.visitOther(that, ctx) def visitFunction(self, that: Function, ctx: T) -> Optional[U]: return self.visitOther(that, ctx) # ... 之后，如果我们想要编写一种遍历 AST 的方法，可以直接继承 Visitor 类，并在对应结点的 visit 成员方法下实现对应的逻辑。例如，框架中用如下的方法进行符号表构建： class Namer(Visitor[ScopeStack, None]): def visitProgram(self, program: Program, ctx: ScopeStack) -> None: # ... for child in program: if isinstance(child, Function): child.accept(self, ctx) def visitFunction(self, func: Function, ctx: ScopeStack) -> None: # ... # ... 如果想要访问某个子结点 child，直接调用 child.accept(self, ctx) 即可。 "},"docs/step1/spec.html":{"url":"docs/step1/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step1 语法规范 我们采用 EBNF (extended Barkus-Naur form) 记号书写语法规范，采用类似 ANTLR 的记号： 小写字母打头的是非终结符（如 program），大写字母打头的是终结符（如 Identifier），可以用字符串字面量表示终结符（如 'int'） 后面会用到：( 和 ) 表示分组，| 表示选择，* 零或多次，+ 一或多次，? 零或一次。 很容易通过增加新的非终结符，去掉这些符号。例如 x+ 就可以被替换成新的非终结符 y，并且 y : x | x y。 EBNF 也有很多写法，另一种是用尖括号表示非终结符 ::= 等。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer step1 语义规范 1.1 MiniDecaf 的 int 类型具体指 32 位有符号整数类型，范围 [-2^31, 2^31-1]，补码表示。 1.2 编译器应当只接受 [0, 2^31-1] 范围内的整数常量, 不支持负整数常量，如果整数不在此范围内，编译器应当报错。引入负号-后，可以用负号配合正整数常量来间接表示负整数常量。 1.3 如果输入程序没有 main 函数，编译器应当报错。 "},"docs/step2/intro.html":{"url":"docs/step2/intro.html","title":"实验要求","keywords":"","body":"实验指导 step2：一元运算符 step2 中，我们要给整数常量增加一元运算：取负 -、按位取反 ~ 以及逻辑非 !。 语法上，我们需要修改 expression 的定义，从 expression : Integer 变成： expression : unary unary : Integer | ('-'|'!'|'~') unary 三个操作的语义和 C 以及常识相同，例如 ~0 == -1，!!2 == 1。 稍微一提，关于按位取反，我们使用补码存储 int；关于逻辑非，只有 0 表示逻辑假，其他的 int 都是逻辑真。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 ./reports/stage-1.pdf。整个 stage 1 只需要提交一份报告，你不需要单独为 step 2 准备报告。stage 1 的报告还需要额外包含 step 1 的思考题。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 如何检查我是否通过自动测试(CI) 在 git.tsinghua 上打开你的项目，在界面的右侧，Clone 按钮的下方，commit id 的左侧，可以看到一个画圈的 × 或者 √ 的图标，代表当前 commit 是否通过 CI 测试。 如果你希望获取详细测试输出，可以点击这个画圈的 × 或者 √ 的图标，或者在网页左侧选择 CI/CD 一栏的 Jobs，然后选择希望查看的评测结果即可。如果测试输出无法显示，可以点击输出框右上角四个按钮中最左边的一个，或者在当前地址(如.../jobs/123456)的后面加上/raw(如.../jobs/123456/raw)，即可获取测试输出。 "},"docs/step2/example.html":{"url":"docs/step2/example.html","title":"通过例子学习","keywords":"","body":"step2 实验指导 我们按照上一节划分的编译器阶段，分阶段给出 step2 实验指导。本实验指导使用的例子为： 需要注意的是，我们为了简化描述，提取出了测试用例中和本步骤最相关的部分，实际的测试用例还是一个完整的，带有主函数的 MiniDecaf 程序。 -1 词法语法分析 在 step2 中，我们引入了一元运算，因此需要引入新的抽象语法树节点： 节点 成员 含义 Unary 操作数 operand，运算类型 op 一元运算 注意由于各种一元运算的形式是一样的，只是运算规则不同，所以用统一的一元运算节点来表示，在后续步骤中，再根据具体的运算种类翻译为不同的 TAC 与 RISC-V 指令。 语义分析 由于现在 return 语句的返回值不再是整型常量，而是表达式，因此语义分析时需要递归地访问运算操作结点的子结点，才能访问到作为叶子结点的整型常量，完成 step1 中实现的整型常量越界检查。 代码没有特别需要修改的地方。 中间代码生成 在 step1 中，我们只需为 return 语句的返回的整型常量分配一个临时变量即可。而从 Step2 开始，语法树上出现了各种运算操作结点。在生成 TAC 的过程中，我们需要为运算结点分配一个临时变量，并生成一条指令，该指令根据子结点的临时变量进行计算，将结果赋予该结点的临时变量。 针对取负操作，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 NEG T0 对参数取负 按照上文说的，-1 在语法树上对应父-子两个结点，父结点为取负操作，子结点为常量 1。在生成过程中，首先使用 Visitor 模式递归地访问子结点，我们使用一个临时变量加载该立即数。之后，在父结点，我们根据子结点的临时变量，生成一条取负指令，将这条指令得到的目标临时变量设置为父结点的临时变量。 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = NEG _T0 目标代码生成 step2 目标代码生成步骤的关键点在于，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。以 NEG 中间表达指令为例，RISC-V 汇编中有 neg 指令与其对应，因此上述中间代码可以翻译为如下的 RISC-V 汇编： li t0, 1 neg t1, t0 如果你不知道某个运算符应该翻译成怎样的汇编代码，你可以看这里 实现细节 关于实现细节，对应的代码位置在下面给出，代码中提供注释供大家学习。 相比于step 0, 我们实现了把返回值从一个整数（如：2024、1）变成单目表达式（如：-1），则在这一步中你可能需要进行以下操作（实际上这些实现已经在框架里提供）： 首先，我们应该把 - 看作一个符号，而不应该将 -1 看作一个整体，因为我们还可能遇到 -x 这种求一个变量的相反数的操作，如果将其分开处理则会增加我们的工作量。因此我们需要在词法分析中加入对 - 的处理。 我们能发现 -, !, ~ 等符号都可以作为一元运算符出现，比如!x, ~a, -10，我们将这类一元运算操作都称为 unary ，一并处理所有的一元运算符这样就不需要对每一种符号都专门生成一种语法规则和 AST 节点了。 因此我们希望生成的 AST 应当变为如下形式： Program |- (children[0]) Function |- (ret_t) TInt |- (ident) Identifier(\"main\") |- (body) Block |- (children[0]) Return |- (expr) Unary |- (op) Minus |- (expr) IntLiteral(1) 看到这里，你可能会好奇，为什么这里多了如 (expr) Unary 这样的奇怪的 AST 节点。在编译器中，我们将所有的值、或者运算产生的结果称为一个表达式。比如 1 这个数字是一个表达式， -1 , y-x同样也是表达式，其会生成一个值。而带返回值的 return 语句需要一个值，我们可以理解为带返回值的 return 语句后需要接一个表达式，这样在语义上才是正确的（例如，我们能见到return 1;这样的语句，但是不会见到return if;这样的语句，因为 if 并不是一个会产生值的表达式）。 词法分析 & 语法分析 在 frontend/lex/lex.py 里加入新的 lex token 定义，以便lexer可以解析 -： t_Minus = \"-\" 在 ply 的 lexer 中，定义的新 token 需要以 t_开头。更具体的解释见文件注释或文档（太长了助教也读不下去）。 在 frontend/ast/tree.py 里加入新的 AST 节点定义（以及相应的其它东西）： class Unary(Expression): def __init__(self, op: Operator, operand: Expression): ... 并在 frontend/ast/visitor.py 中加入相应的分派函数。 它将在后续的 parser 语义计算中被用到。 在 frontend/parser/ply_parser.py 里加入新的 grammar rule： def p_expression_precedence(p): # 定义的新语法规则名。可以随便起，但必须以 `p_` 开头以被 ply 识别。 \"\"\" expression : unary unary : primary \"\"\" # 以 [BNF](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form) 定义的新语法规则，以 docstring 的形式提供。 p[0] = p[1] # 这条语法规则相应的语义计算步骤，下标对应着产生式中的相应符号。 # 语法分析器直接产生的实际上是一棵语法分析树，而构建 AST 这一数据结构则通过相应语法制导的语义计算过程来完成。 def p_unary_expression(p): \"\"\" unary : Minus unary \"\"\" p[0] = tree.Unary(UnaryOp.Neg, p[2]) 这里其实就是上下文无关文法，大家要看懂文法和代码的对应关系，注意看这条生成规则unary : Minus unary，其中p[0]代表的就是第一个unary, p[1]则是Minus，p[2]为第二个unary。你会看到我们框架代码和这里不太一样，因为unary符号不止有减号，我们通过将lex解析得到的-通过backward_search对应到我们在代码中enum的UnaryOp.Neg（frontend/ast/node.py:40）。 现在尝试运行 python main.py --input example.c --parse 看看效果吧。（记得修改example.c） 怎么从 AST 变为 TAC 的？ 什么是 TAC ，如果你没读前面的章节，你可以快速看看这一部分。 这一步就是 TACGen.transform 函数(frontend/tacgen/tacgen.py)做的事了， TACGen.transform 接受一个AST树输入，输出一个TAC表示，请确保你已经对Visitor 模式有所了解，或者假设你已经知道在遍历 AST 时 accept 函数会对不同类型的 AST Node 调用不同的visit 函数。例如，visit (children[0]) Return 时，遇到的子节点是 (expr) Unary，那么 accept 最终会调用visitUnary，你的lint工具应该是没法做到点一下就跳转到对应的位置，所以你需要自己判断我们在遍历某个节点的时候其子节点的类型。 下面的描述中一定要记得区分accept和直接对于mv.visitXXX的调用，前者是在遍历AST时调用的，后者是在 TACFuncEmitter 类中调用的。并且希望大家一定要对着代码看。 Program |- (children[0]) Function |- (ret_t) TInt |- (ident) Identifier(\"main\") |- (body) Block |- (children[0]) Return |- (expr) Unary |- (op) Minus |- (expr) IntLiteral(1) 继续看上述例子，我们先关注只有 main 函数的 Minidecaf 程序，我们将TACGen.transform代码贴了一些在这里： def transform(self, program: Program) -> TACProg: labelManager = LabelManager() tacFuncs = [] for funcName, astFunc in program.functions().items(): # in step9, you need to use real parameter count emitter = TACFuncEmitter(FuncLabel(funcName), 0, labelManager) astFunc.body.accept(self, emitter) tacFuncs.append(emitter.visitEnd()) return TACProg(tacFuncs) 现在我们开始正式遍历 AST 树，transform 会先遍历每一个函数进行代码翻译，因为我们目前只有一个函数main，我们只考虑没有参数的函数，我们需要对函数体进行翻译，函数体首先在一个block中（花括号括起来的部分），因此会先进入 visitBlock 函数，visitBlock 函数对于在block中的所有子节点调用了child.accept(self, mv)，在这个例子中则会调用Return 语句对应的visitor，进入visitReturn。继续向下，visitReturn 又对于 return AST Node 中的 expr 调用了 stmt.expr.accept(self, mv) ，又进入了visitUnary，同理，expr.operand.accept(self, mv)会进入visitIntLiteral。 到了此处出现了不同，我们发现visitIntLiteral中第一次调用了mv的成员函数 mv.visitLoad(expr.value) 这里进入了TACFuncEmitter.visitLoad： def visitLoad(self, value: Union[int, str]) -> Temp: temp = self.freshTemp() self.func.add(LoadImm4(temp, value)) return temp self.freshTemp()分配了一个虚拟寄存器 temp ，并且产生了一条立即数加载语句（你可以认为现在的所有指令就是用一个大数组存放了起来）。至此，我们翻译出了第一条语句，将 1 load 到一个虚拟寄存器 temp 中。剩下的部分，与这条语句的翻译也十分相似，因此不再赘述。 到此为止我们得到的TAC代码如下： FUNCTION: _T0 = 1 _T1 = - _T0 return _T1 现在尝试运行 python main.py --input example.c --tac 看看效果吧。 怎么从TAC到汇编代码 这一步是 Asm.transform 函数(backend/asm.py)处理的，Asm.transform 接受一个 TAC 输入，输出汇编代码。 def transform(self, prog: TACProg): analyzer = LivenessAnalyzer() reg_alloc = BruteRegAlloc(emitter) for func in prog.funcs: emitter = RiscvAsmEmitter(Riscv.AllocatableRegs, Riscv.CallerSaved) pair = emitter.selectInstr(func) builder = CFGBuilder() cfg: CFG = builder.buildFrom(pair[0]) analyzer.accept(cfg) reg_alloc.accept(cfg, pair[1]) return emitter.emitEnd() 我们先忽略LivenessAnalyzer和Control Flow Graph(CFG)以及寄存器分配的部分（助教写了一个非常简单暴力的寄存器分配，如果你觉得它不够好，你可以在后面的step换掉它），实际上，我们这里最主要的是指令选择（selectInstr），指令选择将中端TAC代码转换为riscv汇编代码，selectInstr函数中，我们也采用了visitor模式遍历指令序列， _T0 = 1 这句比较直接，我们也能较为容易的想到一个简单的汇编指令对应（li _T0, 1），主要讲讲和_T1 = - _T0 和 return _T1翻译过程发生了什么。 先看visitUnary函数： def visitUnary(self, instr: Unary) -> None: op = { TacUnaryOp.NEG: RvUnaryOp.NEG, # You can add binary operations here. }[instr.op] self.seq.append(Riscv.Unary(op, instr.dst, instr.operand)) 这里将中端的TacUnaryOp.NEG翻译为了后端的RvUnaryOp.NEG，在后端输出汇编时，我们直接将RvUnaryOp.NEG转换为小写字符串取了11位以后的字符，直接输出为neg（参考Unary.__str__函数），因此后续希望添加其他后端的符号时，你应该直接在RvUnaryOp中增加对应的同名的enum字段。 你可以试试，将RvUnaryOp.NEG中名字改为RvUnaryOp.XXX看看输出的汇编代码会发生什么变化吧。 再看visitReturn函数，我们这里的return是一个带返回值函数的return def visitReturn(self, instr: Return) -> None: if instr.value is not None: self.seq.append(Riscv.Move(Riscv.A0, instr.value)) else: self.seq.append(Riscv.LoadImm(Riscv.A0, 0)) self.seq.append(Riscv.JumpToEpilogue(self.entry)) 这里会进入第一个分支，由于 Risc-V 的调用约定将A0寄存器定为存放返回值的寄存器，因此在返回时我们产生了一条Move指令，这里的instr.value则是返回值对应的表达式使用的寄存器。 你可能会觉得，这一步不就是将 TAC 一一对应为一个汇编指令序列嘛，有什么必要吗？其实这一步是必要的，首先有的中间表示可能无法由一条汇编指令完成，比如T2 = T1 || T0，这里的逻辑或需要将T1、T0进行或操作后，再判断其值是否为1。为什么这一步不在产生 TAC 时就处理了？因为我们希望中间表示能在一定程度上与平台无关（不同后端目标架构的指令选择可能存在较大差异），中间表示有一定抽象能力能简化整体编译器的设计。 物理寄存器分配我们暂时跳过。至此我们已经完成了从源代码到汇编代码的翻译。 现在尝试运行 python main.py --input example.c --riscv 看看效果吧。 思考题 我们在语义规范中规定整数运算越界是未定义行为，运算越界可以简单理解成理论上的运算结果没有办法保存在32位整数的空间中，必须截断高于32位的内容。请设计一个 minidecaf 表达式，只使用-~!这三个单目运算符和从 0 到 2147483647 范围内的非负整数，使得运算过程中发生越界。 提示：发生越界的一步计算是-。 总结 本步骤中其他运算符的实现逻辑和方法与取负类似，大家可以借鉴取负的实现方法实现剩下的逻辑非和按位非。并且，我们在实验框架中已经给出了取负的参考实现，希望能够帮助大家快速上手编译实验。 "},"docs/step2/spec.html":{"url":"docs/step2/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step2 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : unary unary : Integer | ('-'|'!'|'~') unary step2 语义规范 2.1 运算符 - 的结果是其操作数的相反数。 2.2 运算符 ~ 的结果是其操作数的二进制反码（也就是说，结果中的每一个二进制位是 1 当且仅当其对应的二进制位是 0）。 2.3 当操作数不等于 0 时，逻辑非运算符 ! 的结果为 0；当操作数等于 0 时，其结果为 1。 2.4 MiniDecaf 中，负数字面量不被整体作为一个 token。它被看成是一个取负符号、后面是它的绝对值。 所以我们无法用字面量表示 -2147483648，但可以写成 -2147483647-1（待我们加上四则运算后）。 2.5 整数运算越界是未定义行为（undefined behavior），即对程序的行为无任何限制。 例如 -(-2147483647-1) 是未定义行为。这一条规则对于后续 step 引入的运算符也都适用。 对于含有未定义行为的 C/C++ 程序，在启用优化选项编译时，编译器可能产生意料之外的结果。 "},"docs/step3/intro.html":{"url":"docs/step3/intro.html","title":"实验要求","keywords":"","body":"实验指导 step3：加减乘除模 step3 我们要增加的是：加 +、减 -、乘 *、整除 /、模 % 以及括号 ( )。 语法上我们继续修改 expression，变成 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1+2*(4/2+1) == 7。 我们这种表达式语法写法可能比较繁琐，但它有几个好处： 和 C17 标准草案保持一致 把优先级和结合性信息直接编码入语法里，见优先级和结合性一节。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 ./reports/stage-1.pdf。整个 stage 1 只需要提交一份报告，你不需要单独为 step 3 准备报告。stage 1 的报告还需要额外包含 step 1 的思考题。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 如何检查我是否通过自动测试(CI) 在 git.tsinghua 上打开你的项目，在界面的右侧，Clone 按钮的下方，commit id 的左侧，可以看到一个画圈的 × 或者 √ 的图标，代表当前 commit 是否通过 CI 测试。 如果你希望获取详细测试输出，可以点击这个画圈的 × 或者 √ 的图标，或者在网页左侧选择 CI/CD 一栏的 Jobs，然后选择希望查看的评测结果即可。如果测试输出无法显示，可以点击输出框右上角四个按钮中最左边的一个，或者在当前地址(如.../jobs/123456)的后面加上/raw(如.../jobs/123456/raw)，即可获取测试输出。 "},"docs/step3/example.html":{"url":"docs/step3/example.html","title":"通过例子学习","keywords":"","body":"step3 实验指导 本实验指导使用的例子为： 1+3 词法语法分析 在 step3 中，我们引入了算术运算，因此需要引入新的抽象语法树节点： 节点 成员 含义 Binary 左操作数 lhs，右操作数 rhs，运算类型 op 二元运算 对有兴趣的同学：虽然 -2 和 2-3 里面的 - 意义不同，但 lexer 不知道这点（parser 才知道），所以它们都会用同样的 token kind - 表示。 但有时，可能需要后续阶段告诉 lexer（或 parser）一些信息，最经典的例子是 “typedef-name identifier problem”。 语义分析 同 Step2。 中间代码生成 与一元操作类似，针对加法，我们需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 作用 ADD T0,T1 将两个参数相加 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = 3 _T2 = ADD _T0, _T1 目标代码生成 step3 目标代码生成步骤的关键点与 step2 相同，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。 li t0, 1 li t1, 3 add t2, t0, t1 思考题 我们知道“除数为零的除法是未定义行为”，但是即使除法的右操作数不是 0，仍然可能存在未定义行为。请问这时除法的左操作数和右操作数分别是什么？请将这时除法的左操作数和右操作数填入下面的代码中，分别在你的电脑（请标明你的电脑的架构，比如 x86-64 或 ARM）中和 RISCV-32 的 qemu 模拟器中编译运行下面的代码，并给出运行结果。（编译时请不要开启任何编译优化） #include int main() { int a = 左操作数; int b = 右操作数; printf(\"%d\\n\", a / b); return 0; } 总结 本步骤中其他运算符的实现逻辑和方法与加法类似，可以参考二元加法的实现方法设计实现其他二元运算符。 "},"docs/step3/precedence.html":{"url":"docs/step3/precedence.html","title":"优先级和结合性","keywords":"","body":"优先级和结合性 操作符有优先级和结合性的概念，在之前的编程经历中大家应该已经对这两个概念已经有了直观的理解，这里用例子进一步解释一下： 优先级是两个操作符之间的关系，例如*的优先级比+高，所以表达式1 + 2 * 3应该解析成语法树add (1 mul (2 3))（前序表示），不能解析成mul (add (1 2) 3) 结合性是一个操作符的性质，例如-是左结合的，所以表达式1 - 2 - 3应该解析成sub (sub (1 2) 3)，不能解析成sub (1 sub (2 3)) 我们给出的语法规范已经表示了这样的性质，因此理论上我们不需要再额外定义操作符的优先级和结合性了。你可以自己试试，按照本步给出的语法规则，上面的两个表达式确实只能解析成我们期望的结果。 但是有一个问题：这样的语法规范虽然是正确的，也确实可以直接用来实现语法分析器了，但并不符合直观：我们一开始学习C或者别的编程语言的时候，讲的就是一个二元表达式由两个子表达式和中间的操作符组成，并且操作符有优先级和结合性。也就是这样的： expression : expression ('+'|'-') expression | expression ('*'|'/'|'%') expression | ('-'|'~'|'!') expression | Integer | '(' expression ')' 当然，它是有歧义的，你也可以自己试试，如果只有这些产生式的话，上面的两个表达式都可以解析成正确或者错误的结果。所以如果想基于这个规范来实现语法分析器，就必须告诉语法分析工具这些操作符的优先级和结合性是什么。 之后每一步给出的语法都是没有歧义，本身就能体现优先级和结合性的。如果你确实想借助优先级和结合性来实现，需要两个步骤： 把我们给出的语法规范转化成类似上面这样“更模糊”，有歧义的语法规范。我们相信这个方向的转化应该是容易的。 指定每个操作符的优先级和结合性。可以参考https://en.cppreference.com/w/c/language/operator_precedence，它给出了C语言操作符的优先级和结合性，因为我们的MiniDecaf语言是C语言的一个子集，所以这张表格也足够我们的语言使用了。 "},"docs/step3/spec.html":{"url":"docs/step3/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step3 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step3 语义规范 3.1 二元操作符 * 的结果是操作数的乘积。 3.2 二元操作符 / 的结果是第一个操作数除以第二个操作数所得的商的整数部分（即所谓“向零取整”），二元操作符 % 的结果是第一个操作数除以第二个操作数所得的余数。在两种操作中，如果第二个操作数为 0，则其行为都是未定义的。当 b 不为 0 时，表达式 (a/b)*b + a%b 应该等于 a。 3.3 二元操作符 + 的结果是操作数的和。 3.4 二元操作符 - 的结果是第一个操作数减去第二个操作数所得的差。 3.5 除非特别声明，子表达式求值顺序是未规定行为（unspecified behavior），即其行为可以是多种合法的可能性之一。也就是说，以任意顺序对子表达式求值都是合法的。 例如：执行 int a=0; (a=1)+(a=a+1); 之后 a 的值是未规定的（待我们加上变量和赋值运算符后，这个问题才会产生真正切实的影响）。 "},"docs/step4/intro.html":{"url":"docs/step4/intro.html","title":"实验要求","keywords":"","body":"实验指导 step4：比较和逻辑表达式 step4 我们要增加的是： 比较大小和相等的二元操作：、、>=, >, ==, != equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive 逻辑与 &&、逻辑或 || expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1=2 是逻辑真（int 为 1）。 但特别注意，C 中逻辑运算符 || 和 && 有短路现象，我们不要求。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 1 的实验报告需要放在 stage-1 这个 branch 下的 ./reports/stage-1.pdf。整个 stage 1 只需要提交一份报告，你不需要单独为 step 4 准备报告。stage 1 的报告还需要额外包含 step 1 的思考题。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 如何检查我是否通过自动测试(CI) 在 git.tsinghua 上打开你的项目，在界面的右侧，Clone 按钮的下方，commit id 的左侧，可以看到一个画圈的 × 或者 √ 的图标，代表当前 commit 是否通过 CI 测试。 如果你希望获取详细测试输出，可以点击这个画圈的 × 或者 √ 的图标，或者在网页左侧选择 CI/CD 一栏的 Jobs，然后选择希望查看的评测结果即可。如果测试输出无法显示，可以点击输出框右上角四个按钮中最左边的一个，或者在当前地址(如.../jobs/123456)的后面加上/raw(如.../jobs/123456/raw)，即可获取测试输出。 "},"docs/step4/example.html":{"url":"docs/step4/example.html","title":"通过例子学习","keywords":"","body":"step4 实验指导 本实验指导使用的例子为： 1 词法语法分析 本 step 中引入的运算均为二元运算，在 step3 中引入的二元运算节点中进行修改即可。 语义分析 同 Step2。 中间代码生成 针对小于符号，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 LT T0,T1 给出 T0结果，成立为1，失败为0 需要特别注意的是，在 C 语言中，逻辑运算符 || 和 && 有短路现象，我们的实现中不要求大家考虑它们的短路性质。 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = 2 _T2 = LT _T0, _T1 目标代码生成 step4 目标代码生成步骤的关键点与 step3 相同，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。 li t0, 1 li t1, 2 slt t2, t0, t1 逻辑表达式会麻烦一点，因为 gcc 可能会用跳转来实现&&和||，比较难以理解，所以下面直接给出 land 和 lor 对应的不使用跳转的汇编。 IR 汇编 lor or t3,t1,t2 ; snez t3,t3 land snez d, s1; sub d, zero, d; and d, d, s2; snez d, d; 注意 RISC-V 汇编中的 and 和 or 指令都是位运算指令，不是逻辑运算指令。 思考题 在 MiniDecaf 中，我们对于短路求值未做要求，但在包括 C 语言的大多数流行的语言中，短路求值都是被支持的。为何这一特性广受欢迎？你认为短路求值这一特性会给程序员带来怎样的好处？ 总结 本步骤中其他运算符的实现逻辑和方法与小于符号类似，可以参考小于符号的实现方法设计实现其他逻辑运算符。 恭喜你！到目前为止，你已经成功实现了一个基于 MiniDecaf 语言的计算器，可以完成基本的数学运算和逻辑比较运算了，成就感满满！然而，目前你的计算器还只能支持常量计算，这大大降低了计算器的使用体验，因此，在下一个 Stage，我们将一起实现对变量的支持。无论如何，当前的任务已经完成，好好休息一下吧☕️ "},"docs/step4/spec.html":{"url":"docs/step4/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step4 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step4 语义规范 4.1 关系操作符 （小于）、>（大于）、（小于等于）和>=（大于等于）的结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。 关系操作符可能导致表达式的含义与数学文献中常见的含义不同，例如 0 的含义与 (0 相同，即“如果 0 小于 1，那么判断是否有 1 小于 2，否则判断是否有 0 小于 2”。 4.2 判等操作符 ==（等于）和 !=（不等于）类似于关系操作符，结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。但判等操作符的优先级比关系操作符更低。对于任意一对操作数，这两个操作符中有且仅有一个结果为 1。 其优先级的设定会导致其含义在某些时候可能会反直观，例如，0 的运算结果为 1。 4.3 当操作数都非 0 时，逻辑与操作符 && 的结果为 1；否则其结果为 0。 4.4 当操作数有一个非 0 时，逻辑或操作符 || 的结果为 1；否则其结果为 0。 4.5 逻辑操作符 || 和 && 依然遵循语义规范 3.5，即其操作数的求值顺序是未指定行为。 换言之，我们不对逻辑表达式的短路求值做要求，可以将操作数两个以任意顺序计算出，再计算逻辑操作的结果。 "},"docs/step5/intro.html":{"url":"docs/step5/intro.html","title":"实验要求","keywords":"","body":"实验指导 step5：局部变量和赋值 这一步我们终于要增加变量了，包括： 变量的声明 变量的使用（读取/赋值） 此外，我们的 main 函数内部可以包含多条语句和声明了。 为了增加变量，我们需要确定：变量存放在哪里、如何访问变量。我们将借此引入 栈帧 的概念，并介绍它的布局。 语法上，step5 的改动如下： function : type Identifier '(' ')' '{' statement* '}' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression primary : Integer | '(' expression ')' | Identifier 我们要增加和变量相关的语义检查：变量不能重复声明，不能使用未声明的变量。 请将你的作业放置在分支stage-2下，你可以通过git checkout -b stage-2创建一个新的分支并继承当前分支的修改。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 2 的实验报告需要放在 stage-2 这个 branch 下的 ./reports/stage-2.pdf。注意报告的标题是 stage-2 而不是 step-5。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step5/example.html":{"url":"docs/step5/example.html","title":"通过例子学习","keywords":"","body":"step5 实验指导 本实验指导使用的例子为： int main() { int x = 2024; return x; } 词法语法分析 针对局部变量定义和赋值操作，我们需要设计 AST 节点来表示它，给出的参考定义如下（框架中已经提供）： 节点 成员 含义 TInt 无 整型 Identifier 名称 value 标识符（用于表示变量名） Assignment 同 Binary 赋值运算 Declaration 类型 var_t，标识符 ident，初始表达式 init_expr 变量声明 请注意，赋值操作是一种特殊的二元运算，因此可以将它合并到 Binary 节点里，也可以单独设置一类节点继承 Binary 类来处理它。 语义分析 从本节开始，我们需要在语义分析阶段对局部变量的规范进行检查。具体来说，我们需要名为符号表的数据结构。符号表的实现已经在框架中给出。因此，你只需要修改语义分析部分的代码，在必要时调用符号表的接口即可。 在符号表构建过程中，我们要按照语句顺序，逐一访问所有变量定义声明。在访问变量声明时，我们需要为该变量赋予一个变量符号，并将它存入符号表中。由于变量不能重复声明，在定义变量符号前需要在符号表中检查是否有同名符号。 类似地，在访问表达式时，如果遇到变量的使用，我们也需要在符号表中检查，避免使用未声明的变量。例如，如果我们将测例修改为： int main() { int x = 2024; return x + y; } 那么在扫描到加法操作的 AST 结点时，会依次检查该操作的两个操作数 x 和 y。这两个操作数均为变量标识符，因此我们需要到符号表中搜索 x 和 y 对应的符号。符号 x 可以在符号表中找到（我们在扫描 int x = 2024; 这条语句后已经为其定义），而 y 无法找到，因此编译器需要在扫描到 y 对应的结点时报错。 符号表总是和作用域相关的。例如，在 C 语言中，我们可以在全局作用域中定义名为 \"a\" 的全局变量，同时在 main 函数中定义名为 \"a\" 的局部变量，这并不产生冲突。不过由于本节还无需支持全局变量和块语句，同学们不用考虑这一点，只考虑 main 函数作用域对应的单张符号表即可。 此外，在本节中，我们引入了赋值操作。赋值可以看作一种特殊的二元运算，但需要注意，赋值号左侧必须为一个左值。具体来说，同学们需要检查赋值号左侧只能是变量名标识符。在 step11 中，我们会将左值的范围进一步包括数组元素。 对应到框架代码上： frontend/symbol 目录下为符号的实现。其中 symbol.py 为符号类的基类，varsymbol.py 为变量符号。在本节中，同学们只需要考虑变量符号即可。 frontend/scope 目录下为符号表的实现。其中 scope.py 为作用域类，在本节中由于只有一个局部作用域，因此无需考虑作用域栈。同学们只需要新建一个 Scope 对象，用以维护 main 函数中所有出现过的变量符号即可。 中间代码生成 我们首先来看本节指导用例所对应的中间代码： main: _T1 = 2024 _T0 = _T1 return _T0 针对赋值操作，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 ASSIGN T0,T1 临时变量的赋值 从中间代码可以看出，尽管我们引入了变量的概念，但是在比较低级的中间代码上，数据的存储和传递仍然是基于虚拟寄存器进行的。由于 MiniDecaf 语言中的基本类型只有 int 型，而 TAC 里的临时变量也是 32 位整数，因此，我们可以把 MiniDecaf 局部变量和 TAC 临时变量对应起来。 在扫描到 int x = 2024; 这条语句时，中间代码先把立即数 2024 加载到临时变量 _T1 中，然后再把 _T1 的值赋给临时变量 _T0，此时 _T0 已经成为了变量 x 的“替身”。每次需要用到变量 x 的值时，我们都会去访问 _T0。例如，测例中直接用返回 _T0 代替了返回变量 x 的值。因此，为了在后续使用变量 x 时能快速找到 _T0 这个临时变量，在符号表中存储 x 这个符号时，应当为该符号设置一个成员，存储 x 对应的临时变量。每当在 AST 上扫描到一个变量标识符结点时，我们都直接调用该变量对应的临时变量作为结点的返回值。 请注意 frontend/symbol/varsymbol.py 中，变量符号的定义里有该变量对应的 TAC 临时变量成员。 目标代码生成 本节指导用例对应如下 RISC-V 汇编代码： .text .global main main: li t1, 2024 mv t0, t1 # 我们使用 mv 指令来翻译中间表示里的 ASSIGN 指令 mv a0, t0 ret 简单的启发式寄存器分配算法 在中间代码中，我们使用了虚拟寄存器来存储变量的值。如果所使用的虚拟寄存器的个数，超过了目标机器实际拥有的物理寄存器数目，将无法生成正确的目标代码。此时，需要采用寄存器分配算法，调度和分配数目有限的物理寄存器资源，保证所有临时变量（虚拟寄存器或伪寄存器）都有合适的物理寄存器与之对应。在程序执行的任何时刻，都需要保证不会出现寄存器分配冲突，即两个同时有效且将被引用的临时变量（虚拟寄存器）被分配到同一个物理寄存器中，寄存器分配冲突将造成程序运行结果的错误。然而，寄存器分配问题是NP 完备问题（可以从 3-SAT 问题归约），这意味着对于一个含有大量临时变量的程序，为了获得最优寄存器分配方案，编译器将耗费可观的计算时间用于寄存器分配。因此，考虑到执行效率问题，实际的编译器实现中一般采用启发式算法。 实验框架中所采用的启发式寄存器分配算法基于活跃性分析。为避免一次性介绍过多的知识，将在 Step6 详细介绍活跃性分析的相关理论。大家目前只需要了解，活跃性分析是为了求解每个临时变量是否会在程序某点之后被引用，如果被引用，这个临时变量就是活跃的。 基于活跃性分析的启发式寄存器分配算法的基本思路：针对每一条 TAC 指令（例如 _T2 = ADD _T1, _T0），对于每个源操作数对应的临时变量（本例中 _T1 和 _T0），我们检查该临时变量是否已经存放在物理寄存器中，如果不是，则分配一个物理寄存器，并从栈帧中把该临时变量加载到寄存器中；对于目标操作数对应的临时变量（本例中的 _T2），如果该临时变量没有对应的物理寄存器，则为其分配一个新的物理寄存器。寄存器分配过程中，将为临时变量和为该变量分配的物理寄存器之间建立一种关联关系。 在分配寄存器时，首先检查是否存在空闲的寄存器（即尚未跟任何临时变量建立关联关系的寄存器），有则选择该寄存器作为分配结果。否则，检查有没有这样的寄存器，其所关联的临时变量在当前位置已经不是活跃变量了，这说明该寄存器所保存的数据未来不会被用到，可以回收使用这个寄存器而不用担心引起数据错误。一种可能的情况是，所有寄存器所关联的变量都是活跃的，即不存在空闲的寄存器。此时，将把某个寄存器所关联的暂时不用的变量存到栈帧（内存的一部分）中，腾出这个寄存器，这也称为溢出（spill）到内存。所腾空的寄存器是随机选取的，因此，所采用的寄存器分配算法有些暴力，存在进一步优化空间。 在实验框架中已经给出寄存器分配算法的代码，集中在 backend/reg/bruteregalloc.py 中，主要有以下几个函数： accept：根据每个函数的 DFG（数据流图）进行寄存器分配，寄存器分配结束后生成相应汇编代码。 bind：将一个 Temp（临时变量）与寄存器绑定。 unbind：将一个 Temp（临时变量）与相应寄存器解绑定。 localAlloc：根据活跃变量信息对一个 BasicBlock（基本块）内的指令进行寄存器分配。 allocForLoc：每一条指令进行寄存器分配。 allocRegFor：根据活跃变量信息决定为当前 Temp（临时变量）分配哪一个寄存器。 栈帧 上面的描述中提到，在分配寄存器的时候从栈帧中加载数据，以及将暂时不用的变量存储到栈帧中，接下来介绍栈帧的概念。 栈帧的概念 在汇编语言课程学习中，大家应该已经接触到栈帧的概念，下面简单回顾一下。在程序执行过程中，每次调用和执行一个函数，都会在栈上开辟一块新的存储空间，这块存储空间就叫做“栈帧”。栈帧中存放了函数执行所需的各种数据，包括需要临时保存的局部变量、在栈上临时申请的存储空间（如数组，在 Step11 中介绍）、被调用者负责保存的寄存器等。栈帧是函数正确调用和执行的保证。 需要注意的是，由于我们目前只支持一个 main 函数，直到 Step9 才会有多函数支持。所以现在关于栈帧的讨论，就只针对 main 函数的栈帧，并且集中于临时变量的存储和加载。 假设当前函数被某个函数调用，下图给出当前函数的栈帧。如图所示，当前函数的栈帧由被调用者负责保存的寄存器、保存的临时变量以及局部变量三个部分组成，fp 指向当前栈帧的栈底，sp 指向当前栈帧的栈顶，fp 和 sp 之间的部分就是当前函数的栈帧。当前实验步骤中，需要关注的是临时变量保存区域，正是在这个区域中，保存了为腾空物理寄存器而取出的临时变量（仍然活跃的临时变量）。值得一提的是，临时变量保存区域中还保存了基本块出口处仍活跃的临时变量（关于基本块的概念，将在 Step6 介绍，在当前的步骤不需要考虑）。 栈帧的建立与销毁 栈帧是函数运行所需要的上下文的一部分，在进入函数的时候需要建立对应的栈帧，在退出函数的时候需要销毁其对应的栈帧。栈帧对于函数的运行非常重要。那么程序在运行的过程中如何建立和销毁栈帧呢？实际上，建立栈帧的操作是由编译器生成代码完成的。在每个函数的起始位置，由编译器生成的用于建立栈帧的那段汇编代码称为函数的 prologue。prologue 所做的事情包括：分配栈帧空间和保存相应寄存器的值。相应的，在每个函数的末尾，用于销毁栈帧的那段汇编代码称为函数的 epilogue。epilogue 所做的事情包括：设置返回地址，回收栈帧空间，以及从当前被调用函数过程返回 貌似创建和销毁栈帧是一个大工程？实际不然，确定栈帧只需要维护好两个寄存器，sp 和 fp，它们分别保存当前栈帧的栈顶地址和栈底地址。当新的函数被调用时，需要把旧栈帧的栈底地址（fp）保存起来，用旧栈帧的栈顶地址（sp）表示新栈帧的栈底地址（新fp）。不难看出，新老栈帧在栈内存中是连续的存储空间。此外，每个函数体中需要分配的局部变量以及需要保存的临时变量在编译过程中是可知的。因此，栈帧的大小在编译期可以计算得出，即存储寄存器的空间，临时变量存储空间与局部变量空间三者之和。在求得栈帧大小之后，可以通过修改栈顶指针（sp）的值来分配恰当的栈帧空间。 一个例子 #include int calculate() { int a = 1; int b = 2; int c = 3; int d = 4; int e = 5; int result = a + b + c + d + e; return result; } int main() { int result = calculate(); printf(\"%d\\n\", result); return 0; } 在这个示例中，我们在 calculate 函数内部声明了 5 个局部整数变量（a 到 e）。假设我们的处理器只有 4 个通用寄存器，在这种情况下，我们无法将 5 个局部变量都保存在寄存器中。因此，编译器需要在栈上分配空间来存储这些变量。以下是栈空间的变化过程： main 函数调用 calculate 函数，将返回地址压入栈中。 calculate 函数执行 prologue，将 fp 的值保存到栈中，然后将 sp 的值赋给 fp，此时 fp 和 sp 的值相同，都指向栈顶。 calculate 函数分配栈帧空间，在这个例子中，假设 a 到 d 保存在寄存器中，e 保存在栈帧中，因此需要分配 4 字节的栈帧空间。sp 指向栈顶，因此 sp 的值减去 4，即可得到 e 的地址。 计算完成后，calculate 函数执行 epilogue，将 fp 的值赋给 sp，并恢复 fp 的值，然后将返回地址弹出栈中，跳转到返回地址。 思考题 请将你的整个stage-2作业放置在分支stage-2下，你可以通过git checkout -b stage-2创建一个新的分支并继承当前分支的修改。 我们假定当前栈帧的栈顶地址存储在 sp 寄存器中，请写出一段 risc-v 汇编代码，将栈帧空间扩大 16 字节。（提示1：栈帧由高地址向低地址延伸；提示2：risc-v 汇编中 addi reg0, reg1, 表示将 reg1 的值加上立即数存储到 reg0 中。） 有些语言允许在同一个作用域中多次定义同名的变量，例如这是一段合法的 Rust 代码（你不需要精确了解它的含义，大致理解即可）： fn main() { let a = 0; let a = f(a); let a = g(a); } 其中f(a)中的a是上一行的let a = 0;定义的，g(a)中的a是上一行的let a = f(a);。 如果 MiniDecaf 也允许多次定义同名变量，并规定新的定义会覆盖之前的同名定义，请问在你的实现中，需要对定义变量和查找变量的逻辑做怎样的修改？（提示：如何区分一个作用域中不同位置的变量定义？） 总结 Step5 主要涉及的知识为符号表、寄存器分配和栈帧，对于大家来说有一定的跳跃性和挑战性，希望大家能够尽早开始。 "},"docs/step5/spec.html":{"url":"docs/step5/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step5 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement* '}' type : 'int' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step5 语义规范 5.1 每一条变量声明（定义）指定了对标识符的解释和属性。当变量被定义时，应当有一块存储空间为这个变量所保留。当变量声明之后，若与这个变量的名称相同的标识符作为操作数（operand）出现在一个表达式中时，其就应被指派（designate）为这个变量。 5.2 变量的初始化表达式指定了变量的初始值。 5.3 同一个标识符应只能作为至多一个变量的名字，即是说，不允许声明重名变量。 5.4 对未声明的变量的使用是错误。 5.5 没有被初始化的（局部）变量的值是不确定的。 在初始化表达式中，正在被初始化的变量已被声明，但其值尚未被初始化。 例如，int a = a + 1;，这样一条声明在语义上等价于 int a; a = a + 1; 5.6 局部变量的名字可以为 main。 5.7 赋值运算 = 的左操作数必须是一个可修改的左值（modifiable lvalue）。左值（lvalue）即一个会被指派为某个变量的表达式，如在 int a; a = 1; 中，a 即是一个会被指派为变量的表达式。左值可修改是指被指派的变量不能是一个左值数组。 就 step5 来说，这一点其实几乎已经被语法保证，因为其 = 的左边只能是一个标识符，只需再要求其是一个已经声明过的变量的名字即可。 5.8 在赋值运算（=）中，右操作数的值会被存在左操作数所指派的变量中。 5.9 赋值表达式的结果，为赋值运算完成后左操作数所指派的变量的值，但这个结果本身并非左值。 5.10 一个函数中可以有任意多条 return 语句。 5.11 当 main 函数执行至 } 时，应终止执行并返回 0。 "},"docs/step6/intro.html":{"url":"docs/step6/intro.html","title":"实验要求","keywords":"","body":"实验指导 step6：作用域和块语句 step6 我们要增加块语句的支持。 虽然块语句语义不难，就是把多个语句组成一个块，每个块都是一个作用域。 随之而来一个问题是：不同变量可以重名了。 重名的情况包括作用域内部声明覆盖（shadowing）外部声明，以及不相交的作用域之间的重名变量。 因此，变量名不能唯一标识变量了，同一个变量名 a 出现在代码不同地方可能标识完全不同的变量。 我们需要在符号表构建的过程中，确定 AST 中出现的每个变量名分别对应那个变量。 语法上改动不大 function : type Identifier '(' ')' compound_statement compound_statement : '{' block_item* '}' statement : 'return' expression ';' | compound_statement block_item : statement | declaration 语义检查我们也要修改了，只有在同一个作用域里，变量才不能重复声明。 当然，如果变量在使用前还是必须先被声明。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 3 的实验报告需要放在 stage-3 这个 branch 下的 ./reports/stage-3.pdf。注意报告的标题是 stage-3 而不是 step-6。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step6/example.html":{"url":"docs/step6/example.html","title":"通过例子学习","keywords":"","body":"step6 实验指导 本实验指导使用的例子为： int main() { int x = 1; { x = 2; int x = 3; } x = 4; return x; } 词法语法分析 针对块语句，我们需要设计 AST 节点来表示它，给出的参考定义如下： 节点 成员 含义 Block 子语句列表 children 语句块 语义分析 从 Step6 开始，我们需要考虑作用域和代码块。简而言之，一份代码中可能有多个代码块的嵌套，因此作用域开始出现了层次结构。例如，在示例中，尽管 main 函数里定义了变量 x，但随后我们开启了一个新的代码块。在这个代码块中，赋值语句 x = 2; 中的 x 就是指 main 作用域中定义的 x，而随后通过 int x = 3; 我们定义了另一个变量 x，这个 x 只在内部大括号括起的作用域内生效。 在 Step5 中，我们只维护了 main 的作用域，所有符号都在这个作用域的符号表中维护。现在，为了维护层次嵌套的作用域，我们引入了作用域栈（Scope Stack）这个数据结构。在进行符号表构建的扫描过程中，我们需要动态维护作用域栈，保存当前扫描结点所在的从内到外所有作用域。每次我们开启一个代码块时，要新建一个作用域并压栈；而当退出代码块时，要弹栈关闭此作用域。 接下来针对上述代码示例，讲述作用域栈的维护方式。首先，栈底有一个全局作用域，其符号表里只有 main 函数。由于目前不需要考虑函数和全局变量，可以暂时忽略全局作用域。进入 main 函数时，开启一个局部作用域，在扫描 int x = 1; 时定义变量符号 x，并将其加入栈顶作用域对应的符号表中。如下所示： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域（栈顶） 变量 x 接下来，扫描到一个局部代码块，由此建立一个局部作用域并压栈。在扫描 x = 2; 时，我们需要分析 x 这个变量对应着哪个作用域里的符号。此时的作用域栈是这样的： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域 变量 x 局部作用域（栈顶） 空 对变量x的查找从栈顶开始，由上向下依次查找对应的符号表，直至找到变量 x 为止。由于在栈顶作用域对应的符号表中不存在变量符号 x，于是向下继续查找。在 main 函数对应的作用域中，可以找到变量符号 x。因此，语句 x = 2; 中的 x 对应 main 函数作用域里定义的变量 x。 接下来，当扫描到语句 int x = 3; 时，定义了另一个变量 x。此时，只需要在栈顶作用域中查找该变量是否存在。若不存在，即在符号表中加入对应符号。此时的作用域栈如下： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域 变量 x 局部作用域（栈顶） 变量 x 请务必注意上表中的两个变量 x 是不同的变量。 接下来，退出代码块，将其对应的作用域弹出栈，此时的作用域栈如下： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域（栈顶） 变量 x 最后，扫描语句 x = 4; 时，从栈顶作用域符号表查找 x，所找到的变量 x 为 main 作用域定义的 x 变量。 中间代码生成 本步骤中无须新增新的 TAC 指令。 让我们来看看示例所对应的 TAC 代码： main: _T1 = 1 _T0 = _T1 # int x = 1; _T2 = 2 _T0 = _T2 # x = 2 _T4 = 3 _T3 = _T4 # int x = 3; _T5 = 4 _T0 = _T5 # x = 4; return _T0 显然，两个代码块里的变量 x 是不同的变量，因此它们分别对应着不同的临时变量。其中，_T0 对应着 main 作用域里的 x，而 _T3 则对应着内层代码块定义的变量 x。只要同学们在符号表构建阶段把每个变量和正确作用域的变量符号关联起来，这一步就非常简单了：找到对应变量符号，使用该符号对应的临时变量即可。 目标代码生成 不需要新增新的中间代码指令。 代码框架需要同学们对寄存器分配相关的 CFG 的内容进行细微修改。具体来说，需要在 backend/dataflow/cfg.py 中添加基本块是否可达的判断。在寄存器分配算法 backend/reg/bruteregalloc.py 的注释中，我们给出了提示，如果一个基本块不可达，那么无须为它分配寄存器。 实现提示 在 step5 中，namer/typer 遍历时的上下文信息(参数 ctx)是单一的作用域。到了 step 6，你需要按照实验指导书中描述，把上下文信息改成“作用域栈”。也即定义 class Namer(Visitor[Scope, None]) 应改为 class Namer(Visitor[YourType, None])，其中 YourType 是你的作用域栈类型，你可以任意命名它。我们推荐把这个类的定义放在 frontend/scope/ 下。class Typer 也需要如上改动。 之前 step5 的全局唯一的作用域可以被当作“函数作用域使用”，在 visitFunction 入栈。然后在新的 visitBlock 中，再进一步将局部作用域压栈。最后，在所有这些方法的末尾，不要忘了把对应作用域退栈。 当只有一个作用域时，“不可以定义新变量a”就意味着当前“可以获取变量a的值”，反之亦然，所以“定义变量”和“获取变量”的检查都可以用 Scope.lookup 实现。但有了多个作用域之后，就出现了“既可以拿到a的值，也可以重新定义一个a”的情况。这需要重新考虑 Typer / Namer 中的每一个 Scope.lookup ，看她们是否需要换成新函数。 后续 stage-4 时，你需要一个机制来检查 break/continue 语句是否在一个循环内。这可以通过修改 namer/typer 中的对应结点来实现。另外，别忘了循环本身也是一个作用域！ 后续如果你选做“全局变量”部分，可以在 Namer 和 Typer 的 transform 方法中先将全局作用域加入栈底，再往上才是 visitFunction 的函数作用域。 思考题 请画出下面 MiniDecaf 代码的控制流图。int main(){ int a = 2; if (a "},"docs/step6/dataflow.html":{"url":"docs/step6/dataflow.html","title":"数据流分析","keywords":"","body":"数据流分析 编译优化的基础是数据流分析。 基本块（basic block）和控制流图（control-flow graph）是用于进行上述分析的数据结构。 以下讲述数据流分析的内容中，所有的 CondBranch 指令为条件跳转指令，Branch 指令为跳转指令。 基本块 基本块是指一段这样的代码序列： 除出口语句外基本块中不含任何的 Branch、Beqz（条件为假时跳转）、Bnez（条件为真时跳转）或者 Return 等跳转语句（但可以包含 Call 语句）。 除入口语句外基本块中不含任何的 Label 标记，即不能跳转到基本块中间。 在满足前两条的前提下含有最多的连续语句，即基本块的头尾再纳入一条语句将会违反上面两条规则。 下面的例子中，代码中不同的基本块被标以不同的颜色： 也就是说，基本块内的代码执行过程总是从基本块入口开始，到基本块出口结束的，中间不会跳到别的地方或者从别的地方跳进来。 控制流图 控制流图是一个有向图：它以基本块作为结点，如果一个基本块 A 执行完之后，有可能跳转到另一个基本块 B，则图中包含从 A 对应结点到 B 对应结点的有向边。对于以 Branch 语句或者任何非跳转语句结尾的基本块，其后继只有一个结点；对于以 CondBranch 语句结尾的基本块，其后继含有两个结点，分别对应跳转条件为真和假的情况。不难想像，控制流图的有向边组成的每一个环路都对应着程序中的一个循环结构。由于该图给出程序控制流的各种可能执行路径，因此也称为控制流图。 为进行编译优化，建立控制流图是必不可少的一步。已知一个操作序列，如何根据这个操作序列建立对应的控制流图呢？通常分为两步进行： 划分基本块。 建立基本块之间的连接关系。 基本块的划分算法比较简单：从头到尾扫描操作序列，当遇到以下情况时结束当前基本块，并开始一个新的基本块建立过程： 当遇到一个 Label 标记而且存在跳转语句跳转到这个行号时。 当遇到 Branch、CondBranch 或者 Return 等跳转语句时。 整个操作序列扫描完毕后，我们就成功建立了所有基本块。 在划分好基本块之后，需要从头到尾依次扫描所有的基本块建立控制流图： 如果当前基本块以 Branch 结尾，则在当前基本块与所跳转到的目标基本块之间加入一条有向边。 如果当前基本块以 CondBranch 结尾，则在当前基本块和跳转条件成立与不成立的目标基本块之间分别加入一条有向边（共 2 条边）。 如果当前基本块以 Return 结尾，则不需要加入新的边。 在所有的基本块都扫描完毕后，即建立了控制流图。基于控制流图，可以进行控制流分析。 上面例子对应的控制流图如下： 活跃变量和活跃变量方程 从编译器中端出来的中间代码中，我们对 TAC 中使用的临时变量的个数并没有做任何限制。但是在实际机器中，物理寄存器的数量是有限的。 因此我们需要想办法把这些无限多的临时变量“塞”到有限个物理寄存器里面：如果两个临时变量不会在同一条指令中被用到，那么我们可以让这两个临时变量使用同一个物理寄存器（把一部分当前指令用不到的临时变量保存到栈上）。 根据这样的原则，大多数的临时变量都可以用有限的几个物理寄存器对应起来，而“塞不下”的那些临时变量，则可以暂时保存到内存里面（因为访问内存的时间比访问寄存器的时间多得多，因此临时变量应尽可能一直存放在物理寄存器中，尽量不要 spill 到栈上）。 由于一个物理寄存器在确定的时刻只能容纳一个临时变量，因此为了把若干个变量塞到同一个物理寄存器里面，我们需要知道各个临时变量分别在哪条指令以后不会再被用到（以便腾出当前临时变量占用的物理寄存器给别的临时变量）。此时我们需要用到活性分析（liveness analysis），或者称为“活跃变量分析”。 一个临时变量在某个执行点是活的（也叫“活跃”、live），是指该临时变量在该执行点处具有的值会在这个执行点以后被用到，换句话说，就是在该执行点到给这个临时变量重新赋值的执行点之间存在着使用到这个临时变量的语句。活性分析是指分析每一个临时变量在程序的每一个执行点处的活跃情况，通常是通过计算出每个执行点处的活跃变量集合来完成。 下面代码中每行语句右边都给出了执行完该语句后的活跃变量集合： TAC 代码 活跃变量集合 _T0 = 4 {_T0} _T1 = 3 {_T0, _T1} _T2 = _T0 * _T1 {_T0} _T3 = _T0 * _T0 {_T0, _T3} _T2 = _T3 * _T3 {_T0, _T2, _T3} _T2 = _T0 * _T2 {_T2, _T3} _T1 = _T2 * _T3 {_T1} return _T1 空集 一般来说，活性分析是通过求解活跃变量方程来完成的。为了介绍活跃变量方程的概念， 我们需要先引入下面四种针对基本块的集合： Def 集合：一个基本块的 Def 集合是在这个基本块内被定值的所有变量。所谓的定值 （definition），可以理解为给变量赋值，例如加法语句给目标变量定值等（注意：Store 语句不给任何变量定值，Load 语句则会给对应变量定值）。 LiveUse 集合：一个基本块的 LiveUse 集合是在这个基本块中所有在定值前就被引用过的变量，包括了在这个基本块中被引用到但是没有被定值的那些变量。 LiveIn 集合：在进入基本块入口之前必须是活跃的那些变量。 LiveOut 集合：在离开基本块出口的时候是活跃的那些变量。 其中 Def 和 LiveUse 是基本块本身的属性，对每个基本块从后往前遍历基本块内的指令便可以求出。 有了基本块的这四个集合的概念，我们给出控制流图中每个基本块满足的活跃变量方程: 该方程说的是一个基本块的 LiveOut 集合是其所有后继基本块的 LiveIn 集合的并集，而且 LiveIn 集合是 LiveUse 集合的变量加上 LiveOut 集合中去掉 Def 集合以后的部分。 这个方程的直观意义是： 一个基本块的任何一个后继基本块入口处活跃的变量在这个基本块的出口必须也是活跃的。 在一个基本块入口处需要活跃的变量是在该基本块中没有定值就被使用的变量，以及在基本块出口处活跃但是基本块中没有定值过的变量（因为它们的初值必定是在进入基本 块之前就要具有的了）。 根据这个方程，我们可以通过迭代更新的办法求出每个基本块的 LiveIn、LiveOut 集合，以下是求解的伪代码： for i 获得了每个基本块的 LiveIn 和 LiveOut 集合以后，我们需要进一步地计算基本块内每个 TAC 语句的 LiveIn 和 LiveOut 集合。如果我们把基本块内所有 TAC 语句分别看成是一个独立的基本块，则不难想像，前面提到的活跃变量方程仍然有效，不同之处在于，一个基本块对应的 “控制流图” 有以下三种特点： 每个节点的出度都是 1，也就是说 LiveOut(B) = LiveIn(Succ(B))。 由于每个结点只含有一个语句，因此其 Def 集要么是空集，要么只含有一个元素。 由于每个结点对应的语句里所引用的所有变量在使用的时候都未在该基本块中经过定值，其 LiveUse 集合就是源操作数对应的所有变量。 基于上面三个特点，已经求出基本块的 LiveOut 集合的前提下我们只需要在每个基本块内从后往前遍历基本块内的指令就可以对每条基本块内指令求出 LiveIn、LiveOut。 "},"docs/step6/spec.html":{"url":"docs/step6/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step6 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | compound_statement declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step6 语义规范 6.1 根据其声明的位置，每一个标识符都属于一个作用域。目前我们有两种作用域：文件级和块级。如果是在块中声明，则标识符其声明所属的块的作用域中，例如局部变量；否则标识符在文件级（全局）作用域中，例如全局变量。 6.2 （更新 5.6）如果一个标识符在两个作用域里面，这两个作用域必然是嵌套的，即一个内层作用域完全被另一个外层作用域所覆盖。且在内层作用域中，外层作用域里该标识符所指派（designate）的变量或函数是不可见的。 在初始化表达式中，其正在初始化的变量已被声明，会隐藏（shadow）外层作用域的同名变量，但其值不确定。例如在下面的代码片段中，a + 1 的值是不确定的。 int a = 1; { int a = a + 1; } 6.3 （更新 5.3）对于同一个标识符，在同一个作用域中至多有一个声明。 6.4 （更新 5.4）使用不在当前开作用域中的变量名是不合法的。 "},"docs/step7/intro.html":{"url":"docs/step7/intro.html","title":"实验要求","keywords":"","body":"实验指导 step7： step7 我们要支持条件语句，包括 if 语句和条件表达式（又称三元/三目表达式，ternary expression）。 语法上的改动是： if 表达式 statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? 条件表达式 assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional if 语句的语义和 C 语言相同，注意条件表达式优先级只比赋值高。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 4 的实验报告需要放在 stage-4 这个 branch 下的 ./reports/stage-4.pdf。整个 stage 4 只需要提交一份报告，你不需要单独为 step 7 准备报告。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step7/example.html":{"url":"docs/step7/example.html","title":"通过例子学习","keywords":"","body":"step7 实验指导 本实验指导使用的例子为： int main() { int x = 1; if (x) x = 2; else x = 3; return x; } 词法语法分析 针对 if 语句，我们需要设计 AST 节点来表示它，给出的参考定义如下（框架中已经提供）： 节点 成员 含义 If 分支条件 cond，真分支 then，假分支 otherwise if 分支语句 仿照 if 节点，还需要类似地实现条件表达式节点。 悬吊 else 问题 这一节引入的 if 语句既可以带 else 子句也可以不带，但这会导致语法二义性：else 到底和哪一个 if 结合？ 例如 if(a) if(b) c=0; else d=0;，到底是 if(a) {if(b) c=0; else d=0;} 还是 if(a) {if(b) c=0;} else d=0;？ 这个问题被称为 悬吊 else（dangling else） 问题。 如果程序员没有加大括号，那么我们需要通过一个规定来解决歧义。 我们人为规定：else 和最近的 if 结合，也就是说上面两种理解中只有前者合法。 为了让 parser 能遵守这个规定，一种方法是设置产生式的优先级，优先选择没有 else 的 if。 按照这个规定，parser 看到 if(a) if(b) c=0; else d=0; 中第一个 if 时，选择没有 else 的 if； 而看到第二个时只能选择有 else 的 if ，也就使得 else d=0; 被绑定到 if(b) 而不是 if(a) 了。 需要说明的是 bison 默认在 shift-reduce conflict 的时候选择shift，从而对悬挂else进行就近匹配。 语义分析 本步骤中语义分析没有特别需要增加的内容，只需要在扫描到 if 语句和条件表达式时递归地访问其子结点即可。请注意 if 语句不总是有 else 分支，所以在递归到子结点时，请先判断子结点是否存在。 中间代码生成 从本步骤开始，由于 MiniDecaf 程序出现了分支结构，我们需要开始考虑跳转语句了。在 Step1-4 中，TAC 代码中的标签只有标志 main 函数入口这一个功能。而现在，我们需要使用标签来指示跳转指令的目标位置。我们用 _Lk 来表示跳转用标签，以此和函数入口标签区分开来。 为了实现 if 语句，我们需要设计两条中间代码指令，分别表示条件跳转和无条件跳转，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 作用 BEQZ T0, Label 若 T0 的值为0，则跳转到 LABEL 标签处 JUMP Label 跳转到 LABEL 标签处 现在让我们来看看示例所对应的 TAC 代码： main: _T1 = 1 _T0 = _T1 BEQZ _T0, _L1 _T2 = 2 _T0 = _T2 JUMP _L2 _L1: _T3 = 3 _T0 = _T3 _L2: return _T0 在这段 TAC 代码中，x 对应的临时变量为 _T0。如果 x 的值为真（不等于0），那么应当执行 then 分支 x = 2;，否则执行 else 分支 x = 3;。因此，我们设置了两个跳转标签 _L1 和 _L2，分别表示 else 分支开始位置和整个 if 语句的结束位置。如果 x 为假，那么应当跳转到 _L1 处，我们使用一条 BEQ 指令来执行。如果 x 为真，那么按顺序执行 then 分支的代码，并在该分支结束时，用一条 JMP 指令跳转到 if 语句的结束位置，从而跳过 else 分支。在 TAC 生成过程中，每当扫描到 if 语句时，都需要调用 TAC 的底层接口，新建两个跳转标签，并按照这种方式生成中间代码。 当然，如果一条 if 语句没有 else 分支，那么只需要一个跳转标签即可。例如我们将例子中的 if 语句修改为 if (x) x = 2;，则对应的 TAC 代码可简化为： main: _T1 = 1 _T0 = _T1 BEQ _T0, _L1 _T2 = 2 _T0 = _T2 _L1: return _T0 同样地，条件表达式也可以使用类似的方法完成中间代码生成。要注意的是，条件表达式是一种特殊的表达式，因此有返回值。同学们在实现的时候不要忘记为其分配临时变量。 目标代码生成 Step7 中目标代码生成主要是指令的选择以及 label 的声明，RISC-V 提供了与中间代码中 BEQZ 和 JUMP 类似的指令： step7: # RISC-V 汇编标签 beqz t1, step7 # 如果 t1 为 0，跳转到 step7 标签处 j step7 # 无条件跳转到 step6 标签处 思考题 我们的实验框架里是如何处理悬吊 else 问题的？请简要描述。 在实验要求的语义规范中，条件表达式存在短路现象。即： int main() { int a = 0; int b = 1 ? 1 : (a = 2); return a; } 会返回 0 而不是 2。如果要求条件表达式不短路，在你的实现中该做何种修改？简述你的思路。 总结 本节主要就是引入了跳转，后面 Step8 循环语句还会使用。 "},"docs/step7/spec.html":{"url":"docs/step7/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step7 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' block_item* '}' type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | compound_statement | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier 注意：if 的 then 分支和 else 分支需要是一个语句（statement）而非声明（declaration）。 例如 if (1) int a; 不是合法的 MiniDecaf 程序。 step7 语义规范 7.1 条件表达式会先对第一个操作数求值，再根据其值选择计算第二个或第三个操作数。当且仅当第一个操作数的值不等于 0，我们会对第二个操作数求值。当且仅当第一个操作数的值等于 0，我们会对第三个操作数求值。当第一个操作数的值为 0 时，条件表达式的求值结果为第二个操作数所求得的值；当第一个操作数的值非 0 时，条件表达式的求值结果为第三个操作数所求得的值。 不论选择第二个操作数或者是第三个操作数去求值，都必须首先计算完第一个操作数，之后才能开始第二个或第三个操作数的求值计算。 7.2 对于 if 语句而言，当控制条件不等于 0 时，会执行第一个子句；当控制条件等于 0 时，如果有 else 分支，就会执行第二个语句，否则整个 if 语句的执行便已经完成。 7.3 如果出现悬吊 else（dangling else），要求 else 优先和最接近的没有匹配 else 的 if 匹配。 例如 if (0) if (0) ; else ; 等价于 if (0) { if (0) ; else; } 而非 if (0) { if (0) ; } else ;。 "},"docs/step8/intro.html":{"url":"docs/step8/intro.html","title":"实验要求","keywords":"","body":"实验指导 step8：循环语句 step8 我们要增加对循环语句，以及 break/continue 的支持： statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' 循环语句的语义和 C 语言相同，注意检查 break/continue 不能出现在循环外。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 4 的实验报告需要放在 stage-4 这个 branch 下的 ./reports/stage-4.pdf。整个 stage 4 只需要提交一份报告，你不需要单独为 step 8 准备报告。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step8/example.html":{"url":"docs/step8/example.html","title":"通过例子学习","keywords":"","body":"step8 实验指导 本实验指导使用的例子为： for (int i = 0; i 词法语法分析 针对循环语句和 break/continue 语句，我们需要设计 AST 节点来表示它，给出的参考定义如下： 节点 成员 含义 While 循环条件 cond，循环体 body while 循环语句 For 初始语句 init，循环条件 cond，更新语句 update，循环体 body for 循环语句 Break 无 break 语句 Continue 无 continue 语句 其中，while 和 break 语句的实现已经在框架中给出，同学们可以参考并实现 for 和 continue 语句。 语义分析 本步骤语义分析阶段的处理方式和 Step7 中的 if 语句相类似，但是请额外注意以下两点： for 循环要自带一个作用域。在示例里，for (int i = 0; i 语句里定义的循环变量处于一个独自的作用域里。这也就是说，我们可以在循环体内部定义同名变量。如果我们把示例修改为：for (int i = 0; i 这也是合法的 MiniDecaf 程序。因此，在符号表构建阶段，扫描到 for 结点时，不要忘记开启一个局部作用域。 break 和 continue 语句必须位于循环体内部才合法。因此，在扫描过程中，需要记录当前结点位于多少重循环内。扫描到 break 和 continue 结点时，若当前不处于任何循环内，则报错。 中间代码生成 本步骤中没有需要新增的 TAC 指令。不过为了实现循环语句，需要仔细地考虑如何将 MiniDecaf 循环语句翻译成 TAC 的分支跳转指令。由于 while 循环可以看作 for 循环的特例，我们选择了 for 循环作为示例。 让我们先来看看示例对应的 TAC 代码： _T1 = 0 _T0 = _T1 # int i = 0; _L1: # begin label _T2 = 5 _T3 = LT _T0, _T2 BEQZ _T3, _L3 # i 为了实现所有可能的跳转，对每个 for 循环我们都需要定义三个跳转标签：begin, loop 和 break。它们的作用如下： begin 标签（示例中的 _L1）是循环体的开始位置。初次进入循环时，从这个标签的位置开始执行，并判断循环条件是否满足，若不满足，则跳转到 break 标签（示例中的 _L3）处。 loop 标签（示例中的 _L2）是执行 continue 语句时应当跳转到的位置。 break 标签是整个循环结束后的位置。如果循环条件不满足，或者执行了 break 语句，那么应当跳转到此处，执行循环之后的指令。 请注意，示例给出的只是一种循环语句参考实现，同学们也可以设计自己的实现方法。 由于循环语句可以嵌套，所以 TAC 语句生成过程中需要动态维护 loop 标签和 break 标签，这样才能确定每一条 break 和 continue 语句跳转到何处。因此，在 TAC 生成时，需要使用栈结构维护从内到外所有的 loop 标签和 break 标签。 utils/tacgen/tacgen.py 里的 TACFuncEmitter 类里实现了维护 TAC 生成时需要的上下文信息的功能。同学们可以在这个类中增加对循环所需的 break/continue 标签的维护。 目标代码生成 由于不需要增加新的中间代码指令，本步骤中目标代码生成模块没有新的内容。除非之前步骤的实现有误，否则这个步骤应该不会出现错误。 思考题 将循环语句翻译成 IR 有许多可行的翻译方法，例如 while 循环可以有以下两种翻译方式： 第一种（即实验指导中的翻译方式）： label BEGINLOOP_LABEL：开始下一轮迭代 cond 的 IR beqz BREAK_LABEL：条件不满足就终止循环 body 的 IR label CONTINUE_LABEL：continue 跳到这 br BEGINLOOP_LABEL：本轮迭代完成 label BREAK_LABEL：条件不满足，或者 break 语句都会跳到这儿 第二种： cond 的 IR beqz BREAK_LABEL：条件不满足就终止循环 label BEGINLOOP_LABEL：开始下一轮迭代 body 的 IR label CONTINUE_LABEL：continue 跳到这 cond 的 IR bnez BEGINLOOP_LABEL：本轮迭代完成，条件满足时进行下一次迭代 label BREAK_LABEL：条件不满足，或者 break 语句都会跳到这儿 从执行的指令的条数这个角度（label 不算做指令，假设循环体至少执行了一次），请评价这两种翻译方式哪一种更好？ 我们目前的 TAC IR 中条件分支指令采用了单分支目标（标签）的设计，即该指令的操作数中只有一个是标签；如果相应的分支条件不满足，则执行流会继续向下执行。在其它 IR 中存在双目标分支（标签）的条件分支指令，其形式如下： br cond, false_target, true_target 其中cond是一个临时变量，false_target和true_target是标签。其语义为：如果cond的值为0（假），则跳转到false_target处；若cond非0（真），则跳转到true_target处。它与我们的条件分支指令的区别在于执行流总是会跳转到两个标签中的一个。 你认为中间表示的哪种条件分支指令设计（单目标 vs 双目标）更合理？为什么？（言之有理即可） "},"docs/step8/spec.html":{"url":"docs/step8/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step8 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step8 语义规范 方便起见，我们称 for 循环括号中的三个表达式/声明自左向右依次为 init、ctrl 和 post。 例如 for (i=0; i 中，i=0 是 init，i 是 ctrl，i=i+1 是 post。 8.1 有两种循环语句：for 循环、while 循环。执行一条循环语句，意味着反复执行一条语句（即循环体），直到其控制表达式等于 0。 8.2 while 循环的控制表达式的求值在循环体的每次执行之前。 8.3 对于 for 循环而言：如果 init 是一个声明，其声明发生在控制表达式的第一次求值之前；如果 init 是一个表达式，其求值会在控制表达式的第一次求值之前。ctrl 即是控制表达式，其求值在循环体的每次执行之前。post 的求值在循环体的每次执行之后。 8.4 for 循环的 init、ctrl 和 post 都可以被省略。省略 ctrl 等价于将其替换为一个非零常数，比如 1。 8.5 循环语句有其自己的作用域，且是它所在的作用域的子集。循环体也有其作用域，且是循环语句的作用域的子集。如果 for 循环的 init 是一条声明，则其所声明的变量所属的作用域是整个 for 循环语句的作用域（包含 init、ctrl、post 和循环体）。 例如，for (int i=0;;i=i+1) { int i=1; return i; } 是合法的代码片段。 8.7 continue 语句和 break 语句要么出现在循环体里，要么其就是循环体。 8.8 执行一条 continue 语句，意味着将程序的执行跳转至该条 continue 语句所在的最小的循环语句的循环体的末尾。 例如，for (int i=0;i 等价于 for (int i=0;i。 8.9 执行一条 break 语句，意味着终止该条 break 语句所在的最小的循环语句的执行。 "},"docs/step9/intro.html":{"url":"docs/step9/intro.html","title":"实验要求","keywords":"","body":"实验指导 step9：函数 step9 开始，我们要支持多函数了。 我们需要支持函数的声明和定义： program : function* function : type Identifier '(' parameter_list ')' (compound_statement | ';') parameter_list : (type Identifier (',' type Identifier)*)? 我们还需要支持函数调用： expression_list : (expression (',' expression)*)? unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' 语义检查部分，我们需要检查函数的重复定义、检查调用函数的实参（argment）和形参（parameter）的个数类型一致。我们不支持 void 返回类型，这可以通过忽略函数的 int 返回值实现。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 5 的实验报告需要放在 stage-5 这个 branch 下的 ./reports/stage-5.pdf。注意报告的标题是 stage-5 而不是 step-9。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step9/example.html":{"url":"docs/step9/example.html","title":"通过例子学习","keywords":"","body":"step9 实验指导 本实验指导使用的例子为： int func(int x, int y) { return x + y; } int main() { return func(1, 2); } 词法语法分析 针对函数特性，我们需要设计 AST 节点来表示它，给出的参考定义如下： 节点 成员 含义 Function 返回类型 return_type，函数名 ident，参数列表 params，函数体 body 函数 Parameter 参数类型 var_type，变量名 ident 函数参数 Call 调用函数名 ident，参数列表 argument_list 函数调用 语义分析 本步骤中引入了函数，和局部变量类似，不允许调用未声明的函数，也不允许重复定义同名函数（允许重复声明，但要求声明类型一致）。因此，需要在全局作用域的符号表里维护函数符号。函数符号存放在栈底的全局作用域中，在遍历 AST 构建符号表的过程中，栈底符号表一直存在，不会被弹出。 此外，由于函数体内部除了局部变量以外，还有函数参数（argument）。因此，我们进入一个函数，开启函数体局部作用域时，需要将所有的参数加进该作用域的符号表中。举例来说，如果我们将示例改成： int func(int x, int y) { int x = 1; return x + y; } 那么语义检查时应当报错。 函数符号的实现在 frontend/symbol/funcsymbol.py 中。 中间代码生成 为了实现函数，我们需要设计至少一条中间代码指令来表示函数调用，给出的参考定义如下： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 CALL LABEL(T0, T1, ...) 调用函数 LABEL，传入的实参为T0、T1等 下面是一段含有函数调用的代码片段： T0 = CALL foo(T1, T2) T1和T2作为被调用函数foo的实参，而调用后的返回值保存在T0中。 实际上这与高级语言的函数语义非常相似。你可能会觉得一个与源语言语义几乎没差别的中间代码函数调用指令有点多余，所以我们也提供了另一种方案。 在早先的文档中，函数调用涉及CALL和PARAM两种指令。CALL指令只对应实际汇编代码的函数调用，而PARAM T0指令用于传递一个参数。 假设我们有若干个参数，可以依次使用 PARAM 命令将它们加入参数列表。在调用函数时，这些参数的值会自动依次按顺序装载到临时变量 _T0, _T1 ... 中。比如我们有这样一段 TAC 程序： PARAM A PARAM B PARAM C XX = CALL XXX 那么，在进入 XXX 函数时，相当于执行了： _T0 = A _T1 = B _T2 = C 因此，示例可以对应如下的 TAC 程序： func: _T2 = ADD _T0, _T1 return _T2 # 参数 x 和 y 分别对应 _T0, _T1 main: _T0 = 1 PARAM _T0 # 将 _T0 的值作为参数 x _T1 = 2 PARAM _T1 # 将 _T1 的值作为参数 y _T3 = CALL func # 调用函数 return _T3 同学们可以选择使用这两种方案中的任何一种，也可以自行设计函数调用的中间表示。 思考 在本次实验中我们设置了一道关于函数调用中间表示设计的思考题。下面的问题或许能帮助你思考（你无需回答这里的问题，这里也没有标准答案）： 中间表示应该更接近源语言（高级语言）还是目标语言（例如汇编语言）？ 到目前为止实验文档给出的参考中间表示更接近源语言还是目标语言？ 如果你感兴趣，可以了解一下LLVM IR。 目标代码生成 下面是一种可能的目标汇编代码，你的编译器生成的代码无需与其完全一致。 .text .global main func: # start of prologue addi sp, sp, -56 # end of prologue # start of body add t0, a0, a1 mv a0, t0 j func_exit # end of body func_exit: # start of epilogue addi sp, sp, 56 # end of epilogue ret main: # start of prologue addi sp, sp, -56 sw ra, 52(sp) # end of prologue # start of body li t0, 1 li t1, 2 mv a0, t0 mv a1, t1 call func mv t0, a0 mv a0, t0 j main_exit # end of body main_exit: # start of epilogue lw ra, 52(sp) addi sp, sp, 56 # end of epilogue ret 首先你需要参考之前步骤中实现的方法，翻译本步骤中新增的中间代码指令。 完成这个步骤的过程中你可能需要回顾step 2中对于后端翻译的介绍和step 5中对于寄存器分配和栈帧的介绍来回想一下后端每个部分在做什么。 函数调用 程序代码里的一个函数调用，包含了下面一系列的操作： （汇编）保存 caller-saved 寄存器。 准备参数，完成传参。 执行汇编中的函数调用指令，开始执行子函数直至其返回。 拿到函数调用的返回值，作为函数调用表达式的值。 具体依赖于1的处理方式，可能需要恢复 caller-saved 寄存器。 上述步骤 1-5 称为调用序列（calling sequence）。然而，调用序列中有一些问题需要解决：如何进行参数传递？如何获取函数返回值？调用者（caller）和被调用者（callee）需要保存哪些寄存器，如何保存？调用者和被调用者通常对以上问题约定解决方式，并同时遵守这些约定。这些调用者与被调用者共同遵守的约定称为调用约定（calling convention）。调用约定通常在汇编层级使用，汇编语言课上也有涉及。因为汇编语言是低级语言，缺乏对函数的语言特性支持，只有标号、地址、寄存器，所以需要调用约定，规定如何用汇编的语言机制实现函数调用。 调用约定 我们给出RISC-V标准调用约定供大家参考，你可以不按照标准调用约定实现，这样的话你需要自己定义一种调用约定。如果你实现的是标准调用约定，你的编译器生成的代码还可以与gcc生成的代码进行链接，比如链接标准库，实现输入输出等功能。 RISC-V 的标准调用约定 caller-saved 和 callee-saved 寄存器 上表给出 RISC-V 中 32 个整数寄存器的分类。所谓 caller-saved 寄存器（又名易失性寄存器），是指不需要在各个调用之间保存的寄存器，如果调用者认为在被调用函数执行结束后仍然需要用到这些寄存器中的值，则需要自行保存。所谓 callee-saved 寄存器（又名非易失性寄存器），指这些寄存器需要在各个调用之间保存，调用者可以期望在被调用函数执行结束后，这些寄存器仍保持原来的值。这要求被调用者，如果使用这些寄存器，需要先进行保存，并在调用返回之前恢复这些 callee-saved 寄存器的值。 具体的保存方法并不限制，但一般都使用栈来保存。 函数参数以及返回值的传递 函数参数（32 位 int）从左到右存放在 a0 - a7 寄存器中，如果还有其他参数，则以从右向左的顺序压栈，第 9 个参数在栈顶位置。同学们可以使用编写一个带有多个参数的函数并进行调用，然后用 gcc 编译程序进行验证。 返回值（32 位 int）放在 a0 寄存器中。 实战教学 我们推荐大家按照以下步骤实现，当然这不是唯一的实现方式。前中端的部分在前面的step中涉及很多，大家应该已经比较熟悉，这里着重关注后端要做的事。 要做什么 由于调用约定的存在，中间表示里的函数调用指令无法像我们之前接触到的常规指令一样简单地翻译为实际汇编指令，我们必须生成额外代码进行寄存器保存、参数传递等操作以符合调用约定。这些额外操作会出现在真正的函数调用指令call周围，我们称之为“（生成）函数调用时的处理”或“对于调用者的处理”。 只是让caller调用函数的过程遵循调用约定还不够，被调用的每个函数callee也要遵守规范，保存恢复callee-saved寄存器、从正确的位置获取caller传入的参数。因为每个函数都是（潜在的）被调用者，故对于所有函数都要生成这些操作。我们称之为“生成函数体时的处理”或“对于被调用者的处理”。 你在后端主要需要实现的即为“对于调用者的处理”与“对于被调用者的处理”两部分。 对于调用者的处理 这里我们需要关注源文件backend/reg/bruteregalloc.py中的BruteRegAlloc类。 根据调用约定，调用其它函数后caller-saved即volatile寄存器中的值全部是无效的。这意味着如果函数调用前caller-saved寄存器中存放了后续仍活跃的临时变量，它们必须被倒腾到别的地方，如callee-saved寄存器或栈上。因此我们先将活跃且在caller-saved寄存器中的临时变量保存到栈上，这实际上让所有caller-saved寄存器变得空闲，以便于接下来在a0到a7中容纳参数。 保存活跃的临时变量：首先保存所有位于caller-saved寄存器中且活跃的临时变量，然后解除所有caller-saved寄存器与临时变量的绑定关系。你可以用subEmitter.emitStoreToStack和unbind来达到上述效果。 这是否意味着原本就在caller-saved寄存器中的参数也被丢到了栈上？似乎有些多余？ 是的，但这样处理比较简单。比较理想的方案是直接将参数从一个寄存器复制到目标参数寄存器，但这可能带来一些边角情况，你需要谨慎处理。 将参数放入寄存器：所有传参用到的寄存器(a0~a7)都是caller-saved寄存器，1中的操作保证了传参所需要的寄存器都是空的，因此直接将参数放到寄存器中即可。具体地，用物理寄存器a0~a7传递被调用函数的前8个参数，我们假设这8个参数对应的临时变量（Temp）为v0~v7。对于第i个参数，目标是将vi的值加载入ai。若vi已经与某个物理寄存器xj绑定，则可以生成指令mv ai, xj；如果vi的值不在物理寄存器中，调用emitLoadFromStack。（思考： 如果前面暂时不解除volatile寄存器的绑定，这里可能会有什么问题？ 你有更高效的解决方案吗？） 为什么有的临时变量可能在寄存器中？ 因为我们在步骤1中只操作了caller-saved寄存器。如果某个临时变量存放在callee-saved寄存器中，那么它不会在上一步骤被放到栈上。 用栈传递参数（可选）：调用约定规定a0至a7存放不下的参数需要用栈传递（为了降低大家的实现难度，基础实验中我们不对参数超过8个的传参实现进行测试）。若参数vi在物理寄存器xj中，则直接将xj“压栈”；否则任选一个a0~a7之外的volatile寄存器tk，我们先通过emitLoadFromStack将vi加载到tk，然后“压栈”tk（建议直接使用t0寄存器）。需要注意这里的“压栈”不能直接用emitStoreToStack，我们需要手动生成一条NativeStoreWord指令，而且它无需也不应该修改栈指针sp。在所有参数入栈后，统一修改sp。 进行真正的函数调用：可以使用emitNative来生成一条调用指令。如果上一步中存在栈传参，别忘了在调用后把sp改回来（清除栈上传递的参数）。 妥善处理函数返回值：根据调用约定，函数返回值会存放在a0寄存器中。如果你在指令选择中为函数调用单独增添了将a0复制到目标临时变量的指令，这里无需处理。你也可以选择直接将目标临时变量绑定到a0。 记录函数调用情况（可选）：你也许需要在SubroutineEmitter中记录当前函数是否调用过其它函数，以便减少不必要的ra保存和恢复。 对于被调用者的处理 这里我们需要关注源文件backend/riscv/riscvasmemitter.py中的RiscvSubroutineEmitter类和backend/reg/bruteregalloc.py中的BruteRegAlloc类。被调用者需要从正确的位置获取到传入的参数，因此需要处理寄存器和临时变量的对应关系；同时在被调用函数的结尾我们要准确无误地返回到调用处，因此需要处理和返回地址相关的信息。 处理返回地址：具体需要保存和恢复ra寄存器，相关实现在emitFunc函数中。框架的现有部分已经帮助大家处理好了callee-saved寄存器的保存和恢复，你可以参照这部分实现ra寄存器的保存和恢复。（备注：严格来讲ra并不是callee-saved寄存器。ra会在什么情况下被修改？不过你可以选择总是保存和恢复ra。） 处理传入的函数参数和临时变量的对应关系：将传入的参数与临时变量绑定，这样在函数体中就可以直接使用这些参数。BruteRegAlloc类中的的bindings变量记录了临时变量和物理寄存器的对应关系，你可以使用bind, unbind函数来完成这些操作。思考应该在何处进行这个绑定操作。 一些可能带来困惑的地方 ra是一个caller-saved寄存器，但它有着和callee-saved寄存器相似的处理方式。一般而言只有当某个函数作为caller调用了其它函数时，它存放在ra中的返回地址才会被覆盖掉，这与其它caller-saved寄存器类似。然而鉴于ra的特殊用途，你可以把它视作一个callee-saved寄存器。 你可能会发现我们的框架能支持的栈空间大小有限，存放不了太多的临时变量。目前而言的确是这样，你无需考虑那种情况。 思考题 你更倾向采纳哪一种中间表示中的函数调用指令的设计（一整条函数调用 vs 传参和调用分离）？写一些你认为两种设计方案各自的优劣之处。 具体而言，某个“一整条函数调用”的中间表示大致如下： _T3 = CALL foo(_T2, _T1, _T0) 对应的“传参和调用分离”的中间表示类似于： PARAM _T2 PARAM _T1 PARAM _T0 _T3 = CALL foo 为何 RISC-V 标准调用约定中要引入 callee-saved 和 caller-saved 两类寄存器，而不是要求所有寄存器完全由 caller/callee 中的一方保存？为何保存返回地址的 ra 寄存器是 caller-saved 寄存器？ 总结 到这里，你已经完成了所有基础实验。有了对函数的支持，你的编译器也变得更加强大，你可以试着用它写一些更有意思的代码。 "},"docs/step9/spec.html":{"url":"docs/step9/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step9 语法规范 灰色部分表示相对上一节的修改。 program : function* function : type Identifier '(' parameter_list ')' ( compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier 我们暂不要求支持不包含函数体的函数声明。 step9 语义规范 9.1 在函数调用中，实参和形参的参数个数必须相同，同一位置的参数类型也必须相同。 9.2 在准备函数的调用时，所有的实参会被求值，然后赋给相应位置上的形参。 在函数体中，形参的值可能会被改变，但即便实参是一个可修改的左值，被调用函数中形参的改变也不会影响实参的值。 9.3 函数是可以递归调用的。 9.4 （更新 5.10）执行一条 return 语句，意味着终止当前函数的执行，并将控制权交还给调用当前函数的 caller，语句中的表达式的值会返还给 caller 作为函数调用的表达式的值。一个函数可以有任意多条 return 语句。 9.5 函数的形参可以被视为在函数体的开头被定义（被以实参的值初始化）的局部变量。所有形参均为左值，且不能被在函数体中直接重定义（除非是在一个更小的嵌套的块中）。 例如，int f(int x) { int x; } 不合法，但 int f(int x) { { int x; } } 合法。 9.6 如果一个不是 main 的函数执行到了它的 }，且其返回值被 caller 所使用，则这是一个未定义行为。 对于感兴趣的同学：C 语言中规定只有使用了返回值才是未定义行为，而 C++ 中规定不管返回值有没有被使用，都是未定义行为。 我们没有支持 void 类型，但可以忽略返回值达到类似的效果。 “执行到了 }” 意味着执行时没有通过 return 返回，例如 int f(){if(0) return 0;}。 实现的时候，你可以直接让所有函数都默认返回 0，语义规范说 main 之外的函数没有 return 是未定义行为，未定义行为的意思就是你想怎么处理都可以，所以全部默认返回 0 当然也是可以的，而且更清晰简单。 "},"docs/step10/intro.html":{"url":"docs/step10/intro.html","title":"实验要求","keywords":"","body":"实验指导 step10：全局变量 step10 我们要支持的是全局变量，语法改动非常简单： program : (function | declaration)* 全局变量和局部变量不同，它不是分配在栈上，而是放在某个固定地址，写在汇编的 .bss 段或 .data 段里。 访问它也不能通过 fp 加偏移量，而是需要通过它的符号加载它的地址，通过它的地址访问它。 汇编课上应该讲过，实际中（包括 gcc 和 qemu）使用的可执行文件的格式是 ELF（Executable and Linking Format）。 .text 是其中存放代码的段（section），.bss 和 .data 都是其中存放数据的段，前者零初始化后者须指定初始值。 对有兴趣的同学： 全局变量地址不是被狭义上的编译器（compiler）确定的，也不是被汇编器（assembler）确定的，而是被链接器（linker）或加载器（loader）确定的。 简单的说，狭义上的编译器把源代码变成文本汇编，汇编器把文本汇编给编码到二进制代码，然后通过链接器变成可执行文件，运行时由加载器加载到内存中运行。 当然，广义上的编译器就囊括了这所有阶段。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 6 的实验报告需要放在 stage-6 这个 branch 下的 ./reports/stage-6.pdf。整个 stage 6 只需要提交一份报告，你不需要单独为 step 10 准备报告。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step10/example.html":{"url":"docs/step10/example.html","title":"通过例子学习","keywords":"","body":"step10 实验指导 本实验指导使用的例子为： int x = 2024; int main() { return x; } 词法语法分析 针对全局变量，我们需要新设计 AST 节点来表示它，只需修改根节点的孩子类型即可：原先表示整个 MiniDecaf 程序的根节点只能有函数类型的子节点，现在还可以允许变量声明作为子节点。 语义分析 本步骤引入全局变量，在引入全局变量之后，AST 根结点的直接子结点不只包括函数，还包括全局变量定义。全局变量符号存放在栈底的全局作用域符号表中。在遍历 AST 构建符号表的过程中，栈底的全局作用域符号表一直都存在，不会被弹出。 中间代码生成 经过 Step5 的学习，我们知道局部变量是存储在寄存器或栈中的，可以直接访问。然而，全局变量存储在特别的内存段中，不能直接访问。课程实验建议的加载全局变量方式为：首先加载全局变量符号的地址，然后根据地址来加载数据。因此，需要定义两个中间代码指令，完成全局变量值的加载： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 LOAD T1, offset 临时变量 T1 中存储地址，加载与该地址相差 offset 个偏移的内存地址中的数据 LOAD_SYMBOL symbol symbol 为字符串，加载 symbol 符号所代表的地址 有了上述两条指令，可以将测试用例翻译如下： main: _T0 = LOAD_SYMBOL x _T1 = LOAD _T0, 0 return T1 需要说明的是，你也可以把两条指令合并为一条指令，直接加载全局变量的值，但分为两条指令的方式可扩展性更好些。 请注意，翻译所得的 TAC 代码中没有为全局变量赋予初始值（2024）。可以将变量的初始值存放在变量符号对应的符号表里，在后端代码生成时通过读取符号表得到初值。此处给出的只是一种参考实现，大家也可以将全局变量的定义显式翻译为 TAC 代码，这样可以使中端与后端完全解耦。 目标代码生成 Step10 中目标代码生成的主要任务有：翻译中间代码，将全局变量放到特定的数据段中。 翻译中间代码 实际上，我们提供的中间代码设计和 RISC-V 汇编的思想是一致的，RISC-V 汇编中有对应 LOAD 和 LOAD_SYMBOL 的指令，我们直接给出翻译结果： main： la t0, x # _T0 = LOAD_SYMBOL x lw t1, 0(t0) # _T1 = LOAD _T0, 0 mv a0, t1 ret 将全局变量放到特定的数据段中 到目前为止，翻译中间代码的方式是有问题的，问题在于，需要加载的 x 变量符号究竟存在哪里，如果所生成的汇编程序不给出 x 的定义，程序是有bug的。实际上，RISC-V 提供了一系列的汇编指令，用以声明全局变量 x 所对应的数据段。 下面给出 RISC-V 用以全局变量声明的汇编指令，其他全局变量的声明只需修改变量名称和初始值即可： .data .globl x x: .word 2024 上例中，.data 表示输出到 data 数据段；.globl x 声明 x 为全局符号；.word 后是一个 4 字节整数，是 x 符号对应的初始值。 按照汇编约定，data 段中存放已初始化的全局变量，未初始化的全局变量则存放在 bss 段中。举例而言，下面的示例将未初始化的全局变量 x 存放到 bss 段中。其中，.space 表示预留一块连续的内存，4 表示存储空间大小为 4 字节。 .bss .globl x x: .space 4 思考题 写出 la v0, a 这一 RiscV 伪指令可能会被转换成哪些 RiscV 指令的组合（说出两种可能即可）。 参考的 RiscV 指令链接：https://github.com/TheThirdOne/rars/wiki/Supported-Instructions "},"docs/step10/spec.html":{"url":"docs/step10/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step10 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' ( compound_statement | ; ) type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step10 语义规范 10.1 对于全局变量的初始化，我们仅对初始化表达式是整数字面量的情况做要求（例如 2123），对初始化表达式是非字面量的情况不做任何要求（例如 a 或 f() 或 2+3）。 C 其实也支持非字面量的编译期常量，例如 int a=1+3;。编译器可以计算出 1+3==4 然后让它等价于 int a=4;。 但为了实现简便，我们就不要求支持这点。 C 不允许 int a=f(); 因为 f() 不是编译器常量； 而 C++ 甚至可以支持 int a=f();，其大致实现为 int a=0; 然后在 main 之前执行的初始化函数中 a=f();。 10.2 我们对全局变量的重复声明不做任何要求或限定；但全局变量不能被重复定义，即不能有同名的被初始化的全局变量。 int a; int a=2; int a; int main(){ return a;} 是合法的 C 代码，不过不是合法的 C++ 代码，也许 C++ 的处理方式更符合你的直觉。 为了简单，我们不要求这点。比如对于形如 int a; int a=2; 或 int a; int a; 的代码片段，你可以以任意方式处理。 10.3 如果一个全局变量没有被初始化，我们认为其拥有一个默认初始值 0。 "},"docs/step11/intro.html":{"url":"docs/step11/intro.html","title":"实验要求","keywords":"","body":"实验指导 step11：数组 step11 的目标是支持数组： 语法上没有太大改动， 数组的初始化： declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' 数组的下标操作 postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' step11 难度不大，但有了数组让我们能够写很多有意思的程序了，step11 之前甚至 MiniDecaf 连快速排序都写不了。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 6 的实验报告需要放在 stage-6 这个 branch 下的 ./reports/stage-6.pdf。整个 stage 6 只需要提交一份报告，你不需要单独为 step 11 准备报告。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step11/example.html":{"url":"docs/step11/example.html","title":"通过例子学习","keywords":"","body":"step11 实验指导 本实验指导使用的例子为： int x[10]; int main() { int y[10]; return 0; } 词法语法分析 针对数组，我们需要设计 AST 节点来表示它，给出的参考定义如下： 节点 成员 含义 IndexExpr 索引基底 base，索引下标 index 索引运算 语义分析 由于 step 11 里引入了数组，现在我们的变量类型不只是 int 型了，还包括 int 型数组。因此，为了保证所有表达式中变量的类型均合法，需要进行类型检查。 注意：引入数组后，左值不再一定是 identifier 了，还有可能是如 a[0][1] 这样的索引运算表达式，因此同学们可能需要仔细考虑一下如何处理赋值时对值类别的检查。 frontend/type/array.py 里实现了数组类型，同学们可以使用它完成实验，也可以自行对其进行修改。 有能力的同学可以考虑将原先 Namer 中类型检查的部分，以及 stage 5 需要增加的类型检查重构进 Typer 中，使实现更加模块化。 中间代码生成 数组和普通变量类似，可以分为局部数组和全局数组。 全局数组的处理与全局变量类似，由于是升级关卡，我们留给同学自行思考（和全局变量究竟有什么不同，是不是需要的内存空间更大？提示：1. 需要申请更大的 bss 段内存）。 针对局部数组，给出一种参考实现，实际上不只存在一种实现方法。实验文档给出一种参考实现方法，定义了一条中间代码指令 ALLOC 用于分配内存空间： 请注意，TAC 指令的名称只要在你的实现中是一致的即可，并不一定要和文档一致。 指令 参数 含义 ALLOC size 分配 size 字节的内存，并返回内存首地址 采用 ALLOC 指令，测试样例中的局部数组部分代码可以翻译为如下中间代码（忽略全局数组部分）： main: T0 = ALLOC 40 # 一个 int 类型为 4 个字节 T1 = 0 return T1 通过这种方式，我们实际上是把内存分配的锅甩给了目标代码生成，这大大提升了目标代码生成的自由度，属于合理分锅。 除了分配数组，我们还需要考虑如何访问数组元素。通过 ALLOC 指令我们得到了数组的首地址，那么任何一个数组元素的地址可以通过在首地址的基础上加上偏移量得到。于是，读取数组元素可以使用 Step10 中引入的 LOAD 指令来实现，我们还需要引入一条类似的 STORE 指令将值写入数组元素。 那么，如何将数组下标对应到偏移地址？对一维数组，下标的常数倍（int 型的大小为 4 个字节，倍数为4）即为偏移量。而对于高维数组，我们可以将其视为一个展开成一维的大数组。对于数组 a[d1][d2]...[dn]，访问元素 a[i1][i2]...[in] 可以等价于访问 a[i1d2d3...dn + i2d3...*dn + ... + in]。在将数组索引翻译成 TAC 时，同学们需要自行将数组下标转换成地址计算指令。这个步骤并不困难，但可能比较繁琐，同学们在实现时要注意细节，避免错误。 目标代码生成 同中间代码生成，全局数组自行思考实现。 对于局部数组的内存分配，推荐在栈上为局部数组分配所需的空间，实际上，Step5 栈帧中的局部变量区域，可以用于存储局部数组。因此，大家需要模仿新建栈帧的操作，对栈顶指针 sp 进行修改，在栈上开辟出一块连续内存，并将这块内存的首地址返回即可。后续如有对数组中元素的访问，基于首地址进行偏移操作即可。 思考题 C 语言规范规定，允许局部变量是可变长度的数组（Variable Length Array，VLA），在我们的实验中为了简化，选择不支持它。请你简要回答，如果我们决定支持一维的可变长度的数组(即允许类似 int n = 5; int a[n]; 这种，但仍然不允许类似 int n = ...; int m = ...; int a[n][m]; 这种)，而且要求数组仍然保存在栈上（即不允许用堆上的动态内存申请，如malloc等来实现它），应该在现有的实现基础上做出那些改动？ 提示：不能再像现在这样，在进入函数时统一给局部变量分配内存，在离开函数时统一释放内存。 你可以认为可变长度的数组的长度不大于0是未定义行为，不需要处理。 "},"docs/step11/spec.html":{"url":"docs/step11/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step11 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' ( compound_statement | ; ) type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step11 语义规范 11.1 一个数组类型描述了一组被连续分配在一段内存空间中的对象，所有对象都具有相同的类型（我们称之为元素类型）。数组类型包含两部分：元素类型，和数组的长度（即元素数量）。数组类型的表达式仅能参与下标运算。 11.2 我们仅要求支持固定长度的数组，即在数组的声明中，其长度是一个正整数字面量。 所以，我们不要求支持变长数组 int a[n]; 或不定长数组 int a[];。 11.3 对于下标运算 a[b]，要求 a 是一个数组类型，b 是一个整数类型，a[b] 是 a 中的第 b 个元素（从 0 开始计数）。 11.4 下标运算越界是未定义行为。 即便是类似 int a[4][5]; a[1][7] 这种，同样也是未定义行为。 "},"docs/step12/intro.html":{"url":"docs/step12/intro.html","title":"实验要求","keywords":"","body":"实验指导 step12：为数组添加更多支持 step12 的目标是支持数组的初始化和传参： 语法上没有太大改动， 数组的初始化： declaration : type Identifier ('[' Integer ']')+ ('=' '{' (Integer (',' Integer)*)? '}')? ';' 数组的传参： function : type Identifier '(' parameter_list ')' (compound_statement | ';') parameter_list : (type Identifier ('[' ']')?(('['Integer']')*)? (',' type Identifier ('[' ']')?(('['Integer']')*)?)*)? 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 6 的实验报告需要放在 stage-6 这个 branch 下的 ./reports/stage-6.pdf。整个 stage 6 只需要提交一份报告，你不需要单独为 step 12 准备报告。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step12/example.html":{"url":"docs/step12/example.html","title":"通过例子学习","keywords":"","body":"step12 实验指导 本实验指导使用的例子为： int func(int param[]){ param[0] = 1; return 0; } int main() { int arr[4] = {1,2}; func(arr); return arr[0] + arr[1] + arr[2]; } 词法语法分析 我们需要增加一个数组的初始化列表，可以直接修改上一节数组的AST结点增加一个数组用于记录初始化元素。 函数的参数列表需要加上数组类型。 语义分析 由于 step 12 里额外引入了数组传参和数组初始化，所以你需要修改语义分析，以支持数组传参。传参出现了一种特殊情况，即：函数参数数组的第一维可以为空。 int fun(int a[][12]){ a[0][1] = 1; return 0; } 中间代码生成 在C语言中，对于全局数组，如果没有初始化，那么其值全为0，而对于局部数组来说，如果没有初始化，其值是未定义的。 而初始化后数组的元素值是确定的，如果初始化时指定的的元素个数比数组大小少，剩下的元素都回被初始化为 0。例如： int arr[3]={1,2}; // 等价于 int arr[3]={1,2,0}; 当数组长度较长时，如果对每个位置产生一条赋值语句可能会让生成的汇编代码非常冗长。因此你可能需要内置一个 memset 这样的函数来实现数组的清零。由于gcc的汇编器通常自带一个memset函数，我们这里采用fill_n命名。 // fill_n 函数原型，三个参数分别是目标内存地址，设置的内容，长度（以数组元素个数为单位） int fill_n(int *dst, int res, int cnt); 因此，上述初始化可以等价地转化为： int arr[3]; fill_n(arr, 0, 3); a[0] = 1; a[1] = 2; 目标代码生成 数组传参相对于初始化是简单的，回想函数一节的传参方式，自行实现。 思考题 作为函数参数的数组类型第一维可以为空。事实上，在 C/C++ 中即使标明了第一维的大小，类型检查依然会当作第一维是空的情况处理。如何理解这一设计？ 总结 恭喜你实现了 MiniDecaf 语言的所有特性。回过头看，我们从常量表达式开始，逐步为编译器增加变量、作用域等特性，又引入控制逻辑，最后实现全局变量和数组，编译器逐渐变得功能齐全。编译器每一个新的特性都带来了新的挑战，而你通过自己的智慧，逐步解决了这些挑战。顺利完成实验后，相信你对编译器也有了自己独特的理解。 "},"docs/step12/spec.html":{"url":"docs/step12/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step12 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' ( compound_statement | ; ) type : 'int' parameter_list : (type Identifier ('[' ']')?(('['Integer']')*)? (',' type Identifier ('[' ']')?(('['Integer']')*)?)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' | type Identifier ('[' Integer ']')+ ('=' '{' (Integer (',' Integer)*)? '}')? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step12 语义规范 12.1 多维数组按照类似一维数组的初始化方法，不要求实现内部嵌套括号 int a[2][2] = {1, 2, 3, 4}; 会将数组变为 a[0][0] = 1; a[0][1] = 2; a[1][0] = 3; a[1][1] = 4; 12.2 数组传参是支持不定长度的 int fun(int a[]) 是被支持的，由于传参不需要申请完整的数组的空间，不会产生需要计算数组空间的问题 "},"docs/step13/readme.html":{"url":"docs/step13/readme.html","title":"选做二说明","keywords":"","body":"选做实验二说明 选做实验二是给希望继续深入了解编译器知识的同学设计的实验部分，这部分内容具有较大难度，请同学们依据自己的时间安排情况决定是否选做。由于我们的实验框架并非为实现这个Step设计，改动部分可能较大，请确保你对框架有完整的了解再开始实验。这部分以报告评分，没有额外的测试样例。 "},"docs/step13/intro.html":{"url":"docs/step13/intro.html","title":"实验要求","keywords":"","body":"实验指导 step13：寄存器分配算法改进 step13 的目标是实现论文 TOPLAS'1996: Iterated Register Coalescing 提出的寄存器分配算法，并以此代替 step5 中提到的当前代码框架中的分配算法。 语法上没有改动。 我们只接受 pdf 格式的实验报告，你需要将报告放在仓库的 ./reports/.pdf，比如 stage 7 的实验报告需要放在 stage-7 这个 branch 下的 ./reports/stage-7.pdf。整个 stage 7 只需要提交一份报告。 你需要： 改进你的编译器，支持上面提到的寄存器分配算法。 除了替换位于 backend/reg/bruteregalloc.py 的分配算法外，你可能还需要修改其他文件以适配算法的需求。如果你忘了这部分内容，可以看看 step 6 的数据流分析一节。 你需要为代码添加合理的注释以便批阅。 你需要设计新测例（见本节实验指导），用以检测新分配算法的优化效果。 完成实验报告（具体要求请看实验指导书的首页）。实验报告中需要包括： 你的学号姓名 简要叙述，为了完成这个 stage 你做了哪些工作（即你的实验内容） 详细说明你的代码的运行逻辑 举例说明：对于某几个测例，你在本节实验之前的代码编译出什么？本节实验之后编译出什么？它是如何被优化的？ 对于本节实验的新测例，分别使用本节实验之前之后的代码进行编译，测量并统计运行时间。改进后的编译器编译出的代码的运行效率需要有显著提升，但效率提升的高低不会作为评分的考察点。 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 如有代码交给其他同学参考，也必须在报告中声明，告知给哪些同学拷贝过代码（包括可能通过间接渠道传播给其他同学）。 "},"docs/step13/example.html":{"url":"docs/step13/example.html","title":"实验指导","keywords":"","body":"step13 实验指导 本节实验要求实现论文 TOPLAS'1996: Iterated Register Coalescing 提出的寄存器分配算法。推荐大家完整读一遍论文，并通过论文作者的讲解课件，（如果前面的链接失效了，可以打开这个链接）辅助理解。论文文末的附录有完整的伪代码，你可以在它的基础上完成本次实验。 下面简要介绍一些你可能需要的预备知识。 回顾：启发式寄存器分配算法 在step 6 的数据流分析一节中，提到了活跃变量的概念。即对于一个临时变量来说，如果它在某个执行点处具有的值会在这个执行点以后被用到，那么它在这个执行点处是活跃的。 而在step5 中提到了一个简单的启发式寄存器分配算法。在给一个变量分配寄存器时，它的大致思路如下： 首先检查是否存在空闲的寄存器，有则直接分配给当前变量。 否则，检查是否存在寄存器，使得它关联的临时变量在当前位置已经不是活跃变量了，如是则把它关联到当前变量。 否则，说明所有寄存器所关联的变量都是活跃的。此时随机选择某个寄存器，把它关联的临时变量存到栈帧上（这叫做溢出（spill）到内存），然后把它关联到当前变量。 基于图染色的寄存器分配算法 我们可以换一种角度去思考寄存器分配问题：两个变量在什么情况下不能被分配到同一个寄存器？当且仅当两个变量同时活跃时，它们不能被分到同一个寄存器。可以把这样的一对变量定义为相干的(interference)，或者说相互冲突的。 重用一下 step 6 中活跃变量的例子： TAC 代码 活跃变量集合 相干寄存器 _T0 = 4 {_T0} _T1 = 3 {_T0, _T1} (_T0,_T1) _T2 = _T0 * _T1 {_T0} _T3 = _T0 * _T0 {_T0, _T3} (_T0,_T3) _T2 = _T3 * _T3 {_T0, _T2, _T3} (_T0,_T2),(_T0, _T3),(_T2, _T3) _T2 = _T0 * _T2 {_T2, _T3} (_T2,_T3) _T1 = _T2 * _T3 {_T1} return _T1 {} 这时我们再提出一个问题：最少可以用多少个寄存器完成上面代码的寄存器分配？ 容易发现，至少需要3个寄存器。因为 _T0,_T2,_T3 相互冲突，需要各一个寄存器，而 _T1 可以跟 _T2 或者 _T3 共用寄存器。 这个思路相比代码框架中的启发式寄存器分配算法有以下好处： 尽量减少使用的寄存器个数，在函数调用或返回时需要保存或恢复尽量少的 callee save/caller save 寄存器，减少变量溢出到内存的次数。这一部分对运行效率的影响很大，因为访存通常比访问寄存器慢很多。 方便全局优化寄存器分配，减少基本块之间的 move 指令。 事实上，我们可以用图染色问题去描述“相互冲突的变量”： 图染色问题：有 n 个结点，m 条边，你需要给每个结点指定一个颜色，使得任意两个有边直接相连的结点的颜色不同。 寄存器分配问题：有 n 个变量，m 组冲突的变量。你需要给每个变量指定一个寄存器，使得任意两个冲突的变量的寄存器不同。 上面这两个问题描述是一一对应的。如图所示（暂时先忽略图中的虚线边），如果把每个字母看成一个变量，每种颜色看成一个寄存器，那么图中的染色方案就对应了一个寄存器分配方案。 如何找到所有冲突的变量 这里只提一个最简单的思路：看上面我们分析时列出的表格，先列举出每一步的活跃变量集合，然后两两连边。 如何解决寄存器分配对应的图染色问题 假定我们有 k 种颜色可用于染色（对应 k 个寄存器可用于存放变量），那么可以依照下面的顺序执行 寻找图中是否有连接了少于 k 条边的结点，如果有，把它记录下来然后从图中删除。重复这个步骤直到不存在少于 k 条边的结点。 如果图中已经没有结点，则进入步骤3；否则，此时图中所有点都连接了至少 k 条边。这时，选择一个点（可以随机选，但可以通过其他信息来优化你的选择），把它记录下来然后从图中删除。然后重复步骤1。 按删除的逆序恢复所有结点。 当恢复一个从步骤1删除的结点时，因为当前它连接了少于 k 条边，所以我们总能为它指定一个颜色，使之不和相邻的最多 k-1 个点的颜色冲突。 当恢复一个从步骤2删除的结点时，检查它连接的所有边。如果我们足够幸运，与它相邻的所有点没有用完所有 k 种颜色，那么我们可以为这个点指定一个不冲突的颜色。否则，为它选择一个颜色，这意味着它和另一个变量被分配到同一个寄存器里。别担心，这不会导致算法失败，只是会使得这个变量在使用时需要从栈帧保存与恢复，对应启发式寄存器分配算法中溢出（spill）到内存的情况。 将每种颜色对应到寄存器上，生成后端代码。 基于复制指令的寄存器合并 在图染色的基础上有一种合并寄存器的进阶方法：合并通过复制指令(copy instructions)（其实就是赋值）传值的寄存器。 例如下面的代码 int f() { int a = 1; int b = a; int c = a + 2; int d = b + 3; return a + b + c + d; } 用上面提过的活跃变量分析可以算出，在 c = a + 2 执行时 a 和 b 都是活跃变量。但观察代码可以发现 a b 事实上存的是同样的值，只需要用同一个寄存器存就行。这篇论文使用了这个优化，并改进了前人的类似优化方案。 这样我们可以在图染色问题中把仅因复制（其实就是赋值）指令相互冲突的一对点之间的连边标记成虚线，表示如果它们最终染同一种颜色，就可以删去这条边然后合并这两个点。这有助于把上述图染色算法中从步骤2删去的点挪到步骤1删去，避免溢出到内存的情况。 可以直接合并这两个点吗？ 可以，但可能会导致产生出连接许多边的结点，反而使得后续染色困难，不得不溢出到内存。这实际上是更早的 Chaitin 的解决方案。 可以在保证合并后边数 的情况下合并这两个点吗？ 可以，但这样合并的点数比较少，优化效果差。这实际上是更早的 Briggs 的解决方案。 可以不合并但强制这两个点同色吗？ 不可以。如下图所示，j，b因复制指令冲突，j,f因其他指令冲突，但b,f之间没有冲突，所以涂色算法中有可能会把 b,f涂成相同颜色。这样就会导致 j 的颜色和 b 相同，从而意外地和 f 相同，导致溢出到内存。 这篇实验要求实现的论文的解决方案 把图中当前所有结点中，连接了至少 k 条边的结点标记为 significant-degree 的。看上述图染色算法流程，可以发现如果一个点不是 significant-degree 的，它会在步骤1被删除。 对于仅因复制指令相互冲突的一对点 (a,b)，可以如此检查它们是否可以合并： 统计与 a 或者 b有边相连的所有结点中有多少个 significant-degree 点。如果有 个，说明最多有 k-1 个结点不会在在步骤1被删除，因此如果 a b 合并，这个合并后的点也会在步骤1被删除。在步骤1被删除就意味着合并后的 a 和 b 一定能找到一种不和周围任何一个点冲突的颜色，从而不会出现上图的情况。 如果不能合并，那么把 a 和 b 中间的虚线边改为实线，表示不再考虑二者合并的情况。 上面的说明只是简要介绍了算法的原理，请阅读论文 TOPLAS'1996: Iterated Register Coalescing 获取更详细的说明。别忘了论文末尾的附录有完整的伪代码实现。 "},"docs/contest/intro.html":{"url":"docs/contest/intro.html","title":"大实验简介","keywords":"","body":"大实验参考文档 注：大实验文档目前还在完善中，会不断迭代更新。如果对于评分部分有更新，会通知所有选择大实验的同学。 介绍 大实验编译器目标：完成一个具有编译优化功能的高性能编译器。部分达到系统能力设计大赛——编译系统设计赛的要求。 参加大实验的同学应该需要自己从头设计一个符合 minidecaf 规范 的编译器，包括前端、中端和后端。参加大实验可以替代期末考试，详见评分方法一节。 有两个原因我们要求同学们从头设计一个编译器： 为了简化课程实验，我们的基础实验框架在设计时并未考虑大实验的需求（例如：IR 的类型系统简易、没有区分基本块），在现有框架的基础上重构实现编译优化反而在一定程度上限制了编译器的优化能力。 大实验设计的其中一个目标是鼓励同学们参加系统能力设计大赛，比赛有查重要求，如果同学们使用相同的框架开始参加大实验并参与后续比赛，可能存在代码被判定为重复的问题。 大实验在 2024 年相对于 2023 年有一些变化，主要体现在： 增加了实验文档 语法要求从 Sysy 语法改为了 MiniDecaf，主要差别在于const标志符号、数组初始化等语法上的区别，难度有所降低 不再要求完成基础实验以后再进行大实验 大实验的语法规范与 step12 的规范是一致的。不过有一点需要注意： 我们要求实现函数声明，即一个函数可以只有声明没有定义，主要是用于评测性能，比如读入数据和打印结果，我们将会把你的代码和一个外部库进行链接编译。这意味着，你需要实现标准的 RiscV 调用约定。 你可以选择 C++，Rust 实现你的编译器，你的编译器生成的目标代码可以是 RISC-V 或者 ARM 架构的，这与比赛要求一致。如果你想用其他语言实现，请告知助教。 大实验为组队实验，4人一组（可以更少，但是评分标准保持不变）。没有特殊情况时，同组同分。 注意：大实验工作量较大，并不推荐所有同学都参加。 编译器的构成 一个编译器主要由以下几个部分构成： 前端：负责词法分析、语法分析、语义分析，生成抽象语法树（AST）。 词法分析器（Lexer）：将输入的源代码转换为一个个的标记（Token）。 语法分析器（Parser）：将标记（Token）转换为抽象语法树（AST）。 语义分析器（Semantic Analyzer）：检查AST是否符合语法规则和语义规则。 中端：负责中间代码生成、优化。 中间代码生成器（Intermediate Representation Generator）：将 AST 转换为中间代码。 优化器（Optimizer）：对中间代码进行优化。 后端：负责目标代码生成。 目标代码生成器（Target Code Generator）：将优化后的中间代码转换为目标机器代码。 寄存器分配：将中间代码中的变量分配到实际的物理寄存器中。 可以通过后续的文档了解每个部分的更多细节。 参考实现进度及顺序 编写前端、设计 IR、完成中间代码生成 (两周) 前端：你可以使用现有的框架完成前端（如：Antlr、Flex & Bison）辅助你生成 AST，完成词法分析、语法分析、语义分析以及中间代码生成。如果你想在这个过程中锻炼你对分析方法的理解，你可以自己实现 LR(1)、LL(1) 等分析器。 设计 IR 也是需要进行代码编写的，可以参考基础实验框架的IR在代码层面是如何实现的（utils/tac）。 中间代码生成：将 AST 转换为 IR，你可以参考基础实验框架的中间代码生成部分（frontend/tacgen）。 此阶段分工建议：两位同学负责前端，两位同学负责中间表示设计和中间代码生成。 完成后端（两周） 实现后端代码生成、栈帧管理 实现一个简单的寄存器分配方案，保证编译器能够完成全流程的运行，然后再考虑优化。 增加中端优化和后端优化（剩下的时间） 中端优化：死代码消除、常量传播、复写传播、循环不变量外提等等 后端优化：图染色寄存器分配、线性扫描法、指令折叠等等 分工建议：两位同学负责中端优化，两位同学负责后端优化。 进度检查 第一次进度检查：第六周周六（10.19） 你的编译器应该能完成将简单的程序转换为 RISC-V 汇编代码，可以选择在这次检查时退出大实验。如果退出大实验，你需要在第八周周日（11.3）Stage 3 截止之前完成 Stage 1-3 的实验，不会有额外扣分。 第二次进度检查（中期检查）：第八周周六（11.2） 这时候你的编译器应该能通过基础实验的所有测试样例（Stage 1-5）。如果不能完成，可能会被取消大实验的资格，同时你需要重新完成基础实验你需要在第十周周日（11.17）Stage 4 截止前完成 Stage 1-4 ，不额外扣分。也可以继续大实验不做基础实验，但是至少要在 Stage-5 让你的编译器能够通过 Stage 1-5 的测试样例。 你们需要提交一个简单的报告，说明每个同学在实验过程中的分工以及完成的功能。（如果缺少这部分实验报告，那么报告成绩将会被扣除5分（总评 5%）） 第三次进度检查：第十二周周六（11.23） 你们需要提交一个简单的报告，说明每个同学在上次检查后的分工以及完成的功能。（如果缺少这部分实验报告，那么报告成绩将会被扣除 5 分（总评 5%）） 第四次进度检查（期末检查）：第十六周周末（12.29） 你的编译器应该能通过所有的测试样例（Stage 1-6），包括附加测试样例。 你应该提交一个完整的实验报告，包括实验的设计、实现、优化以及遇到的问题和解决方法。不需要卷页数，但应该说明了你们实现的功能。（如果缺少这部分实验报告，你将不会得到任何报告成绩） 评分方法 因为大实验实现难度较高且工作量较大，优化目标可能相对难以完成，因此我们给出两种评分方案： 选项一 完成竞赛第二阶段的优化编译器，替代期末考试 成绩占比 90%，剩余 10% 为书面作业和日常成绩。 其中这90%构成为： 50% 正确性测试：你需要通过 Stage 1-6 的所有测试样例以及附加测试的测试样例，这样你可以获得 50% 的正确性得分。 10% 报告，介绍你的编译器的设计、你们进行的优化以及每个人完成的功能。 30% 性能测试，将根据你的编译器的性能进行评分。 性能评分方案： 附加测试中performance部分测试样例，以 gcc 打开-O2优化的性能的 60% 为满分，按照比例折算。如果一个程序 gcc 编译后运行时间为 12s ，如果你的程序执行时间为 20s 即为满分。 你的单个测试点的得分为： min{100, 100 * GCC编译程序运行时间 * 1.67 / 你的程序运行时间} 所有测试点取算数平均值，最后结果 * 30% 作为你的最终性能测试成绩。 评测将会在我们提供的服务器上进行，通过 QEMU 模拟 RISC-V 或者 ARM 架构的 CPU 运行你的程序。经过测试 QEMU与 真实硬件的性能相对差值是比较恒定的（如比较 gcc -O1与-O2）。 实验评测仓库在这里。 你也可以选择参加期末考，那么你的成绩将会是评分方案一、二取最高的一个。 选项二 仅完成竞赛第一阶段（达到课程基础实验的要求） 实验部分占比与基础实验一致，你不需要完成思考题，但是需要简单介绍你的编译器是怎么完成每一个 step 的。根据通过测试样例情况评分。 完成 Stage 1 - 5 实验成绩 35% ，书面作业和日常成绩 10% ，期末成绩 55%。 完成 Stage 1 - 6 实验成绩 42% ，书面作业和日常成绩 10% ，期末成绩 48%。 完成 Stage 1 - 7 实验成绩 50% ，书面作业和日常成绩 10% ，期末成绩 40%。 "},"docs/contest/frontend.html":{"url":"docs/contest/frontend.html","title":"前端设计","keywords":"","body":"前端梗概 前端的主要任务是将源代码转换为抽象语法树（Abstract Syntax Tree, AST），为中端和后端生成中间表示和目标代码提供基础。在这个过程中，前端会经历词法分析、语法分析、语义分析等多个步骤。 词法分析与语法分析 词法分析的任务是将源代码转换为一系列的符号（token），每个符号代表源代码中的一个最小单位，如关键词、标识符、操作符等。词法分析器会忽略空格、注释等非必要信息，并在此过程中进行基本的错误检测（如非法字符）。 下面我们以 Antlr 框架为例，介绍如何进行词法分析和语法分析。你也可以使用其他工具如 Flex & Bison, lex & yacc 等。 Antlr简介 Antlr (Another Tool for Language Recognition) 是一个功能强大的解析器生成器，能够根据给定的语法规则自动生成词法分析器和语法分析器。Antlr 支持多种语言，包括 Java、Python 和 C++。通过定义语法文件（.g4 文件），Antlr 能够帮助我们生成解析源代码所需的词法分析和语法分析工具。 在这个项目中，我们推荐使用 Antlr 来处理 MiniDecaf 的词法分析和语法分析部分。 第一部分:依赖环境准备 ANTLR 工具需要 JVM 才能执行。 直接使用包管理器安装： sudo apt install openjdk-19-jdk 1. 获取 ANTLR 你需要从 ANTLR Download 下载 antlr-4.13.2-complete.jar(截至文档写作时此为最新版)。 使用以下命令（记得把/path/to/antlr-4.13.2-complete.jar替换成你的 antlr 路径）测试是否能正常使用： java -jar /path/to/antlr-4.13.2-complete.jar 你应该能看到类似以下的输出： ANTLR Parser Generator Version 4.13.2 -o ___ specify output directory where all output is generated -lib ___ specify location of grammars, tokens files -atn generate rule augmented transition network diagrams -encoding ___ specify grammar file encoding; e.g., euc-jp ... ... 3. ANTLR 运行时的编译链接 1. 安装 ANTLR 运行时库 ANTLR 运行时库是解析器生成的代码在运行时所依赖的代码。对于 C++，你可以从 ANTLR4 runtime Cpp的 GitHub 仓库下载预编译的库或者自己编译安装。但是官方的 CMAKE 脚本会从官方 git 仓库下载 ANTLR C++ 运行时并构建它，你在编译过程中很可能会因为网络等问题而失败，如果难以解决，可以直接 clone ANTLR 运行时库的 C++ 源代码到你的代码仓库里，并为你的整个项目编写一个 CMAKE 文件(强烈建议)。出于方便考虑，我在这里给出一个可能的项目结构与CMAKE文件实例. 项目结构 example-tree/ ├── 3rd_party/ │ └── antlr4-runtime/ # 第三方库 ANTLR 运行时目录(在源码的 src 目录下) │ ├── CMakeLists.txt # antlr4-runtime 的 CMake 配置文件,需要你手动添加一个 │ └── antlr4-runtime.h │ └── antlr4-common.h │ └── ... ├── CMakeLists.txt # 根目录下的 CMake 配置文件 └── src/ # 源代码目录 ├── frontend/ # 前端代码目录 │ ├── lexer/ # 词法分析相关代码 │ │ └── *.cpp # 词法分析器源文件 │ │ └── *.h # 词法分析器头文件 │ ├── parser/ # 语法分析相关代码 │ │ └── *.cpp # 语法分析器源文件 │ │ └── *.h # 语法分析器头文件 │ └── ast/ # 抽象语法树相关代码 │ ├── *.cpp # AST 源文件 │ ├── *.h # AST 头文件 ├── backend/ # 后端代码目录 ├── midend/ # 中间代码目录 └── main.cpp # 程序入口文件 对应的 CMakeLists.txt # 指定 CMake 的最小版本要求 cmake_minimum_required(VERSION 3.10) # 设置项目名称和使用的语言（CXX 代表 C++） project(my_compiler CXX) # 设置 C++ 标准为 C++17 set(CMAKE_CXX_STANDARD 17) # 设置 C++ 编译器标志，这里没有额外添加，使用默认 set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS}\") # 设置调试模式下的编译器标志，开启 DEBUG 宏 set(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG} -DDEBUG\") # 使用 GLOB_RECURSE 模式递归查找 src 目录下所有的 .cpp 文件 file(GLOB_RECURSE SRC \"src/*.cpp\") # 添加项目的 src 目录到头文件搜索路径 include_directories(src) # 添加第三方库目录 antlr4-runtime 到头文件搜索路径 include_directories(3rd_party/antlr4-runtime) # 添加 antlr4-runtime 子目录作为子项目进行构建 add_subdirectory(3rd_party/antlr4-runtime) # 创建名为 my_compiler 的可执行文件，将所有源文件编译链接到这个可执行文件中 add_executable(my_compiler ${SRC}) # 将 antlr4_runtime 库与 my_compiler 可执行文件链接 target_link_libraries(my_compiler antlr4_runtime) 为 antlr4-runtime 添加一个相应的 CMakeLists.txt # 3rd_party/antlr4-runtime/CMakeLists.txt file(GLOB_RECURSE ANTLR4_SRC \"*.cpp\") add_library(antlr4_runtime STATIC ${ANTLR4_SRC}) 第二部分：文法文件的编写与 parse tree 的生成 终于，在上一部分中，我们完成了项目的环境准备工作，可以着手开始编写代码了。在这一节中，我们会开始编写一个简单的 C 语言子集 simpleC 的文法文件 simpleC.g4，并利用它生成一个 parse tree。最终把一个简单的 C 语言程序 test.c 转换为一个 parse tree。 test.c int main(){ int a = 1 ; int b = a + 2 ; int c = a + b + 1 ; return c ; } parse tree parse tree: (program (funcDeclaration int main ( ) { (statements (statement int a = (expression 1) ;) (statement int b = (expression (expression a) + (expression 2)) ;) (statement int c = (expression (expression (expression a) + (expression b)) + (expression 1)) ;) (statement return (expression c) ;)) })) 1. 编写simpleC.g4 .g4 文件是 ANTLR 使用的文法文件，用于定义语言的语法规则。它使用基于上下文的语法规则来描述语言的结构。一个典型的 .g4 文件包含以下几个部分： 语法定义：声明语法的名称，这是识别语法文件的关键字。这个语法名称必须要和包含这个语法的文件名完全相同(甚至包括大小写,因为 ANTLR 是对大小写敏感的) 规则：定义语言中各种结构的模式。 词法规则：定义词法单元（如关键字、标识符、符号等）。 忽略规则：通常用来忽略空格、换行等空白字符。 操作：在规则中嵌入的代码，用于在解析过程中执行特定的动作。 示例 .g4 文件结构 // 文件名: SimpleC.g4 grammar SimpleC; // 语法定义 // 程序的起始规则 program: funcDeclaration ; // 函数声明规则 funcDeclaration: Type ID LP RP LC statements RC ; // 语句的规则 statements: statement* ; // 声明和表达式 statement: Type ID ASSIGN expression SEMI // varDeclaration | expression SEMI | 'return' expression SEMI ; // 表达式的规则 expression: expression PLUS expression // AddExpr | expression MINUS expression // SubExpr | expression MUL expression // MulExpr | expression DIV expression // DivExpr | '(' expression ')' // ParenExpr | INT // IntExpr | ID // ID ; // 类型的规则（这里只支持 int 类型） Type: 'int' ; // 整数的规则 INT: [0-9]+ ; // 标识符的规则 ID: [a-zA-Z_] [a-zA-Z0-9_]* ; // 忽略空格和换行 WS: [ \\t\\r\\n]+ -> skip ; // 定义括号和符号 LP: '(' ; RP: ')' ; LC: '{' ; RC: '}' ; SEMI: ';' ; ASSIGN: '=' ; PLUS: '+' ; MINUS: '-' ; MUL: '*' ; DIV: '/' ; 通过编写 .g4 文件，我们能够为 ANTLR 提供足够的信息来构建一个能够理解和处理特定语言的解析器。这种形式的文法定义是编译器设计和语言工具开发的基础。 2. 使用文法文件生成 lexer & parser 在确认环境配置无误后，我们可以使用 ANTLR 和文法文件生成所需的 lexer & parser，只需要执行 java -jar /path/to/antlr-4.13.2-complete.jar -Dlanguage=Cpp -no-listener -visitor -o src/frontend/lexer_parser simpleC.g4 -no-listener 和 -visitor 选项分别用于禁止生成 listener（默认是激活的）和激活 visitor 模式。如果你还不知道 visitor 是什么，不用担心，我们稍后会看到。 -o 选项用于设置输出目录。我们将在 src/frontend/lexer_parser 目录中输出生成的代码。 3. 使用 lexer & parser 现在我们可以看到如何在 C++ 程序中使用我们生成的解析器。 // src/main.cpp #include \"antlr4-runtime.h\" #include \"frontend/lexer/SimpleCBaseVisitor.h\" #include \"frontend/lexer/SimpleCLexer.h\" #include \"frontend/lexer/SimpleCParser.h\" #include #include using namespace antlr4; using namespace tree; using namespace std; int main(int argc, const char* argv[]) { ifstream f_stream; f_stream.open(argv[1]); ANTLRInputStream input(f_stream); SimpleCLexer lexer(&input); CommonTokenStream tokens(&lexer); SimpleCParser parser(&tokens); ParseTree* tree = parser.program(); cout toStringTree(&parser, true) 这是我们程序的主文件，展示了如何在 C++ 中设置使用 ANTLR。前几行（3-5）包含的头文件基本上是你总是会包含的标准头文件。第一个是使用运行时所需的，其他两个是为生成的词法分析器和解析器准备的。显然，它们的名字会根据语法的名字而改变，但概念保持不变。 16-21 行展示了使用 ANTLR 解析器的标准方式： 我们将输入转换为 ANTLR 格式 我们创建一个在该输入上工作的词法分析器 我们使用词法分析器产生一个 token 流 我们创建一个在令牌流上工作的解析器 然后，21 行使用解析器的一个方法，该方法对应于语法规则中的一个，以获得规则匹配的第一个节点。在我们的例子中，只有一个节点program，这是因为我们定义规则的方式。然而，原则上那可以是任意的，每次你调用相应的方法，你都会得到一个相应的结果。 现在，使用 cmake 构建并运行我们自己实现的编译器，你将会看到 test.c 对应的 parse tree 被输出到终端中。 ./my_compiler test.c 总的来说，我们现在利用 ANTLR 实现了词法分析器分析输入（即字符）并产生 token，然后解析器分析 token 以产生 parser tree。这样，我们就把一个看似被复杂地组织起来的文本转化成了一个“树”，之后我们就可以使用 visitor 模式遍历这个树并对这个树的每个节点进行一些操作。 第三部分：AST 的生成 在生成 AST 时，我们通常是在解析树（parse tree）的基础上，通过提取语法的核心结构，生成更加精简的抽象语法树（AST）。AST 的节点通常只包含与程序执行相关的核心信息，去除了冗余的语法信息。 1. 定义 AST 结点 首先，我们需要为 AST 定义结点类型。每个结点对应于一种语法结构，比如条件语句、循环、表达式等。以下是一个简单的 If 语句结点的定义： class IfNode : public ASTNode { public: std::unique_ptr cond; // 条件表达式 std::unique_ptr then; // then 语句块 std::unique_ptr other; // optional 的 else 语句块 bool has_otherwise; IfNode(std::unique_ptr cond, std::unique_ptr then, std::unique_ptr other = nullptr) : cond(std::move(cond)), then(std::move(then)), other(std::move(other)), has_otherwise(other != nullptr) {} }; 这个 IfNode 结点包含条件表达式cond、then 语句块和可选的 else 语句块。 2. 使用 Visitor 模式生成 AST 在生成 AST 时，我们需要遍历解析树（parse tree）并根据其结构生成对应的 AST 结点。这里我们可以使用 Visitor 模式，针对解析树的不同节点调用对应的处理函数，来生成合适的 AST 结点。 假设我们有一个解析树 IfContext，对应的语法规则如下： ifStatement : 'if' '(' expr ')' statement ('else' statement)? ; 我们可以继承 ANTLR 自动生成的 BaseVisitor 函数，为 IfContext 实现 Visitor 函数，以生成 IfNode： class ASTBuilderVisitor : public SimpleCBaseVisitor> { public: // 访问 ifStatement 节点 std::unique_ptr visitIfStatement(SimpleCParser::IfStatementContext *ctx) override { // 访问并生成条件表达式的 AST 结点 auto cond = visit(ctx->expr()); // 访问并生成 then 语句的 AST 结点 auto thenBranch = visit(ctx->statement(0)); // 检查是否有 else 分支，并生成对应的 AST 结点 std::unique_ptr elseBranch = nullptr; if (ctx->statement(1)) { elseBranch = visit(ctx->statement(1)); } // 构建 IfNode，并返回 return std::make_unique(std::move(cond), std::move(thenBranch), std::move(elseBranch)); } }; 这个 ASTBuilderVisitor 类的 visitIfStatement 方法遍历解析树中的 ifStatement 结点，生成 IfNode 并填充其条件表达式、then 和 else 分支。通过 Visitor 模式，代码变得结构清晰且便于扩展。 生成 AST 的完整流程 编写 Antlr 语法文件，定义源语言的解析规则。 使用 Antlr 生成词法分析器和语法分析器，解析源代码生成解析树。 实现 Visitor 模式的遍历代码，逐个解析树结点处理并生成 AST 结点。 利用 AST 结点构建抽象语法树，最终生成中间表示或目标代码。 通过这种方式，我们能够将解析树转换为精简的抽象语法树（AST），为后续的中端和后端处理提供基础。 第四部分：语义分析 语义分析的目标是检查程序的合法性，确保程序符合语言的语义规则。在大作业中，这一部分的实际作用主要是检测出 MiniDecaf 的错误测例并报告编译错误。这一步包括符号解析（名称绑定）和类型检查，以保证变量、函数等符号被正确地定义、引用和使用，并且操作符和操作数之间的类型匹配。 符号解析（namer） 符号解析的任务是将程序中使用的标识符（如变量名、函数名等）与它们的定义绑定起来。具体来说，符号解析会遍历抽象语法树（AST），并记录每个作用域中的符号定义。当在同一作用域或嵌套作用域中遇到符号引用时，解析器能够正确地找到该符号的定义或者报错。 符号表 符号解析的核心工具是符号表（symbol table）。符号表是一个数据结构，用来存储标识符的名字及其相关信息（如类型、作用域、存储位置等）。通常符号表会随着作用域的嵌套而形成层级结构，以便在不同作用域之间正确解析符号。 class SymbolTable { public: std::unordered_map> table; std::shared_ptr parent; // 指向父作用域的符号表 SymbolTable(std::shared_ptr parent = nullptr) : parent(parent) {} // 在当前作用域查找符号 std::shared_ptr lookup(const std::string &name){ //··· } // 向符号表中插入新的符号 void insert(const std::string &name, std::shared_ptr symbol) { //··· } }; 在符号解析过程中，我们会为每个作用域生成一个符号表，并随着进入和退出作用域对符号表进行管理。例如，在遇到函数定义时会创建一个新的局部符号表，当函数调用或变量引用时，会查找符号表以确保该符号已定义且在正确的作用域中。 作用域管理 符号解析还需要管理作用域。通常在遇到新的作用域时（如函数、代码块、循环等），创建一个新的符号表，并在退出该作用域时销毁它。在解析过程中，确保每个符号在其可见的作用域内被正确解析。 class SemanticAnalyzer { public: std::shared_ptr currentScope; void enterScope() { currentScope = std::make_shared(currentScope); } void exitScope() { currentScope = currentScope->parent; } void declareVariable(const std::string &name, const std::shared_ptr &symbol) { currentScope->insert(name, symbol); } std::shared_ptr resolveVariable(const std::string &name) { return currentScope->lookup(name); } }; 通过 enterScope() 和 exitScope() 来管理作用域嵌套，当处理一个新的作用域（如函数或代码块）时，会创建新的符号表并进行相应的符号解析。 类型检查（typer） 类型检查的任务是确保程序中的所有操作符和操作数的类型兼容。例如，在算术表达式中，类型检查会确保运算符作用于正确的类型，并且操作数之间的类型一致。类型检查可以有效避免不合法的操作，如对整数进行除以字符串的运算。 类型系统 编译器通常需要支持一套类型系统。类型系统包含基本类型（如整型、浮点型、布尔型等）和复杂类型（如指针、数组、结构体等）。类型检查器会根据这些类型系统对程序中的每个表达式、赋值和函数调用进行检查。 以下是一个简单的类型检查器示例： class TypeCheckerVisitor : public ASTVisitor { public: std::shared_ptr visitBinaryExpr(BinaryExprNode *node) override { auto leftType = visit(node->left); // 检查左操作数的类型 auto rightType = visit(node->right); // 检查右操作数的类型 // 检查操作数的类型是否匹配 if (!leftType->equals(rightType)) { throw std::runtime_error(\"Type mismatch in binary expression.\"); } // 返回表达式的类型 return leftType; } std::shared_ptr visitVariableDecl(VariableDeclNode *node) override { // 检查变量声明的类型是否正确 auto varType = node->type; if (!isValidType(varType)) { throw std::runtime_error(\"Invalid type for variable.\"); } return varType; } // 其他类型检查逻辑... }; 在该类型检查器中，我们遍历 AST 中的每个节点，检查其类型是否正确。例如，在二元表达式中，我们会检查左右操作数的类型是否匹配，并且确保运算符可以作用于该类型。此外，对于变量声明和函数调用等其他结构，也需要检查它们的类型。 类型转换 由于 MiniDecaf 只支持有限的数据类型，所以类型转换的部分可能并不需要实际实现。 类型检查的过程中，编译器有时需要进行类型转换。例如，将一个整数与浮点数进行加法运算时，编译器可能需要将整数提升为浮点数。编译器可以通过隐式类型转换来完成这类操作，但必须遵循一定的类型转换规则。 class TypeCheckerVisitor : public ASTVisitor { public: std::shared_ptr visitBinaryExpr(BinaryExprNode *node) override { auto leftType = visit(node->left); auto rightType = visit(node->right); // 进行隐式类型转换 if (leftType->isInteger() && rightType->isFloat()) { leftType = floatType(); // 将整数提升为浮点数 } else if (leftType->isFloat() && rightType->isInteger()) { rightType = floatType(); } if (!leftType->equals(rightType)) { throw std::runtime_error(\"Type mismatch in binary expression.\"); } return leftType; } }; 通过检查和处理类型转换，我们确保程序的类型一致性，避免在运行时出现不可预知的错误。 预期目标 完成符号解析和类型检查后，编译器应该能够： 通过符号表解析所有的变量和函数定义，确保它们在正确的作用域中被引用； 检查所有的操作数和运算符的类型是否匹配； 报告语义错误，如未定义的符号、类型不匹配等。 通过这些步骤，语义分析能够确保源代码符合语言的语义规则，为后续的中端优化和代码生成打下坚实的基础。 前端参考资料 Antlr 官方文档 MiniDecaf 教程 编译原理经典书籍 Dragon Book 前端预期目标 完成这部分内容后，你的编译器应该能够通过 Antlr 生成词法分析器和语法分析器，能够将 MiniDecaf 程序解析为抽象语法树（AST），并完成对 MiniDecaf 程序的语义分析。 "},"docs/contest/midend/midend.html":{"url":"docs/contest/midend/midend.html","title":"中端设计","keywords":"","body":"中端介绍 中端的设计包括：中间表示的设计、中端代码生成和中端优化。 中间表示 前端的解析和中端设计密不可分，通常，我们需要设计一个中间表示（Intermediate Representation, IR）来连接前端和后端。也只有我们定义好了中间表示，才能将来自于前端的AST转换为中端代码。 什么是中间表示？ 中间表示（也称中间代码，intermediate representation / IR）是介于语法树和汇编代码之间的一种程序表示。 它不像语法树一样保留了那么多源程序的结构，也不至于像汇编一样底层。 由于源语言（MiniDecaf）和目标语言（RISC-V 汇编）一般存在较大的差别，因此直接把源语言翻译为目标语言中的合法程序通常是比较困难的。大多数编译器实现中所采取的做法，是首先把源语言的程序翻译成一种相对接近目标语言的中间表示形式，然后再从这种中间表示翻译成目标代码。中间表示（IR）的所带来的优势如下： 缩小调试范围，通过把 AST 到汇编的步骤一分为二。如果目标代码有误，通过检查 IR 是否正确就可以知道：是AST 到 IR 翻译有误，还是 IR 到汇编翻译有误。 将 AST 转换到汇编的过程分成两个步骤，每个步骤代码更精简，更易于调试。 适配不同指令集（RISC-V, x86, MIPS, ARM...）和源语言（MiniDecaf, C, Java...）。由于不同源语言的 AST 不同，直接从 AST 生成汇编的话，为了支持 N 个源语言和 M 个目标指令集，需要写 N * M 个目标代码生成模块。如果有了 IR，只需要写 N 个 IR 生成器和 M 个汇编生成器，只有 N + M 个模块。 便于优化，中间表示可以附带一些额外信息，比如类型信息、控制流信息等，这些信息辅助编译器进行优化。 例如以下是一个IR代码的例子： _main: _T1 = 0 _T2 = 100 _T3 = 0 _L0: _T4 = _T1 从这个IR例子中，我们可以看到，相对于c语言，IR中没有了while、for这样的循环语句，而是通过标签和jump、branch指令来实现循环。高级语言的许多特性在IR中都被抹去了，让代码更加简洁，便于优化。而相对于汇编代码，IR中无需关注寄存器、函数调用的上下文切换等信息，与具体的硬件架构解耦。 我们将在中间表示设计中介绍IR设计时候需要考虑的地方和并列举一些实例。 中间代码生成 前端解析后，我们会得到一棵抽象语法树，接下来我们需要将这棵抽象语法树转换为中间代码。依据你设计的IR，你需要在保证语义的情况下，将AST用你的IR表示出来。可以参考基础实验框架中frontend/tacgen/的代码。 如以下是一个简单的例子： int main(){ int a = 2; int b = 0; if(a) b = 1; else b = -1; return b; } 生成的AST可能如下： Program |- (children[0]) Function |- (ret_t) TInt |- (ident) Identifier(\"main\") |- (body) Block |- (children[0]) VarDecl |- (type) TInt |- (ident) Identifier(\"a\") |- (init) IntLiteral(2) |- (children[1]) VarDecl |- (type) TInt |- (ident) Identifier(\"b\") |- (init) IntLiteral(0) |- (children[2]) If |- (cond) Identifier(\"a\") |- (children[0]) Assign |- (lhs) Identifier(\"b\") |- (rhs) IntLiteral(1) |- (children[1]) Assign |- (lhs) Identifier(\"b\") |- (rhs) UnaryOp(NEG) |- (expr) IntLiteral(1) |- (children[3]) Return |- (expr) Identifier(\"b\") 你需要通过遍历AST的节点来将其转换为IR。例如，当你遇到一个if节点时，你可以先生成三个标签，一个用于表示if语句的开始，一个用于表示else语句的开始，一个用于表示整个if语句的结束。先生成一个判断语句，在生成if条件满足对应的标签以及代码，最后生成一个跳转语句，跳过else块。然后再生成else块的标签和代码。 例如上述代码转化为IR后可能如下： _main: _T0 = 2 # 代表a = 2 _T1 = 0 # 代表b = 0 bnez _T0, _L0, _L1 # 如果a != 0，跳转到_L0，否则跳转到_L1 _L0: _T2 = 1 # 代表b = 1 jump _L2 # 跳转到_L2，跳过else块 _L1: _T2 = -1 # 代表b = -1 jump _L2 # 跳转到_L2 _L2: ret _T2 我们将在中间代码生成中介绍生成中间代码时需要考虑的地方和并列举一些实例。 中端优化 中端的优化是编译器的一个重要组成部分，它可以在保持程序功能不变的前提下，提高程序的性能。中端优化的目标是提高程序的性能，减少程序的运行时间和资源消耗。中端优化的方法有很多，比如常量传播、死代码消除、循环不变量外提、循环展开、函数内联等。 一个经典的例子是常量传播。常量传播是指将一个常量值替换为它的值，以便于在中端直接完成一些计算以降低运行时开销。比如，对于下面的 IR 代码： _T1 = 5 _T2 = _T1 + 6 _T3 = _T2 + 7 _T4 = _T3 + 8 _T5 = _T4 + 9 ret _T5 经过常量传播优化后，可以得到： _T1 = 5 _T2 = 11 _T3 = 18 _T4 = 26 _T5 = 35 ret _T5 进一步如果我们进行死代码消除，可以得到： 死代码消除是指删除程序中没有用到的代码，以减少程序的运行时间和资源消耗。 _T5 = 35 ret _T5 中端优化依赖与数据流、控制流分析，你需要先了解一些数据流分析的基础知识才能进行一些中端优化。 我们的文档里在数据流分析中对数据流分析进行了简单介绍，你可以在这里了解一些数据流分析的基础知识。除了这个文档中介绍的数据流分析，还有很多其他的数据流分析方法，比如Use-Def链、Def-Use链、可达定义分析等。 我们在文档中对两个优化进行简单介绍，详见常量传播和死代码消除。 中端参考资料 本章中我们以几个简单的例子介绍了什么是中间表示、中端优化以及如何做中端优化。此外我们也将会在这里给出一些中端优化的参考资料，供大家学习。 GCM & GVM Engineering A Compiler LLVM IR SSA book 预期目标 完成这部分内容后，你的编译器应该能将 MiniDecaf 程序翻译成 IR，并能够输出 IR。进一步地，如果你希望参加性能评测，你还需要实现一些中端优化。 "},"docs/contest/midend/ir.html":{"url":"docs/contest/midend/ir.html","title":"中间表示设计","keywords":"","body":"中间表示设计 这里我们以一种经典 IR —— 三地址码为例，介绍中间表示的设计。 三地址码 三地址码（Three Address Code, TAC）是一种经典的 IR 设计，TAC 看起来很像汇编，与汇编最大的区别在于 —— 汇编里面使用的是目标平台（如 risc-v, x86, mips）规定的物理寄存器，其数目有限；而 TAC 使用的是 “虚拟寄存器” （也可以称作临时变量），其数目不受限制，可以任意使用（这意味着直接将临时变量转化为物理寄存器可能会出现寄存器不够用的情况）。在后端生成汇编代码时，我们再考虑如何为临时变量分配物理寄存器的问题。 main: # main 函数入口标签 _T0 = 1 # 加载立即数 _T1 = _T0 # 临时变量赋值操作 _T2 = ADD _T0, _T1 # 加法操作 _T2 = _T0 + _T1 _T3 = NEG _T0 # 取负操作 _T3 = -_T0 return _T2 # 函数返回 以上给出了一份 TAC 示例程序。请注意 TAC 代码只是一种中间表示，并不需要像汇编语言那样有严格的语法。因此，可以自由选择输出 TAC 代码的格式，只要方便自己调试即可。例如，你也可以将 _T2 = ADD _T0, _T1 输出成 _T2 = _T0 + _T1。下面是另一个IR输出格式的例子： i32 main() { _B0: i32 _T0 = 1 i32 _T1 = _T0 i32 _T2 = _T0 + _T1 i32 _T3 = -_T0 return i32 _T2 } 你会发现，这种IR输出格式包含了一些类型信息，也更加易读。 TAC 指令与汇编指令比较类似，每条 TAC 指令由操作码和操作数（最多3个，函数调用除外，由于函数参数可能有多个，使用严格的三个操作数反而会使得函数实现更为复杂）构成。操作数可能会有：临时变量、常量、标签（可理解为常量地址）和全局变量。 我们来思考一下，如果需要完整描述源程序的语义，需要哪些语句？ 算术语句：这是计算机最基础的语义。 二元运算（如加、减、乘、除） 形式：dst = op src1, src2 示例：_T2 = ADD _T0, _T1 一元运算（如取负、取位反） 形式：dst = op src 示例：_T3 = NEG _T0 跳转语句：用于实现程序的控制流，如循环和条件跳转，通常结合标签使用。 条件跳转语句 形式：branch cond, label1, label2 示例：branch _T0, _L1, _L2 无条件跳转语句 形式：jump label 示例：jump _L0 函数调用语句 形式：dst = call (func_name, arg1, arg2, ...) 示例：_T2 = call (foo, _T0, _T1) 赋值语句 形式：dst = src 示例：_T2 = _T0 访存语句 加载操作：dst = load addr, offset 示例：_T2 = load _T0, 0 存储操作：store src, addr, offset 示例：store _T0, _T1, 0 内存申请语句（注意区分，这里指编译器静态分配，与运行时动态分配的 malloc 不同，主要用于在栈上分配内存） 形式：dst = alloc size 示例：_T2 = alloc 40 返回语句 形式：return src 示例：return _T0 有了这些语句以后，我们的IR就可以描述源程序的语义了。 内存数据结构 中间表示是一种内存数据结构，不仅需要方便阅读，还需要方便进行后续操作（如优化、翻译）。 我们可以为所有指令定义一个基类 Instruction，然后根据不同的指令类型定义不同的子类。 struct Instruction { Type type; }; 下面以二元运算指令为例，展示如何定义一个具体的指令类。 二元运算需要两个操作数，并且会产生一个计算结果。 而操作数可能是一个立即数，也可能是一个变量。例如以下的情况： _T2 = ADD _T0, _T1 _T3 = ADD _T0, 2 因此为了指令实现方便，我们可以将操作数定义为一个如下的结构体： struct Operand { union{ int value; int reg_id; }; bool is_reg; ... ... }; 我们使用一个 union 来存储操作数的值或者寄存器编号，使用一个 bool 来标记操作数是否是一个寄存器。当然，你可以要求操作数必须是寄存器，这样就不需要 is_reg 这个标记了。这样你需要增加一条指令，将立即数分配到一个寄存器中。 有了操作数，我们就可以定义指令了，我们将二元运算指令定义为如下的结构体，其中Opcode是操作码，用来标记不同的二元运算类型，src1和src2是两个操作数，dst是运算结果存放的寄存器： enum Opcode { ADD, SUB, MUL, DIV }; struct Binary : public Instruction { Opcode opcode; // 操作码 Operand src1; // 操作数一 Operand src2; // 操作数二 Operand dst; // 目标寄存器 }; 一元运算指令的定义与二元运算指令的定义类似，这里不再赘述。 跳转语句应该怎么定义？这里我们需要引入基本块的概念。 在中端进行优化时，我们需要进行数据流分析和控制流分析，控制流分析过程中我们会将程序分解为多个基本块，基本块是一系列连续的指令序列，基本块内部指令序列的执行顺序是固定的，且不会被其他指令打断。我们可以将基本块定义为如下的结构体： struct BasicBlock { std::vector instructions; std::string label; }; 基本块的引入可以让我们便捷地进行各种编译优化，同时也简化了跳转语句的设计，只需要一个目标基本块即可： struct Jump : public Instruction { BasicBlock *target; // 跳转目标 }; 我们是以函数为单位来组织基本块的，函数定义为如下的结构体： struct Function { std::string name; std::vector blocks; }; 整个程序又是由多个函数和全局变量组成的，因此我们可以将程序定义为如下的结构体： struct Program { std::vector functions; std::vector globals; }; 你会发现，我们的程序组织成了一个树状结构，即 Program 包含多个 Function，每个 Function 包含多个 BasicBlock，每个 BasicBlock 包含多条 Instruction。 一些tips： 你可以在Instruction的层次上再次进行抽象，将运算指令和跳转分开，设计专门的运算指令类和跳转指令类，这样可以让程序的结构更加清晰，比如你可以将 Binary 和 Unary 都继承自 Arithmetic，将 Jump 继承自 ControlFlow， Arithmetic 和 ControlFlow 都继承自 Instruction。 你可以在Instruction中添加一些成员变量，如use和def，用于在数据流分析后记录一些中间结果用于优化。 你完全可以不按照我们给出的这些结构来设计你的 IR，这里有一些参考： 北大编译实验Koopa IR LLVM IR 静态单赋值（SSA） 进一步地，你可以实现符合静态单赋值要求的 IR ，静态单赋值的 IR 在编译器中有着广泛的应用，比如 LLVM 的 IR 就是一种静态单赋值的 IR。在静态单赋值的 IR 中，每个变量只被赋值一次，这使得编译器可以更容易地进行优化。 "},"docs/contest/midend/irgen.html":{"url":"docs/contest/midend/irgen.html","title":"中间代码生成","keywords":"","body":"中间代码生成 介绍 前端解析后，我们会得到一棵抽象语法树，接下来我们需要将这棵抽象语法树转换为中间代码。依据你设计的IR，你需要在保证语义的情况下，将AST用你的IR表示出来。可以参考基础实验框架中frontend/tacgen/的代码。推荐在生成中间代码时就先利用 Alloca、Load、Store 指令来简单地实现 SSA 形式的中间代码，方便之后用mem2reg进一步优化（你可以先阅读静态单赋值简单了解什么是SSA）。 部分处理思路 整体思路是通过遍历AST的节点，根据节点类型进行相应的处理。推荐先根据AST的遍历顺序写一个框架，再填充具体的处理逻辑。 由于每个组的AST和IR设计不尽相同，本部分仅介绍一些重点的处理思路和具体示例，结合小实验文档食用效果更佳。 注意： 本部分仅供参考，你需要根据自己设计的AST和IR进行调整。 在遍历AST的过程中，要记得维护一些数据，比如当前所在函数、当前所在基本块、函数的寄存器数量、函数的基本块数量、前端变量到IR的Data对象的映射表等。 program 对于program节点，先新建一个IR的Program对象，然后我们只需要再遍历子节点。 如果子节点是function，就新建一个IR的Function对象，再访问该function节点，从而将该函数的前端信息存入Function对象中，最后将其加入到当前Program对象中的functions列表。 如果子节点是declaration，说明这是一个全局变量，就新建一个Data对象，再访问该declaration节点，从而将该全局变量的前端信息存入Data对象中，最后将其加入到当前Program对象中的global_data列表。 parameter_list 对于parameter_list节点，可以把前几个寄存器编号分配给参数。 如果是标量参数，要另外在栈上开空间。（这是为了满足 SSA 形式） 如果是数组参数，则可以直接保存在寄存器中。 declaration 对于declaration节点，需要根据是否为全局变量、是否为数组来进行处理。为了满足 SSA 形式，哪怕是局部标量，也要用Alloca指令得到一个地址，后续就通过这个地址来对该变量进行读写操作。 如果有初始化， 对于标量，需要访问expression节点并获取其运算结果对应的寄存器，然后新增Store指令，表示将得到的寄存器的值存入该标量对应的地址。 对于数组则需要遍历Integer节点，并分别使用Store指令将数组元素存入数组的相应地址，对于全局变量可以考虑是否加入.bss段。 lvalue lvalue节点表示的是左值，可能出现的地方为：assignment的等号左边部分、expression的某个部分，如果是后者且该节点表示的是一个具体值，则返回存有该值的寄存器，否则返回其对应地址的寄存器。（下面会对“表示的是一个具体值”进行解释） 先通过前端变量到IR的Data对象的映射表，找到该节点所表示的前端变量对应的Data对象。 如果这是个全局变量，则新增LoadAddr指令，表示加载全局变量的地址，获取对应地址的寄存器 如果这是个局部变量，则直接通过Data对象获取对应地址的寄存器 如果这是个数组，那么前端节点应该会记录下标，每个下标都是expression节点，故需要访问每个下标节点，获取其运算结果对应的寄存器，可以将这些寄存器存起来，比如存进index_temps中，之后再利用这些信息来构造相应的GetElementPtr指令，表示通过数组基地址和下标获取元素的地址。 目前不管是全局变量还是局部变量，不管是标量还是数组，我们得到的都是存有其对应地址的寄存器，需要根据具体情况确定返回内容。 如果该lvalue节点是expression的某个部分，且表示的是一个具体值，则先新增Load指令，表示将地址里的值加载到一个寄存器中，最后返回这个寄存器；否则，就直接返回其对应地址的寄存器。 什么是“表示的是一个具体值”？举个例子，如果已知有一个数组a[2][3]，那么如果该lvalue节点表示的是a[1][2]，则表示的是一个具体值，如果表示的是a、a[0]，则不是一个具体值而是一个地址。 中场休息 看了前面的内容感觉很抽象怎么办？没关系，我们不急着往后学，先休息一下，看一个具体的用到parameter_list, declaration, lvalue节点的例子，希望能帮到你。 int a = 1; int foo(int x, int y[]) { return x + y[1]; } int main() { int b[2][3] = {1, 2, 3, 4, 5, 6}; return foo(a, b[1]); } 生成的AST可能如下： ``` 上述代码转化为IR后可能如下： ```asm i32 foo(i32 _T0, i32* _T1) { _B0: alloca i32* _T2 = 4 store *(i32* _T2 + 0) = i32 _T0 load i32 _T3 = *(i32* _T2 + 0) i32 _T4 = 1 i32* _T5 = elementptr: i32* _T1[i32 _T4] load i32 _T6 = *(i32* _T5 + 0) i32 _T7 = i32 _T3 + i32 _T6 return i32 _T7 } i32 main() { _B0: alloca i32[3]* _T0 = 24 i32 _T1 = 1 store *(i32[3]* _T0 + 0) = i32 _T1 i32 _T2 = 2 store *(i32[3]* _T0 + 4) = i32 _T2 i32 _T3 = 3 store *(i32[3]* _T0 + 8) = i32 _T3 i32 _T4 = 4 store *(i32[3]* _T0 + 12) = i32 _T4 i32 _T5 = 5 store *(i32[3]* _T0 + 16) = i32 _T5 i32 _T6 = 6 store *(i32[3]* _T0 + 20) = i32 _T6 i32* _T7 = LoadAddr $a load i32 _T8 = *(i32* _T7 + 0) i32 _T9 = 1 i32* _T10 = elementptr: i32[3]* _T0[i32 _T9] i32 _T11 = call foo(i32 _T8, i32* _T10) return i32 _T11 } 在本例中， foo函数的参数表示为_T0, _T1。为了满足 SSA 形式，使用标量x时，需要另外在栈上开空间，这样之后对x的读写操作都可以直接通过_T2来进行。对于y[1]，利用下标和getElementptr指令可以得到其地址，然后通过load指令可以得到其值。（getElementptr指令是为了写起来方便快捷；这里你也可以通过基地址_T1和下标1，构造出_T1 + 1 * 4的式子来计算出y[1]的地址） main函数中对于数组b，先使用Alloca指令获取其栈上地址，再将初始值存到各个元素的地址中。由于a是foo函数的实参，所以这是一个lvalue节点，同时我们知道这是一个具体值，所以在LoadAddr指令获取a的地址之后，还要用Load指令将其值加载到一个寄存器中。b[1]在这里虽然也是一个lvalue节点，但是由于它不是一个具体值，所以我们直接使用其对应地址的寄存器。 expression 访问expression节点之后需要返回存有其运算结果的寄存器，方便后续使用。以下分两种情况进行处理： unary '=' expression，表示赋值表达式。 对于等号左边，访问该lvalue节点并获取其对应地址的寄存器。 对于等号右边，访问该expression节点并获取其运算结果对应的寄存器。 最后新增Store指令，表示将右边的寄存器里的值存入左边的寄存器里的地址，并返回左边的寄存器。 conditional，表示条件表达式。 如果这是个三目运算符，可参考if节点的处理方式，区别在于，对于:?运算符，then 和 else 是两个表达式节点，对于if语句，这两个变量是两个语句节点。 如果这是个logical_or节点，则直接访问logical_or节点，由于可能出现逻辑短路的情况，所以你需要思考如何新增Branch指令来进行分支跳转，可以参考短路求值。 具体示例可以参考短路求值。 if 先给当前函数新增一个基本块true_bb表示if语句的true分支入口。 如果有else部分，则给当前函数新增一个基本块false_bb表示if语句的false分支入口。 给当前函数新增一个基本块next_bb表示if之后的基本块。 分支条件是一个expression节点，访问该expression节点并获取其运算结果对应的寄存器。 由于expression节点可能出现逻辑短路的情况，所以你需要思考如何新增Branch指令来进行分支跳转，可以参考短路求值。 将当前基本块改为true_bb，然后访问true分支的前端节点，再新增一个Jump指令，表示从true_bb跳转到next_bb。 如果有else部分，则将当前基本块改为false_bb，然后访问false分支的前端节点，再新增一个Jump指令，表示从false_bb跳转到next_bb。 最后将当前基本块改为next_bb。 例： int main(){ int a = 2; int b = 0; if(a) b = 1; else b = -1; return b; } 生成的AST可能如下： Program |- (children[0]) Function |- (ret_t) TInt |- (ident) Identifier(\"main\") |- (body) Block |- (children[0]) VarDecl |- (type) TInt |- (ident) Identifier(\"a\") |- (init) IntLiteral(2) |- (children[1]) VarDecl |- (type) TInt |- (ident) Identifier(\"b\") |- (init) IntLiteral(0) |- (children[2]) If |- (cond) Identifier(\"a\") |- (children[0]) Assign |- (lhs) Identifier(\"b\") |- (rhs) IntLiteral(1) |- (children[1]) Assign |- (lhs) Identifier(\"b\") |- (rhs) UnaryOp(NEG) |- (expr) IntLiteral(1) |- (children[3]) Return |- (expr) Identifier(\"b\") 上述代码转化为IR后可能如下： i32 main() { _B0: alloca i32* _T0 = 4 i32 _T1 = 2 store *(i32* _T0 + 0) = i32 _T1 alloca i32* _T2 = 4 i32 _T3 = 0 store *(i32* _T2 + 0) = i32 _T3 load i32 _T4 = *(i32* _T0 + 0) if i32 _T4 == 0 jump _B2 else jump _B1 _B1: i32 _T5 = 1 store *(i32* _T2 + 0) = i32 _T5 jump _B3 _B2: i32 _T6 = 1 i32 _T7 = -i32 _T6 store *(i32* _T2 + 0) = i32 _T7 jump _B3 _B3: load i32 _T8 = *(i32* _T2 + 0) return i32 _T8 } 在本例中，生成了_B1, _B2, _B3三个基本块，分别表示true分支入口、false分支入口和if之后的基本块。_B0的结尾是一个Branch指令，_B1, _B2结尾都是Jump指令，表示从true_bb、false_bb跳转到next_bb。 while 这里的翻译方式采用的是step8的思考题中的第二种。在翻译过程中，你还要维护好循环所需的break/continue标签。 给当前函数新增一个基本块body_bb表示while语句的循环体入口。 给当前函数新增一个基本块body_cond_bb表示第二个while语句的条件部分。 给当前函数新增一个基本块next_bb表示while之后的基本块。 开始访问第一个while语句的条件部分，分支条件是一个expression节点，可以直接访问该expression节点。 由于expression节点可能出现逻辑短路的情况，所以你需要思考如何新增Branch指令来进行分支跳转，可以参考短路求值进行学习。 将当前基本块改为body_bb，然后访问true分支的前端节点，再新增一个Jump指令，表示从body_bb跳转到body_cond_bb。 将当前基本块改为body_cond_bb，第二个while语句的条件部分是一个expression节点，访问该expression节点并获取其运算结果对应的寄存器。 由于expression节点可能出现逻辑短路的情况，所以你需要思考如何新增Branch指令来进行分支跳转，可以参考短路求值进行学习。 最后将当前基本块改为next_bb。 例： int main(){ int a = 0; while(a 生成的AST可能如下： 上述代码转化为IR后可能如下： i32 main() { _B0: alloca i32* _T0 = 4 i32 _T1 = 0 store *(i32* _T0 + 0) = i32 _T1 load i32 _T2 = *(i32* _T0 + 0) i32 _T3 = 10 i32 _T4 = i32 _T2 在本例中，_B0的最后是第一个while语句的条件部分，while语句还生成了_B1, _B2, _B3三个基本块，分别表示while语句的循环体入口、第二个while语句的条件部分和while之后的基本块。if语句生成了_B4, _B5两个基本块。多出来的_B6是个不可达基本块，可以在之后生成目标代码时消掉。（思考一下，为什么要生成_B6？提示：如果break;语句后面加上a = 1;语句，IR会如何改变？） 预期目标 完成这部分内容后，你的编译器应该能将 MiniDecaf 程序翻译成满足 SSA 形式的 IR，并能够输出 IR。进一步地，如果你希望参加性能评测，你还需要实现一些中端优化。 "},"docs/contest/midend/ssa.html":{"url":"docs/contest/midend/ssa.html","title":"静态单赋值","keywords":"","body":"静态单赋值 静态单赋值这一小节参考并改编自北航的编译课程实验文档： https://buaa-se-compiling.github.io/miniSysY-tutorial/challenge/mem2reg/help.html 在此表示感谢！ 静态单赋值（Static Single Assignment, SSA）是编译器中间表示（IR）阶段的一个重要概念，它要求程序中每个变量在使用之前只被赋值一次。 例如，考虑使用 IR 编写程序计算 1 + 2 + 3 的值，一种可能的写法为： _T0 = 1 _T1 = 2 _T2 = 3 _T3 = _T0 + _T1 _T3 = _T3 + _T2 ret _T3 很遗憾，上述程序并不符合 SSA 的要求，因为其中变量 _T3 被赋值了两次。正确的写法应该为： _T0 = 1 _T1 = 2 _T2 = 3 _T3 = _T0 + _T1 _T4 = _T3 + _T2 ret _T4 我们为什么要这样做呢？ 因为 SSA 可以简化每个变量的属性，进而简化编译器的优化过程。 例如，考虑下面这段伪代码： y = 1 y = 2 x = y 很显然，其中变量 y 的第一次赋值是不必须的，因为变量 y 被使用前，经历了第二次赋值。对于编译器而言，确定这一关系并不容易，需要经过定义分析（Reaching Definition Analysis）的过程。在很多控制流复杂的情况下，上述过程将变得更加困难。 但如果将上述代码变为 SSA 形式： y1 = 1 y2 = 2 x1 = y2 上述关系变得更加显而易见，由于每一个变量只被赋值一次，编译器可以轻松地得到 x1 的值来自于 y2 这一信息。 正因如此，许多编译器优化算法都建立在 SSA 的基础之上，例如：死代码消除（dead code elimination）、常量传播（constant propagation）、值域传播（value range propagation）等。 我们如何实现 SSA 呢？ 例如，考虑使用 IR 编写程序使用循环计算 5 的阶乘。 按照 C 语言的思路，我们可能给出如下写法： _L0: _T0 = 0 _T1 = 1 _T2 = 2 _T3 = _T0 + _T1 # int temp = 1 _T4 = _T0 + _T2 # int i = 2 _T5 = 5 _L1: _T6 = _T4 我们注意到，变量 _T3 和 _T4 由于循环体的存在可能被赋值多次，因此上述写法并不符合 SSA 的要求。 一种可能的方案是使用 Phi 指令。Phi 指令的语法是 = PHI [, ], [, ] ... 。它使得我们可以根据进入当前基本块之前执行的是哪一个基本块的代码来选择一个变量的值。 由此，我们的程序可以改写为： _L0: _T0 = 2 _T1 = 1 _L1: _T2 = PHI [_T0, _L0], [_T6, _L2] # int i = 2 _T3 = PHI [_T1, _L0], [_T7, _L2] # int temp = 1 _T4 = 5 _T5 = _T2 由此，上述程序中每一个变量只被赋值了一次，满足了 SSA 的要求。（注意，SSA 仅要求变量在静态阶段被单一赋值，而不是在运行时仅被赋值一次） 另一种可能的方案是使用 Alloca、Load 和 Store 的组合。SSA 要求中间表示阶段虚拟寄存器满足单一赋值要求，但并不要求内存地址如此。因此，我们可以在前端生成中间代码时，将每一个变量都按照栈的方式使用 Alloca 指令分配到内存中，之后每次访问变量都通过 Load 或 Store 指令显式地读写内存。使用上述方案编写的程序满足 SSA 的要求，且避免了繁琐地构造 Phi 指令，但频繁地访问内存将导致严重的性能问题。 有没有更好的解决方案呢？ 有，我们可以将两种方案结合起来。 在前端生成中间代码时，首先使用第二种方案利用 Alloca、Load、Store 指令快速地构建满足 SSA 要求的代码。 随后，在上述代码的基础上， 将其中分配的内存变量转化为虚拟寄存器，并在合适的地方插入 Phi 指令。 这一解决方案也被称为 mem2reg 技术。 mem2reg 使得我们可以在生成中间代码时，使用 Alloc、Load 和 Store 的组合针对局部变量生成符合 SSA 要求的代码。 举个例子，一种可能的中间代码表示为： main: _T0 = alloc 4 _T1 = alloc 4 store _T0, 1 load _T2, _T0 _T4 = _T2 > 0 beqz _T4, _L2 store _T2, 1 _L1: load _T5, _T2 ret _T5 _L2: _T6 = 0 - 1 store _T2, _T6 jump _L1 在此基础上，进行 mem2reg 转化： main: _T0 = 1 > 0 beqz _T0, _L2 _L1: _T2 = phi [1, main], [_T3, _L2] ret _T2 _L2: _T3 = 0 - 1 jump _L1 需要注意的是，所有的 Phi 指令应当在基本块的开头同时支持并行执行（即在同一个基本块内的 Phi 指令的顺序对结果没有影响）。 在实现 mem2reg 时，我们需要首先对代码进行数据流分析，计算控制流图中的支配关系和每个基本块的支配边界。 相关的解释和详细说明可以参考： 如何构建 SSA 形式的 CFG：https://szp15.com/post/how-to-construct-ssa/ 随后，我们需要实现 SSA 构造算法。一种常用的算法是将整个过程分为：插入 phi 函数和变量重命名，两个阶段。 在第一阶段，记录每个局部变量相关的 Alloc 和 Store 指令，并由此在基本块的开头插入 Phi 指令。 在第二阶段，遍历所有基本块，对其中局部变量相关的 Alloc，Load 和 Store 指令进行改写，以保证程序语义的正确性。在遍历一个基本块的所有指令后，维护该基本块的所有后继基本块中的 Phi 指令。 相关的解释和详细说明可以参考： Static Single Assignment Book 的 Chapter3：https://pfalcon.github.io/ssabook/latest/ "},"docs/contest/midend/cp.html":{"url":"docs/contest/midend/cp.html","title":"常量传播","keywords":"","body":"常量传播/常量折叠 常量传播/常量折叠的目的在于发掘代码中可能存在的常量，尽量用对常量的引用替代对虚拟寄存器的引用(虚拟寄存器和变量是同一个概念，以下都使用变量)，并尽量计算出可以计算的常量表达式。 常量传播通常依赖Use-Def和Def-Use数据流分析（这里有一个参考资料），这个数据流分析可以帮我们找到每个指令用到的变量是在哪里定义的。 例如，对于如下代码： _main: _T0 = 2 _T1 = 0 _T2 = _T0 + 3 _T3 = _T1 + 5 _T4 = _T2 * 2 _T5 = _T3 - _T1 _T6 = _T4 + _T5 ret _T6 经过常量传播/常量折叠优化后，代码变为： _main: _T0 = 2 _T1 = 0 _T2 = 5 _T3 = 5 _T4 = 10 _T5 = 5 _T6 = 15 ret _T6 常量传播/常量折叠的实现 常量传播/常量折叠的实现依赖于数据流分析，一种可能的实现方法如下： 遍历所有语句，找出常量定义，将其全部加入常量表。例如： _T0 = 2 _T1 = 0 _T2 = _T0 + 3 _T0和_T1的值是常量，将_T0和_T1的值分别存入常量表。 依据Def-Use关系，找出所有用到常量_T0和_T1的地方，如果这些地方计算的结果也是常量，则将计算结果也加入常量表。上述代码中，_T2的值为5，也是一个常量，将_T2的值加入常量表。 重复上述过程，直到常量表不再增加为止。 "},"docs/contest/midend/dce.html":{"url":"docs/contest/midend/dce.html","title":"死代码消除","keywords":"","body":"死代码消除 死代码消除（Dead code elimination, DCE）即无用代码消除，死代码和不可达代码是两个概念。前者指的是执行之后没有任何作用的代码（例如：多余的计算），后者指的是永远无法被执行到的代码。 死代码消除通常依赖于Use-Def和Def-Use数据流分析，这个数据流分析可以帮我们找到每个指令用到的变量是在哪里定义的。 这里介绍一种 DCE 的方法（来源于《高级编译器设计与实现》（鲸书））： 首先，标识所有计算必要值的指令。比如在函数中要返回（return）或输出（print）的值，或者它可能会对从函数外访问的存储单元有影响（全局内存访问，对函数外定义的数组访问）。 然后，以迭代的方式逐步标记对这种对计算必要值有贡献的指令。假如一个指令的结果是另一个必要值计算指令的输入，那么这个指令也是必要的。 当以上迭代函数稳定不变时，所有未标记的指令都可以认为是Dead Code，可以删除。 具体实现上，可以借助du/ud链来实现： 维护一个set，存储所有必要值的定义指令。 找出函数所有的必要值，标记这些值的定义指令。 对于set中的每个指令，顺着ud链找到所有使用这个指令的指令，将这些指令加入set。 对于上一步中新加入的指令，继续顺着ud链找到所有使用这个指令的指令，将这些指令加入set。 重复上一步，直到set不再变化。 函数中的指令，如果不在set中，就可以认为是Dead Code。 此处举个例子： _main: _T0 = 1 _T1 = 2 _T2 = _T1 + 5 _T3 = _T0 + 2 _T4 = _T3 * 5 return _T4 # _T4 是必要值 顺着ud链，可以找到 _T4 = _T3 * 5，因此 _T3 也是必要值。继续找到 _T3 = _T0 + 2，因此 _T0 也是必要值。最终 _T0、_T3、_T4 都是必要值，而 _T1、_T2 的定义指令都可以认为是Dead Code。 因此可以优化为： _main: _T0 = 1 _T3 = _T0 + 2 _T4 = _T3 * 5 return _T4 "},"docs/contest/backend.html":{"url":"docs/contest/backend.html","title":"后端设计","keywords":"","body":"后端设计 编译器后端的主要功能是将中间表示（IR）转换为目标架构的汇编代码，在我们的课程实验中即将TAC翻译为RISC-V汇编代码。与目标机器架构紧密相关的优化也会在这一阶段进行。 代码生成 目标代码的生成是后端的核心部分。通常中间表示不会与目标架构的汇编代码非常相似，一方面它们所用的指令不一样，另外中间表示也会省略掉与物理寄存器和函数调用的若干细节。这要求我们在将IR翻译为汇编指令时处理好这些缺失的部分，生成合法的汇编程序。 指令选择 对于一条IR指令，选择合适的汇编指令对应物。对于大部分算术指令，一对一翻译即可，这没有什么难度；而某些IR指令没有直接的相应汇编指令，需要被翻译为多条汇编指令。你可能需要选择相对更优的候选指令序列。一对多指令翻译包含一些微妙之处，比如可能引入额外的寄存器、有潜在的副作用、干扰数据流分析，有时将它们视为一个指令整体是更合理的选择。你可能需要恰当地选择将一条“指令”彻底地转化为汇编指令的时机。 这里举几个例子： 逻辑与和逻辑或。可详见step4。 函数调用。函数调用通常不止一条call指令，在它之前需要生成传参的指令（参数少时用mv，多的时候压栈），在它之后可能要修改栈指针。 SSA IR中的Phi指令。通常Phi指令会被翻译为mv指令，但留意多条Phi指令同时存在的情况，它们在语义上“同时发生”，而实际指令序列具有顺序，这可能导致寄存器中的值被错误覆盖。 寄存器分配 IR里通常会假设数量无限的虚拟寄存器（或称作变量），但目标ISA（Instruction Set Architecture）通常只允许有限数量的物理寄存器，我们必须将虚拟寄存器映射到物理寄存器上。如果物理寄存器无法容纳所有的活跃变量，它们就需要溢出（spill）到栈上。大多数架构上寄存器访问开销显著低于内存访问开销，因此我们应尽量避免发生spill。 课程实验使用的寄存器分配算法非常简单，它以基本块为单位，在基本块结束处活跃的变量会全部被spill到栈上。你会发现这个算法显得比较愚蠢，产生了大量实际无用的load和store指令。因此，你需要实现一个“全局”的寄存器分配算法，它应当能够跨基本块进行分析。（这里的“全局”通常以函数为粒度） 常见的全局寄存器分配算法包括图染色和线性扫描。由于我们并没有较为严格的编译时间要求，大家可以使用step13中提到的图染色算法。该算法的一个优势在于能够顺带处理mv指令，可以消除掉无用复制，这使得你前面做代码生成时可以轻松一点（能够较为无顾虑地生成mv指令）。 寄存器分配算法中存在一个比较微妙的地方：当我们不得不选择一个变量spill时，优先选择哪个变量。通常这里是启发式的，我们需要对每个变量设置一个优先级或溢出权重（spill weight）。假设我们已知一个变量中存放的是常数，那么它的保存和恢复开销都会比其它变量更低：无须保存，恢复时只需一条li指令而不必生成load。这种低spill开销的变量可以优先成为被踢出内存的倒霉蛋候选。（思考：我们是否应该优先spill循环体中的变量？）为了给变量设定合理的溢出权重，你可能需要依赖一些分析pass的结果。 栈帧确定和最终代码生成 在代码生成的早期阶段我们无法确定最终栈帧的大小。比如在寄存器分配阶段产生的溢出变量会使得栈帧大小增加，我们需要追踪栈上变量的偏移量和大小。留意load和store指令中允许的立即数偏移范围，当一个函数具有巨大的栈帧时，你可能需要插入一些额外的代码来计算栈上的地址或访问栈上的变量，甚至需要重新进行寄存器分配。 在这里我们介绍一种可能的实现方式。我们暂不考虑VLA（variable-length array），即认为栈上的所有对象都可以在编译期确定大小。首先我们将栈上的对象统一抽象为StackObject，包括栈上的数组、溢出的临时变量、用栈传入的函数参数。然后所有对栈的操作均使用单独的“指令”，例如 LoadFromStack t0, obj, offset: 将栈上对象obj偏移offset（立即数）处的内容加载到 t0 StoreToStack t0, obj, offset：将t0中的内容写入到栈上对象obj偏移offset处 LoadStackAddr t0, obj, offset：计算栈上对象obj偏移offset处的地址，将结果存放在t0 代码生成的大部分阶段均保持以上指令形式。最终确定栈帧时，统计所有栈上对象并为它们赋予一个相对栈帧的偏移。如果你打算在生成的代码中使用栈帧指针fp（frame pointer），展开的指令中可以直接使用这个偏移；如果你打算用栈指针sp进行寻址，你最好维护指令序列中sp发生的变化并计算栈上对象相对于sp的偏移（主要为了应对涉及栈传参的函数调用）。 最终我们将以上的这些“指令”展开。例如LoadFromStack可以保守地展开为以下RISC-V指令序列： li t0, (some immediate offset) add t0, sp, t0 ld t0, 0(t0) 但大多数时候ld t0, offset(sp)就足够了。需要注意的是StoreToStack可能无法展开，也许要在更早的阶段引入额外的临时变量并将其变换为LoadStackAddr和一条store指令。 确定栈帧后生成函数的prologue和epilogue，其中主要包括callee-saved寄存器的保存与恢复、对栈指针的调整。注意有些架构可能对栈指针有对齐要求（e.g. 必须是8的整数倍）。 附：函数调用相关 处理函数调用通常需要插入额外的指令用于传参，而寄存器传参的调用约定又和寄存器分配有一定关系。在Iterated Register Coalescing的论文中并没有提及函数调用约定的处理方式，在这里以RISC-V为例进行一些说明。一种直观的想法是将函数参数对应的临时变量直接预着色为对应的参数寄存器，但这样的方案存在较明显的问题。下面展示两个C语言片段： int f(int x) { // lots of stuff... return x; } 在这个例子中，如果我们将x对应的临时变量直接绑定到参数寄存器a0上，那么a0即x具有超长的生命周期，可能与大量的临时变量节点相干涉。如果中间的代码含有其它函数调用，对a0的使用存在冲突，有可能需要生成大量load/store。 int swap(int x, int y) { // ... swap(y, x); // ... } 对于外层swap，直观上x和y会被分别绑定到a0和a1；而中间再次调用swap时却又要求y在a0且x在a1中，这种冲突免不了一番折腾。 可以发现问题在于我们强行把参数变量和参数寄存器的生命周期绑定在了一起，而事实上调用约定只要求在传参时参数变量位于指定寄存器中。在函数体其它部分的代码中，调用约定不关心也管不着参数变量到底在哪个寄存器里。你可能会反驳：我们其实也关心，尽量让参数变量分配到对应的参数寄存器中有助于减少无意义的move指令。没错，但这个步骤可以交给寄存器分配算法和后续优化处理，在生成代码时我们更关注代码逻辑，应当将参数变量和传参时的寄存器解耦。 具体而言，这种解耦可以通过插入新的临时变量和move指令实现。（在下面的描述中只考虑寄存器传参） 调用其它函数前：假设函数调用的实参位于临时变量x1至xn中。那么我们引入新临时变量T1到Tn，然后按照mv Ti, xi的方式将全部xi移入Ti中，接下来再生成mv aj, Ti复制到目标参数寄存器。注意这里的2n条mv指令形成了两阶段，每个阶段内部的move指令顺序不重要，但不要跨阶段移动指令。 处理在寄存器中的传入参数：假设函数的形参对应临时变量x1到xn。直接在函数开头生成mv xi, ai即可。 以上面的swap函数为例子，插入上述辅助指令后的汇编伪代码如下： swap: mv x, a0 # 1 mv y, a1 # 2 # first move phase mv _T0, x # 3 mv _T1, y # 4 # second move phase mv a0, _T1 # 5 mv a1, _T0 # 6 call swap 在经过带move合并的寄存器分配后，大概率会得到这样的汇编代码： swap: mv t0, a0 mv a0, a1 mv a1, t0 call swap 这里引入了最少数量的额外寄存器，正是我们所期望的变量交换代码。首先前两条mv指令提示寄存器分配算法合并x和a0、y和a1，这一分配方案是可行的，因此前两条无用mv被消去。接下来我们注意到_T0与a1相干涉（指令4的Use集合、指令3的LiveOut集合包含a1，_T0在指令3的Def集合中），因此_T0不能被分配到a1；同时_T0也与a0相干涉（指令6的Use集合，指令5的LiveOut集合包含_T0，a0在指令5的Def集合中），最终_T0被分配到一个新的寄存器t0。而_T1可以安全地被分配到a1，故指令4被视作无用指令消除。 在生成函数调用的代码时，除传参外，还需要考虑caller-saved寄存器的处理。在我们的基本实验框架中，你可以在call指令前后保存并恢复活跃且在caller-saved寄存器中的变量，这样在其它指令看来是无事发生。不过在这里有一种更简便的实现方式：将所有caller-saved寄存器加入到call指令的Def集合中，剩下的事情交给寄存器分配算法处理。考虑以下C语言片段： int getint(); void putint(int); int main() { int x = getint(); putint(x); return x; } 在寄存器分配前可能对应如下代码： main: # prologue call getint mv x, a0 mv a0, x # ... omitted call putint mv a0, x # epilogue ret 采用上述方式，x处于call putint的LiveOut集合中，会与全部的caller-saved寄存器相干涉，这样x就会自动被分配到callee-saved寄存器上。经过后续优化可能的最终汇编代码如下： main: # prologue call getint mv s0, a0 call putint mv a0, s0 # epilogue ret 目标架构相关优化 这里简单地举几个例子。 指令选择相关的窥孔优化 此类优化指的是将局部的几条指令替换为更优的指令序列的一类优化，并非特指。需要注意的是此类优化较为琐碎，建议按需实现。 例如以下的RISC-V指令序列 li t0, 0 bne a0, t0, label1 可以被替换为bne a0, zero, label1，后续再通过无用指令消除去掉li t0, 0（假设该值不再使用）。总的来说，一类优化机会包括识别出指令序列中的常量，尝试将它们嵌入至指令中（RISC-V的I型指令），并进行无效果指令消除（mv到自身、加0、乘1）、强度削减（乘除2的幂转移位，除法转乘法）等优化。 再举一个ARM的例子。ARM的访存指令支持基址+索引*4的寻址模式（类似x86），以下汇编指令序列 mov r1, r1, LSL #2 add r0, r0, r1 ldr r0, [r0] 可以被合并为一条指令： ldr r0, [r0, r1, LSL #2] 这种汇编代码模式在数组访问中较为常见。 指令调度 指令调度指的是在不影响指令逻辑的前提下调整指令的顺序，目的之一是利用现代处理器的特性提升指令级并行度。基本块内的指令调度首先会利用指令间的依赖关系构造DAG，然后利用关键路径长度、寄存器压力、处理器发射宽度等因素结合处理器功能单元的执行模型依次决定指令的执行顺序。感兴趣的同学可以自行查看相关资料。 "},"REFERENCE.html":{"url":"REFERENCE.html","title":"参考资料","keywords":"","body":"参考资料 Writing a C Compiler: by Nora Sandler An Incremental Approach to Compiler Construction : by Abdulaziz Ghuloum Monkey: The programming language that lives in books C17 标准草案 N2176（N2176 是 C17 标准正式发布前的最后一版草案，根据 C17 标准的编者之一 Jens Gustedt 的博文，其与 C17 标准相比只有表述上的差异） RISC-V 手册 RISC-V（非官方）汇编指令用法 "}}