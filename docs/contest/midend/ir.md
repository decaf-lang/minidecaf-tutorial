# 中间表示设计

这里我们以一种经典 IR —— 三地址码为例，介绍中间表示的设计。

## 三地址码

**三地址码**（Three Address Code, TAC）是一种经典的 IR 设计，TAC 看起来很像汇编，与汇编最大的区别在于 —— 汇编里面使用的是目标平台（如 risc-v, x86, mips）规定的物理寄存器，其数目有限；而 TAC 使用的是 **“虚拟寄存器”** （也可以称作临时变量），其数目不受限制，可以任意使用（这意味着直接将临时变量转化为物理寄存器可能会出现寄存器不够用的情况）。**在后端生成汇编代码时，我们再考虑如何为临时变量分配物理寄存器的问题。**

```asm
main:                  # main 函数入口标签
    _T0 = 1            # 加载立即数
    _T1 = _T0          # 临时变量赋值操作
    _T2 = ADD _T0, _T1 # 加法操作 _T2 = _T0 + _T1
    _T3 = NEG _T0      # 取负操作 _T3 = -_T0
    return _T2         # 函数返回
```

> 以上给出了一份 TAC 示例程序。请注意 TAC 代码只是一种中间表示，并不需要像汇编语言那样有严格的语法。因此，可以自由选择输出 TAC 代码的格式，只要方便自己调试即可。例如，你也可以将 _T2 = ADD _T0, _T1 输出成 _T2 = _T0 + _T1。

TAC 指令与汇编指令比较类似，每条 TAC 指令由操作码和操作数（最多3个，函数调用除外，由于函数参数可能有多个，使用严格的三个操作数反而会使得函数实现更为复杂）构成。操作数可能会有：临时变量、常量、标签（可理解为常量地址）和全局变量。

我们来思考一下，如果需要完整描述源程序的语义，需要哪些语句？

首先是基础的算术语句，这是计算机最基础的语义。
算术语句可以抽象为两大类：二元运算（如加减乘除）和一元运算（如取负、取位反）。

跳转语句，用于实现程序的控制

进一步地，你可以实现符合[静态单赋值](./ssa.md)要求的IR，静态单赋值的IR在编译器中有着广泛的应用，比如 LLVM 的 IR 就是一种静态单赋值的 IR。在静态单赋值的IR中，每个变量只被赋值一次，这使得编译器可以更容易地进行优化。

## 内存数据结构

中间表示是一种内存数据结构，不仅需要方便**阅读**，还需要方便**进行后续操作**（如优化、翻译）。

对于一条指令来说

```c++
struct Instruction {
    Type type;
};
```

```c++
struct Operand {
    union{
        int value;
        int var_id;
    }
    bool is_reg;
    ... ...
};

enum Opcode {
    ADD, SUB, MUL, DIV
};

struct Binary : public Instruction {
    Opcode opcode;           // 操作码
    Operand src1;            // 操作数一
    Operand src2;            // 操作数二
    Operand dst;             // 目标寄存器
};
```

