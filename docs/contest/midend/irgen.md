# 中间代码生成

## 介绍
前端解析后，我们会得到一棵抽象语法树，接下来我们需要将这棵抽象语法树转换为中间代码。依据你设计的IR，你需要在保证语义的情况下，将AST用你的IR表示出来。可以参考基础实验框架中`frontend/tacgen/`的代码。**推荐在生成中间代码时就先利用 Alloca、Load、Store 指令来简单地实现 SSA 形式的中间代码，方便之后用`mem2reg`进一步优化**。

## 部分处理思路
整体思路是通过遍历AST的节点，根据节点类型进行相应的处理。推荐先根据AST的遍历顺序写一个框架，再填充具体的处理逻辑。

由于每个组的AST和IR设计不尽相同，本部分仅介绍一些重点的处理思路和具体示例，结合小实验文档食用效果更佳。

为了讲解方便，接下来的IR使用的是[IR设计]()。

注意：
- **本部分仅供参考，你需要根据自己设计的AST和IR进行调整。**
- 在遍历AST的过程中，**要记得维护一些数据**，比如当前所在函数、当前所在基本块、函数的寄存器数量、函数的基本块数量、前端变量到IR的`Data`对象的映射表等。

### program
对于`program`节点，先新建一个IR的`Module`对象，然后我们只需要再遍历子节点。
- 如果子节点是`function`，就新建一个IR的`Function`对象，再访问该`function`节点，从而将该函数的前端信息存入`Function`对象中，最后将其加入到当前`Module`对象中的`functions`列表。
- 如果子节点是`declaration`，说明这是一个全局变量，就新建一个`Data`对象，再访问该`declaration`节点，从而将该全局变量的前端信息存入`Data`对象中，最后将其加入到当前`Module`对象中的`global_data`列表。

### parameter_list
对于`parameter_list`节点，可以把前几个寄存器编号分配给参数。
- 如果是标量参数，要另外在栈上开空间。
- 如果是数组参数，则可以直接保存在寄存器中。

### declaration
对于`declaration`节点，需要根据是否为全局变量、是否为数组来进行处理。

如果有初始化，
- 对于标量，需要访问`expression`节点并获取其**运算结果**对应的寄存器，然后新增`Store`指令，表示将得到的寄存器的值存入该标量对应的地址。
- 对于数组则需要遍历`Integer`节点，并分别使用`Store`指令将数组元素存入数组的相应地址，对于全局变量可以考虑是否加入`.bss`段。

### expression
访问`expression`节点之后需要返回存有其**运算结果**的寄存器，方便后续使用。以下分两种情况进行处理：
- `unary '=' expression`，表示赋值表达式。
  - 对于等号左边，访问该`左值`节点并获取其**对应地址**的寄存器。
  - 对于等号右边，访问该`expression`节点并获取其**运算结果**对应的寄存器。
  - 最后新增`Store`指令，表示将右边的寄存器里的值存入左边的寄存器里的地址，并返回左边的寄存器。
- `conditional`，表示条件表达式。
  - 如果这是个三目运算符，可参考`if`节点的处理方式，区别在于，对于`:?`运算符，`then` 和 `else` 是两个表达式节点，对于`if`语句，这两个变量是两个语句节点。
  - 如果这是个`logical_or`节点，则直接访问`logical_or`节点，由于可能出现逻辑短路的情况，所以你需要思考如何新增`Branch`指令来进行分支跳转，可以参考[短路求值]()。

### if
- 先给当前函数新增一个基本块`true_bb`表示`if`语句的`true`分支。
- 如果有`else`部分，则给当前函数新增一个基本块`false_bb`表示`if`语句的`false`分支。
- 给当前函数新增一个基本块`next_bb`表示`if`之后的基本块。
- 分支条件是一个`expression`节点，访问该`expression`节点并获取其**运算结果**对应的寄存器。
  - 由于`expression`节点可能出现逻辑短路的情况，所以你需要思考如何新增`Branch`指令来进行分支跳转，可以参考[短路求值]()。
- 将当前基本块改为`true_bb`，然后访问`true`分支的前端节点，再新增一个`Jump`指令，表示从`true_bb`跳转到`next_bb`。
- 如果有`else`部分，则将当前基本块改为`false_bb`，然后访问`false`分支的前端节点，再新增一个`Jump`指令，表示从`false_bb`跳转到`next_bb`。
- 最后将当前基本块改为`next_bb`。

### while
这里的翻译方式采用的是[step8的思考题](../../step8/example.md)中的第二种。**在翻译过程中，你还要维护好循环所需的`break/continue`标签。**
- 先给当前函数新增一个基本块`cond_bb`表示第一个 `while`语句的条件部分。
- 给当前函数新增一个基本块`body_bb`表示`while`语句的循环体。
- 给当前函数新增一个基本块`body_cond_bb`表示第二个 `while`语句的条件部分。
- 给当前函数新增一个基本块`next_bb`表示`while`之后的基本块。
- 新增一个`Jump`指令，表示从当前基本块跳转到`cond_bb`，然后将当前基本块改为`cond_bb`。
- 分支条件是一个`expression`节点，可以直接访问该`expression`节点。
  - 由于`expression`节点可能出现逻辑短路的情况，所以你需要思考如何新增`Branch`指令来进行分支跳转，可以参考[短路求值]()进行学习。
- 将当前基本块改为`body_bb`，然后访问`true`分支的前端节点，再新增一个`Jump`指令，表示从`body_bb`跳转到`body_cond_bb`。
- 将当前基本块改为`body_cond_bb`，分支条件是一个`expression`节点，访问该`expression`节点并获取其**运算结果**对应的寄存器。
  - 由于`expression`节点可能出现逻辑短路的情况，所以你需要思考如何新增`Branch`指令来进行分支跳转，可以参考[短路求值]()进行学习。
- 最后将当前基本块改为`next_bb`。

### 左值
`左值`节点可能出现的地方为：`assignment`的等号左边部分、`expression`的某个部分，如果是后者且该节点表示的是一个具体值，则返回**存有该值**的寄存器，否则返回其**对应地址**的寄存器。（下面会对“表示的是一个具体值”进行解释）
- 先通过前端变量到IR的`Data`对象的映射表，找到该节点所表示的前端变量对应的`Data`对象。
  - 如果这是个全局变量，则新增`LoadAddr`指令，表示加载全局变量的地址，获取**对应地址**的寄存器
  - 如果这是个局部变量，则直接通过`Data`对象获取**对应地址**的寄存器
- 如果这是个数组，那么前端节点应该会记录下标，每个下标都是`expression`节点，故需要访问每个下标节点，获取其**运算结果**对应的寄存器，可以将这些寄存器存起来，比如存进`index_temps`中，之后再利用这些信息来构造相应的`GetElementPtr`指令，表示通过数组基地址和下标获取元素的**地址**。
- 目前不管是全局变量还是局部变量，不管是标量还是数组，我们得到的都是存有其**对应地址**的寄存器，需要根据具体情况确定返回内容。
  - 如果该`左值`节点是`expression`的某个部分，且表示的是一个具体值，则先新增`Load`指令，表示将地址里的值加载到一个寄存器中，最后返回这个寄存器；否则，就直接返回其**对应地址**的寄存器。
  - 什么是“表示的是一个具体值”？举个例子，如果已知有一个数组`a[2][3]`，那么如果该`左值`节点表示的是`a[1][2]`，则表示的是一个具体值，如果表示的是`a`、`a[0]`，则不是一个具体值而是一个地址。

## 预期目标

完成这部分内容后，你的编译器应该能将 MiniDecaf 程序翻译成 IR，并能够输出 IR。进一步地，如果你希望参加性能评测，你还需要实现一些中端优化。

